# 项目计划（先补丁合并，再恢复与同步）

你说得对：现在不要急着“讲明白整个系统/下结论”。

站在用户视角，我们先把最核心的两件事规划清楚：

- 计划 A：把 `history_html/history.html` 的“恢复/补丁合并”做稳（恢复书签树，改动最小，对记录/推荐影响最小）
- 计划 B：把“备份历史（云端1/云端2/本地归档）”当成一个可同步的版本库/数据库来设计（后面再扩展到更多用户数据）

---

## 计划 A：补丁合并（最小改动恢复书签树）

### A0. 用户要的是什么（验收口径）
- 在 `history_html/history.html` 的“备份历史”里，选择任意版本点击“恢复”能稳定成功
- 尽量不重建书签：能 move 就 move，能 update 就 update，能对齐就不 delete+create
- 目标不是恢复“推荐/记录数据库本身”，而是：**恢复书签后，这些功能受到的冲击尽量小**（核心就是：尽量保留 bookmarkId）

### A1. 为什么要补丁合并（而不是覆盖恢复）
- 覆盖恢复会清空并重建树，`bookmarkId` 大幅变化，会让依赖 `bookmarkId` 的数据（推荐/复习/屏蔽/翻阅/部分记录）出现“对不上/失效”的体验
- 补丁合并的意义就是：**恢复到目标版本，同时尽量保持现有节点的 ID 不变**

### A2. 现状（代码入口）
- history 页面恢复：`history_html/history.js` -> `executeMergeRestoreToSnapshot()`
- 主 UI 恢复：`background.js` -> `executePatchBookmarkRestore()`
- 目前主 UI patch 的关键依赖：`normalizeTreeIds()`（尽力把 targetTree 的 id 对齐到 currentTree）

### A3. 当前补丁合并不稳的根因
核心问题不是“增删改移怎么做”（你们已有），而是：

- 当 targetTree 的 id 和 currentTree 的 id 不一致时，**如何稳定判断“这是同一个书签/文件夹”**
- 如果身份对不上：move/update/delete 就可能错对象，或退化成大规模重建（反而影响更大）

### A4. 方案方向（不要求你理解 Git，只落地一个更稳的“匹配层”）
我们把补丁合并拆成两层：

- 匹配层：把 targetTree 的节点尽量匹配到 currentTree 的“同一个对象”（即使 id 不同）
- 执行层：使用你们已有的 create/move/update/delete 来做最小改动恢复

匹配层要引入一个“稳定身份 key”（运行时计算，不写回书签）：

- 书签 key（bookmarkKey）：`url + title(规范化)`
- 文件夹 key（folderKey）：`title(规范化) + 结构签名(弱)`
  - 结构签名用于同名文件夹消歧：比如“直接子书签数/子文件夹数 + 子节点部分 key”

并且加入“上下文”辅助匹配：
- pathHint：从根到当前的标题路径（title-only）
- siblingHint：同父级下左右邻居的 key（用于模糊定位）

目标：在 id 不可靠时，也尽量找到“同一对象”，从而保 ID、做最小改动。

### A5. Phase A（先做 history_html，优先级最高）
目标文件：`history_html/history.js`

实施步骤：

1) 建索引（对 currentTree 和 targetTree 都做一次）
- byId：id -> nodeInfo
- byBookmarkKey / byFolderKey：key -> candidates[]（注意是多值）
- byPath：path -> candidates[]

2) 做匹配（target -> current）
匹配顺序（从强到弱，尽量保守）：
- id 精确匹配（类型一致）
- key + 强上下文（父路径/父 key 一致 + 邻居相似）
- key 唯一匹配（只有一个候选）
- path 唯一匹配（兜底，极少用）

3) 生成“补丁计划”（明确列出要做的操作）
- createFolder/createBookmark
- move
- update
- deleteTree

4) 安全执行顺序（减少误操作与连锁影响）
- 先 create folders（按深度 parent-first）
- 再 create bookmarks
- 再 move（先跨父级，再同父级排序）
- 再 update
- 最后 delete（有歧义的一律不删）

5) 冲突/歧义策略（非常关键）
- 只要出现“候选不唯一”，就标记 conflict
- conflict 节点：不 delete、不 move（最多 create 缺失项）
- 这样宁可“少恢复一点”，也不要“错删/错移”（这是用户最不能接受的）

6) 执行后校验
- 重新 `bookmarks.getTree()`，核对：能匹配的节点 title/url/parent/index 是否对齐
- 输出统计：created/moved/updated/deleted/conflicts/skipped

### A6. Phase B（再做主 UI 的 patch）
目标文件：`background.js`

- 把 Phase A 的匹配层/补丁计划/执行顺序复用过来
- 最好抽一个共享模块（例如 `utils/patch-merge-core.js`，MV3 可 import）
  - 让 `history_html/history.js` 和 `background.js` 走同一套逻辑，避免两份实现漂移

### A7. 验收用例（必须覆盖）
- add / delete / move（跨目录）/ rename(title) / url change
- 重名文件夹、同 URL 多处出现（歧义必须不乱删）
- move+rename 同时发生
- 大树性能（5k+）
- 核心指标：补丁合并后 `bookmarkId` 变化尽量少（对“记录/推荐”影响才会小）

---

## 计划 B：恢复与同步（把“备份历史”当成可同步版本库/数据库）

这部分先做“架构计划”，不急着动代码；等计划 A 稳了再逐步落地。

### B0. 用户要的是什么（验收口径）
- 主 UI（设置与初始化）里的“备份历史”能稳定跨端使用：
  - 云端1（WebDAV）/云端2（GitHub）/本地归档 三者之间能同步/合并
  - 用户在任意端都能看到同一批历史版本，并能选择任意版本恢复
- 不需要纠结“同步哪个版本”：
  - 更像“同步一个数据库/版本库”，版本只是库里的对象

### B1. 现状（已经有的能力）
- 已经有“扫描并解析恢复源”的统一入口：`background.js` -> `scanAndParseRestoreSource()`
  - 能从：合并历史 JSON、归档 ZIP、HTML 快照 收集“可恢复版本列表”
- 已经有 restoreRef（source/sourceType/fileUrl/zipEntryName 等）可定位到具体版本内容

### B2. 我们要补齐的关键：把备份历史当成“对象库 + 索引”
建议把备份历史抽象成两类文件：

- 对象（records）：每次备份生成的“不可变”记录（包含 bookmarkTree + 元数据）
- 索引（index/manifest）：告诉你“库里有哪些版本”、各版本的元数据、去重 id、来源等

这样同步逻辑就清晰：
- 同步 = 拉取/推送对象 + 合并索引
- 恢复 = 从索引里选一个版本，再用 restoreRef 定位到对象内容

### B3. 去重与合并原则（避免重复/冲突）
- 每条备份记录需要一个稳定的去重 key（推荐优先使用 `fingerprint`，其次 time+seqNumber）
- 合并时：以去重 key 为准做 union；不要简单用 time 覆盖（time 可能冲突）
- 删除策略：先不做“远端删除同步”（避免误删），只做追加与合并；清理留到后续 GC（垃圾回收）阶段

### B4. 多端同步最小落地（v1）
先只同步“备份历史（书签树版本库）”，不把推荐/记录/画布一起版本化。

v1 目标：
- 云端1/云端2/本地三方都能：
  - pull：把对方新产生的 records 拉下来
  - push：把本地产生的新 records 推上去
  - merge：合并索引，用户能看到统一版本列表

### B5. 多用户/登录（先设计，不急实现）
要做多用户，关键不是 UI，而是“数据隔离 + 路径命名空间”。

建议：
- 每个用户一个 remoteRoot（路径前缀），例如：`/users/<userId>/...`
- 本地 `chrome.storage.local` 的 key 也按 userId 分区（或把 userId 写入 value 内的顶层字段）
- 后续如果要“安全同步”，再加：端到端加密/密钥管理（这是更后面阶段）

### B6. v2/v3（未来扩展点）
当 v1 稳定后，再把以下“扩展数据库”逐步纳入“统一快照”：
- 推荐：屏蔽/待复习/复习记录/卡片状态等
- 书签记录/点击记录
- 书签画布
- 时间追踪统计

注意：这些数据很多依赖 bookmarkId，跨设备/覆盖恢复会断链。
因此它们要进统一快照之前，需要先定义“跨版本/跨设备的稳定映射策略”。

---

## 当前下一步（建议按顺序）
1) 我先把 Phase A 的“匹配层 + 补丁计划 + 安全执行顺序”在 `history_html/history.js` 落地（只改补丁合并，不碰同步）
2) 你验收：恢复是否更稳、误删/错移是否消失、ID 变化是否显著减少
3) 再进入主 UI 的 patch 复用（Phase B）
4) 最后开始落地计划 B（恢复与同步的版本库化）
