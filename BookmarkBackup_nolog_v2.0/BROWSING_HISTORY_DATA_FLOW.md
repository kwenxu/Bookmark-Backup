# 书签浏览记录数据流程图

## 📊 完整数据流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    用户打开插件 history.html                     │
│                 点击「书签温故」→「书签浏览记录」               │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│              首次点击「点击记录」子标签                          │
│        调用 initBrowsingHistoryCalendar()                       │
│        创建 window.browsingHistoryCalendarInstance              │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│                    BrowsingHistoryCalendar 初始化                │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  1. 尝试从持久化存储恢复缓存                            │  │
│  │     chrome.storage.local.get('bb_cache_browsing_history_v1') │
│  │                                                            │  │
│  │  2a. 如果缓存存在（historyCacheRestored = true）        │  │
│  │      → 恢复 bookmarksByDate (Map)                        │  │
│  │      → 恢复 visitKeySet (Set)                            │  │
│  │      → 立即渲染界面                                      │  │
│  │      → 后台增量更新（startTime = lastSyncTime - 60s）   │  │
│  │                                                            │  │
│  │  2b. 如果缓存不存在                                      │  │
│  │      → 全量加载历史记录（调用 browserAPI.history.search）│  │
│  └──────────────────────────────────────────────────────────┘  │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│              loadBookmarkData({ incremental: false/true })       │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  步骤1：获取当前所有书签                                │  │
│  │  ├─ bookmarkUrls (Set)                                   │  │
│  │  └─ bookmarkTitles (Set)                                 │  │
│  │                                                            │  │
│  │  步骤2：调用浏览器历史记录API                           │  │
│  │  browserAPI.history.search({                             │  │
│  │    text: '',                                             │  │
│  │    startTime: incremental ? lastSyncTime - 60s : 0,      │  │
│  │    maxResults: 0  // 不限制                              │  │
│  │  })                                                       │  │
│  │                                                            │  │
│  │  步骤3：过滤匹配书签的历史记录                          │  │
│  │  relevantHistoryItems = historyItems.filter(item => {   │  │
│  │    // 条件1：URL匹配                                     │  │
│  │    if (bookmarkUrls.has(item.url)) return true;         │  │
│  │    // 条件2：标题匹配                                    │  │
│  │    if (bookmarkTitles.has(item.title.trim())) return true;│ │
│  │  })                                                       │  │
│  │                                                            │  │
│  │  步骤4：获取每个URL的详细访问记录                       │  │
│  │  for each relevantHistoryItem:                           │  │
│  │    browserAPI.history.getVisits({ url })                 │  │
│  │    → 获取每次访问的时间戳、referrer等                   │  │
│  │    → 最多保留 400 条访问记录（BROWSING_HISTORY_MAX_VISITS_PER_URL）│
│  │                                                            │  │
│  │  步骤5：存储到 bookmarksByDate                           │  │
│  │  bookmarksByDate: Map<'YYYY-MM-DD', Record[]>            │  │
│  │  visitKeySet: Set<'url|visitTime'> （去重）             │  │
│  │                                                            │  │
│  │  步骤6：清理超过365天的旧记录                            │  │
│  │  pruneOldRecords(cutoffTime)                             │  │
│  │                                                            │  │
│  │  步骤7：保存到持久化存储                                 │  │
│  │  chrome.storage.local.set({                              │  │
│  │    'bb_cache_browsing_history_v1': {                     │  │
│  │      lastSyncTime: Date.now(),                           │  │
│  │      records: [...bookmarksByDate]                       │  │
│  │    }                                                      │  │
│  │  })                                                       │  │
│  │                                                            │  │
│  │  步骤8：派发更新事件                                     │  │
│  │  document.dispatchEvent(                                 │  │
│  │    new CustomEvent('browsingHistoryCacheUpdated')        │  │
│  │  )                                                        │  │
│  └──────────────────────────────────────────────────────────┘  │
└──────────────────────────┬──────────────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ↓                  ↓                  ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────────┐
│ 点击记录     │  │ 点击排行     │  │ 书签关联记录     │
│ 标签页       │  │ 标签页       │  │ 标签页           │
└──────────────┘  └──────────────┘  └──────────────────┘
```

---

## 🎯 三个标签页的数据依赖关系

```
┌─────────────────────────────────────────────────────────────────┐
│                  BrowsingHistoryCalendar 实例                    │
│                                                                  │
│  核心数据结构：                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ bookmarksByDate: Map<'YYYY-MM-DD', Record[]>             │  │
│  │                                                            │  │
│  │ 只包含与书签匹配的历史记录：                              │  │
│  │ {                                                          │  │
│  │   url: string,                                            │  │
│  │   title: string,                                          │  │
│  │   visitTime: number,  // 每次访问的时间戳                │  │
│  │   visitCount: number, // 该次访问的计数                  │  │
│  │   dateAdded: Date,    // 访问日期                        │  │
│  │   folderPath: []      // 空（用于兼容）                  │  │
│  │ }                                                          │  │
│  └──────────────────────────────────────────────────────────┘  │
└──────┬───────────────────────────────┬───────────────────┬──────┘
       │                               │                   │
       │ 直接使用                      │ 提取+统计        │ 提取书签集合
       │                               │                   │
       ↓                               ↓                   ↓
┌─────────────────┐         ┌──────────────────┐   ┌──────────────────────┐
│  ①点击记录      │         │  ②点击排行       │   │  ③书签关联记录       │
│  标签页         │         │  标签页          │   │  标签页              │
├─────────────────┤         ├──────────────────┤   ├──────────────────────┤
│ 数据源：         │         │ 数据源：          │   │ 数据源1：            │
│ bookmarksByDate │         │ bookmarksByDate  │   │ browserAPI.history    │
│                 │         │                  │   │ .search()             │
│ 显示方式：       │         │ 处理方式：        │   │ (所有历史记录)       │
│ - 按日期分组    │         │ 1. 遍历所有记录  │   │                      │
│ - 按时间排序    │         │ 2. 统计每个URL   │   │ 数据源2：            │
│ - 日历视图      │         │    的访问次数    │   │ 从bookmarksByDate    │
│                 │         │ 3. 按时间范围    │   │ 提取书签集合         │
│ 功能：           │         │    (day/week/    │   │ - bookmarkUrls (Set) │
│ - 显示书签的    │         │    month/year)   │   │ - bookmarkTitles(Set)│
│   访问记录      │         │    筛选          │   │                      │
│ - 日/周/月/年   │         │ 4. 排序显示      │   │ 显示方式：           │
│   视图切换      │         │    Top 50        │   │ - 显示所有历史记录   │
│ - 导出功能      │         │                  │   │ - 用黄色边框标识书签 │
│                 │         │ 显示：           │   │ - 按时间排序         │
│                 │         │ URL + 标题       │   │                      │
│                 │         │ 访问次数         │   │ 功能：               │
│                 │         │ 最后访问时间     │   │ - 完整历史记录浏览   │
│                 │         │                  │   │ - 识别哪些是书签     │
└─────────────────┘         └──────────────────┘   └──────────────────────┘

  数据关系：             数据关系：              数据关系：
  100% 依赖              100% 依赖              历史记录：独立API调用
  bookmarksByDate        bookmarksByDate        书签标识：复用bookmarksByDate
```

---

## ⚡ 实时更新机制

```
┌─────────────────────────────────────────────────────────────────┐
│                    用户浏览网页（访问书签）                      │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ↓
                  chrome.history.onVisited
                     事件触发
                           │
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│               handleHistoryVisited(result)                       │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  1. 检查 result.url 是否在 bookmarkUrlSet 中            │  │
│  │     bookmarkUrlSet 由 rebuildBookmarkUrlSet() 维护       │  │
│  │     包含当前所有书签的URL                                │  │
│  │                                                            │  │
│  │  2. 如果在书签集合中：                                   │  │
│  │     scheduleHistoryRefresh({ forceFull: false })         │  │
│  │                                                            │  │
│  │  3. 如果不在书签集合中：                                 │  │
│  │     跳过刷新（非书签访问不触发更新）                     │  │
│  └──────────────────────────────────────────────────────────┘  │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ↓ (500ms 防抖)
┌─────────────────────────────────────────────────────────────────┐
│           refreshBrowsingHistoryData({ forceFull: false })       │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  1. 调用 calendar.loadBookmarkData({ incremental: true })│  │
│  │     → 只查询 lastSyncTime 之后的新记录                  │  │
│  │     → 过滤匹配书签的记录                                 │  │
│  │     → 追加到 bookmarksByDate                             │  │
│  │     → 保存到持久化存储                                   │  │
│  │                                                            │  │
│  │  2. 重建 bookmarkUrlSet                                   │  │
│  │     rebuildBookmarkUrlSet()                               │  │
│  │     （为下次实时更新判断做准备）                         │  │
│  │                                                            │  │
│  │  3. 渲染日历视图                                          │  │
│  │     calendar.render()                                     │  │
│  │                                                            │  │
│  │  4. 清除点击排行缓存                                      │  │
│  │     browsingClickRankingStats = null                      │  │
│  └──────────────────────────────────────────────────────────┘  │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ↓
          announceHistoryDataUpdated()
                           │
                           ↓
        document.dispatchEvent('browsingHistoryCacheUpdated')
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ↓                  ↓                  ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────────┐
│ 点击记录     │  │ 点击排行     │  │ 书签关联记录     │
│ 自动刷新     │  │ 清除缓存     │  │ 自动刷新         │
│ (render())   │  │ 下次点击     │  │ (重新加载)       │
│              │  │ 重新统计     │  │                  │
└──────────────┘  └──────────────┘  └──────────────────┘
```

---

## 🔄 数据更新时机汇总

| 更新场景 | 触发条件 | 更新类型 | 影响范围 |
|---------|---------|---------|---------|
| **首次打开** | 点击「点击记录」标签 | 全量加载 | 从0开始加载所有历史 |
| **缓存恢复** | 有缓存时打开标签 | 立即显示+后台增量 | 先显示缓存，再更新 |
| **访问书签网页** | onVisited 事件 | 增量更新 | 只查询新记录 |
| **切换标签** | 点击不同子标签 | 使用现有数据 | 无需重新加载 |
| **手动刷新** | 用户点击刷新按钮 | 增量更新 | 查询最近更新 |

---

## 💾 持久化存储结构

```javascript
chrome.storage.local.set({
  'bb_cache_browsing_history_v1': {
    lastSyncTime: 1732435200000,  // 最后同步时间戳
    records: [
      ['2025-11-24', [             // 按日期分组
        {
          id: 'xxx-123',
          url: 'https://example.com',
          title: '示例网页',
          dateAdded: 1732435000000,  // 访问日期
          visitTime: 1732435000000,  // 访问时间戳
          visitCount: 1,             // 该次访问计数
          typedCount: 0,
          folderPath: [],
          transition: 'link',
          referringVisitId: null,
          aggregated: false
        },
        // ... 该日期的其他访问记录
      ]],
      ['2025-11-23', [...]], // 其他日期
      // ...
    ]
  }
})
```

---

## 🎯 关键点说明

### 1. 为什么要过滤？
`bookmarksByDate` 只存储**与书签匹配**的历史记录，原因：
- 节省存储空间（365天只存书签相关记录）
- 加快加载速度（过滤后数据量小）
- 精准统计（点击排行只统计书签）

### 2. 书签关联页面为什么不直接用 bookmarksByDate？
因为需求是：
- 显示**所有**历史记录（包括非书签）
- 只是用黄色边框**标识**哪些是书签

所以：
- 历史记录：独立调用 API（`maxResults: 0` 不限制）
- 书签标识：复用 bookmarksByDate 的书签集合

### 3. 实时更新如何工作？
```
访问书签 → onVisited → 检查bookmarkUrlSet 
         ↓ (在集合中)
   安排刷新(500ms防抖) → 增量加载 → 更新缓存 
         ↓
   派发事件 → 三个标签页刷新
```

### 4. bookmarkUrlSet 的作用
- 快速判断某个URL是否是书签（O(1)查询）
- 用于实时更新时的过滤条件
- 每次 `refreshBrowsingHistoryData` 后重建

---

## 📈 数据流向总览

```
初始化：
  浏览器历史API → 过滤(书签匹配) → bookmarksByDate → 持久化存储
                                        │
                    ┌───────────────────┼───────────────────┐
                    ↓                   ↓                   ↓
                点击记录             点击排行          书签关联记录
               (直接显示)          (统计分析)      (API+标识集合)

实时更新：
  访问书签 → onVisited → 增量查询 → 追加到bookmarksByDate 
                                        ↓
                                    保存缓存
                                        ↓
                                  派发事件
                                        ↓
                          三个标签页自动刷新
```

---

**总结**：
1. ✅ 所有数据都来自一个中心数据源：`browsingHistoryCalendarInstance.bookmarksByDate`
2. ✅ 持久化存储，365天历史记录
3. ✅ 增量实时更新，访问书签自动同步
4. ✅ 三个标签页共享数据，各有不同的展示方式
5. ✅ 书签关联记录特殊：历史记录用独立API，书签标识复用数据源
