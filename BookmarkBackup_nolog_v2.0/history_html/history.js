// =============================================================================
// 全局变量和常量
// =============================================================================

// Unified Export Folder Paths - 统一的导出文件夹路径（根据语言动态选择）
const getHistoryExportRootFolder = () => currentLang === 'zh_CN' ? '书签快照 & 工具箱' : 'Bookmark Git & Toolbox';
const getHistoryExportFolder = () => currentLang === 'zh_CN' ? '备份历史' : 'Bookmarks_History';
const getCurrentChangesExportFolder = () => currentLang === 'zh_CN' ? '当前变化' : 'Current Changes';

let currentLang = 'zh_CN';
window.currentLang = currentLang; // 暴露给其他模块使用
let currentTheme = 'light';

// =============================================================================
// 统一存储架构：historyViewSettings
// 将所有视图设置存储在 chrome.storage.local，替代分散的 localStorage
// 这样 background.js (Service Worker) 也能访问这些设置，实现 WYSIWYG 导出
// =============================================================================
let historyDetailMode = 'simple'; // 默认值，将在初始化时从 chrome.storage.local 加载
let historyViewSettings = null;   // 缓存视图设置对象
let historyViewSettingsSaveTimeout = null; // 防抖保存定时器

// 旧的 localStorage 键前缀（用于迁移）
const HISTORY_DETAIL_MODE_PREFIX = 'historyDetailMode:';
const HISTORY_DETAIL_EXPANDED_PREFIX = 'historyDetailExpanded:';

/**
 * 从 chrome.storage.local 加载视图设置
 * @returns {Promise<Object>} 视图设置对象
 */
async function loadHistoryViewSettings() {
    return new Promise(resolve => {
        const browserAPI = (typeof chrome !== 'undefined' && chrome.storage) ? chrome : (typeof browser !== 'undefined' ? browser : null);
        if (!browserAPI || !browserAPI.storage) {
            console.warn('[历史视图设置] 无法访问 storage API');
            historyViewSettings = { defaultMode: 'simple', recordModes: {}, recordExpandedStates: {} };
            historyDetailMode = 'simple';
            resolve(historyViewSettings);
            return;
        }
        browserAPI.storage.local.get(['historyViewSettings'], result => {
            historyViewSettings = result.historyViewSettings || {
                defaultMode: 'simple',
                recordModes: {},
                recordExpandedStates: {}
            };
            historyDetailMode = historyViewSettings.defaultMode || 'simple';
            console.log('[历史视图设置] 已加载:', {
                defaultMode: historyDetailMode,
                recordModesCount: Object.keys(historyViewSettings.recordModes || {}).length,
                expandedStatesCount: Object.keys(historyViewSettings.recordExpandedStates || {}).length
            });
            resolve(historyViewSettings);
        });
    });
}

/**
 * 保存视图设置到 chrome.storage.local（带防抖 300ms）
 * @returns {Promise<void>}
 */
async function saveHistoryViewSettings() {
    if (historyViewSettingsSaveTimeout) {
        clearTimeout(historyViewSettingsSaveTimeout);
    }
    return new Promise(resolve => {
        historyViewSettingsSaveTimeout = setTimeout(async () => {
            const browserAPI = (typeof chrome !== 'undefined' && chrome.storage) ? chrome : (typeof browser !== 'undefined' ? browser : null);
            if (!browserAPI || !browserAPI.storage || !historyViewSettings) {
                resolve();
                return;
            }
            await new Promise(r => {
                browserAPI.storage.local.set({ historyViewSettings }, r);
            });
            console.log('[历史视图设置] 已保存到 chrome.storage.local');
            resolve();
        }, 300);
    });
}

/**
 * 将 localStorage 中的历史视图设置迁移到 chrome.storage.local
 * 只在首次加载时执行一次
 */
async function migrateHistoryViewSettingsFromLocalStorage() {
    const browserAPI = (typeof chrome !== 'undefined' && chrome.storage) ? chrome : (typeof browser !== 'undefined' ? browser : null);
    if (!browserAPI || !browserAPI.storage) return;

    // 检查是否已迁移
    const result = await new Promise(resolve => {
        browserAPI.storage.local.get(['historyViewSettingsMigrated'], resolve);
    });

    if (result.historyViewSettingsMigrated) {
        console.log('[迁移] 历史视图设置已迁移，跳过');
        return;
    }

    console.log('[迁移] 开始迁移 localStorage 中的历史视图设置...');

    const newSettings = {
        defaultMode: 'simple',
        recordModes: {},
        recordExpandedStates: {}
    };

    try {
        // 迁移全局默认模式
        const defaultMode = localStorage.getItem('historyDetailMode');
        if (defaultMode === 'simple' || defaultMode === 'detailed') {
            newSettings.defaultMode = defaultMode;
        }

        // 遍历 localStorage，找出所有历史相关的 key
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (!key) continue;

            // 迁移每条记录的视图模式
            if (key.startsWith(HISTORY_DETAIL_MODE_PREFIX)) {
                const recordTime = key.replace(HISTORY_DETAIL_MODE_PREFIX, '');
                const mode = localStorage.getItem(key);
                if (mode === 'simple' || mode === 'detailed') {
                    newSettings.recordModes[recordTime] = mode;
                }
            }

            // 迁移每条记录的展开状态
            if (key.startsWith(HISTORY_DETAIL_EXPANDED_PREFIX)) {
                const recordTime = key.replace(HISTORY_DETAIL_EXPANDED_PREFIX, '');
                try {
                    const expandedIds = JSON.parse(localStorage.getItem(key));
                    if (Array.isArray(expandedIds)) {
                        newSettings.recordExpandedStates[recordTime] = expandedIds;
                    }
                } catch (e) { }
            }
        }

        // 保存到 chrome.storage.local
        await new Promise(resolve => {
            browserAPI.storage.local.set({
                historyViewSettings: newSettings,
                historyViewSettingsMigrated: true
            }, resolve);
        });

        // 更新全局变量
        historyViewSettings = newSettings;
        historyDetailMode = newSettings.defaultMode;

        console.log('[迁移] 历史视图设置迁移完成');
        console.log('[迁移] 迁移的数据:', {
            defaultMode: newSettings.defaultMode,
            recordModesCount: Object.keys(newSettings.recordModes).length,
            recordExpandedStatesCount: Object.keys(newSettings.recordExpandedStates).length
        });

    } catch (error) {
        console.error('[迁移] 迁移失败:', error);
    }
}

let currentDetailRecordMode = null;
let currentDetailRecord = null;
let currentExportHistoryTreeContainer = null;
// 从 localStorage 立即恢复视图，避免页面闪烁
// 从 URL 参数或 localStorage 恢复视图
let currentView = (() => {
    try {
        // 1. 优先尝试从 URL 参数获取
        // 注意：此时 window.location.search 可能已经可用
        const params = new URLSearchParams(window.location.search);
        const viewFromUrl = params.get('view');
        if (viewFromUrl) {
            console.log('[全局初始化] URL 参数中的视图:', viewFromUrl);
            return viewFromUrl;
        }

        // 2. 其次尝试从 localStorage 获取
        const saved = localStorage.getItem('lastActiveView');
        console.log('[全局初始化] localStorage中的视图:', saved);
        return saved || 'current-changes';
    } catch (e) {
        console.error('[全局初始化] 读取视图失败:', e);
        return 'current-changes';
    }
})();

// 用于避免重复在一次备份后多次重置（基于最近一条备份记录的指纹或时间）
window.__lastResetFingerprint = window.__lastResetFingerprint || null;

// 用于标记由拖拽操作处理过的移动，防止 applyIncrementalMoveToTree 重复处理
window.__dragMoveHandled = window.__dragMoveHandled || new Set();

// 在 Canvas 永久栏目及 Current Changes 预览中，
// 清理所有颜色标识与动作徽标，不改变布局/滚动/展开状态
function resetPermanentSectionChangeMarkers() {
    try {
        // 支持同时清理：
        // 1) Canvas 视图中的永久栏目
        // 2) Current Changes 视图中的书签树预览（克隆出来的永久栏目）
        const sections = [];
        const permanentSection = document.getElementById('permanentSection');
        const previewSection = document.getElementById('changesPreviewPermanentSection');
        if (permanentSection) sections.push(permanentSection);
        if (previewSection) sections.push(previewSection);
        if (!sections.length) return;

        const changeClasses = ['tree-change-added', 'tree-change-modified', 'tree-change-moved', 'tree-change-mixed', 'tree-change-deleted'];

        sections.forEach(section => {
            // 每个栏目内部都有自己独立的滚动容器和书签树
            const tree =
                section.querySelector('#bookmarkTree') || // Canvas 永久栏目
                section.querySelector('.bookmark-tree');  // Current Changes 预览中的克隆树
            if (!tree) return;

            const body = section.querySelector('.permanent-section-body');
            const prevScrollTop = body ? body.scrollTop : null;

            // 1) 红色（deleted）项目：直接移除对应的 .tree-node
            tree.querySelectorAll('.tree-item.tree-change-deleted').forEach(item => {
                const node = item.closest('.tree-node');
                if (node && node.parentNode) node.parentNode.removeChild(node);
            });

            // 2) 清理其余颜色标识类和内联样式、徽标
            const selector = changeClasses.map(c => `.tree-item.${c}`).join(',');
            tree.querySelectorAll(selector).forEach(item => {
                changeClasses.forEach(c => item.classList.remove(c));
                const link = item.querySelector('.tree-bookmark-link');
                const label = item.querySelector('.tree-label');
                if (link) {
                    link.style.color = '';
                    link.style.fontWeight = '';
                    link.style.textDecoration = '';
                    link.style.opacity = '';
                }
                if (label) {
                    label.style.color = '';
                    label.style.fontWeight = '';
                    label.style.textDecoration = '';
                    label.style.opacity = '';
                }
                const badges = item.querySelector('.change-badges');
                if (badges) badges.innerHTML = '';
            });

            // 3) 清理灰色引导标识 (.change-badge.has-changes)
            // 这些标识可能存在于没有变化类的文件夹节点上（表示"此文件夹下有变化"）
            tree.querySelectorAll('.change-badge.has-changes').forEach(badge => {
                badge.remove();
            });

            // 4) 清理图例（备份后没有变化，无需显示图例）
            const legend = tree.querySelector('.tree-legend');
            if (legend) {
                legend.remove();
            }

            if (body != null && prevScrollTop != null) {
                body.scrollTop = prevScrollTop;
            }
        });

        console.log('[Canvas] 永久栏目及预览颜色标识已清理完毕');
    } catch (e) {
        console.warn('[Canvas] 清理永久栏目/预览标识时出错:', e);
    }
}
console.log('[全局初始化] currentView初始值:', currentView);
let currentFilter = 'all';
let currentTimeFilter = 'all'; // 'all', 'year', 'month', 'day'
let allBookmarks = [];
let syncHistory = [];
let lastBackupTime = null;
let currentBookmarkData = null;
let browsingClickRankingStats = null; // 点击排行缓存（基于浏览器历史记录）

const bookmarkUrlSet = new Set();
const bookmarkTitleSet = new Set(); // 书签标题集合（用于标题匹配的实时刷新）
let pendingHistoryRefreshTimer = null;
let pendingHistoryRefreshForceFull = false;

const DATA_CACHE_KEYS = {
    additions: 'bb_cache_additions_v1'
};

let additionsCacheRestored = false;
let saveAdditionsCacheTimer = null;
let browsingHistoryRefreshPromise = null;

// 预加载缓存
let cachedBookmarkTree = null;
let cachedCurrentChanges = null;
let isPreloading = false;

// 图标预加载缓存
const preloadedIcons = new Map();
const iconPreloadQueue = [];

// Favicon 缓存管理（持久化 + 失败缓存）
const FaviconCache = {
    db: null,
    dbName: 'BookmarkFaviconCache',
    dbVersion: 1,
    storeName: 'favicons',
    failureStoreName: 'failures',
    memoryCache: new Map(), // {url: faviconDataUrl}
    failureCache: new Set(), // 失败的域名集合
    pendingRequests: new Map(), // 正在请求的URL，避免重复请求

    // 初始化 IndexedDB
    async init() {
        if (this.db) return;

        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onerror = () => {
                reject(request.error);
            };

            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // 创建成功缓存的存储
                if (!db.objectStoreNames.contains(this.storeName)) {
                    const store = db.createObjectStore(this.storeName, { keyPath: 'domain' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }

                // 创建失败缓存的存储
                if (!db.objectStoreNames.contains(this.failureStoreName)) {
                    const failureStore = db.createObjectStore(this.failureStoreName, { keyPath: 'domain' });
                    failureStore.createIndex('timestamp', 'timestamp', { unique: false });
                }
            };
        });
    },

    // 检查URL是否为本地/内网/明显无效
    isInvalidUrl(url) {
        if (!url || typeof url !== 'string') return true;

        try {
            const urlObj = new URL(url);
            const hostname = urlObj.hostname.toLowerCase();

            // 本地地址
            if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '::1') {
                return true;
            }

            // 内网地址
            if (hostname.match(/^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/)) {
                return true;
            }

            // .local 域名
            if (hostname.endsWith('.local')) {
                return true;
            }

            // 文件协议等
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                return true;
            }

            return false;
        } catch (e) {
            return true;
        }
    },

    // 从缓存获取favicon
    async get(url) {
        if (this.isInvalidUrl(url)) {
            return null;
        }

        try {
            const urlObj = new URL(url);
            const domain = urlObj.hostname;

            // 检查失败缓存
            if (this.failureCache.has(domain)) {
                return 'failed';
            }

            // 检查内存缓存
            if (this.memoryCache.has(domain)) {
                return this.memoryCache.get(domain);
            }

            // 从 IndexedDB 读取
            if (!this.db) await this.init();

            return new Promise((resolve) => {
                const transaction = this.db.transaction([this.storeName, this.failureStoreName], 'readonly');

                // 先检查失败缓存
                const failureStore = transaction.objectStore(this.failureStoreName);
                const failureRequest = failureStore.get(domain);

                failureRequest.onsuccess = () => {
                    if (failureRequest.result) {
                        // 检查失败缓存是否过期（7天）
                        const age = Date.now() - failureRequest.result.timestamp;
                        if (age < 7 * 24 * 60 * 60 * 1000) {
                            this.failureCache.add(domain);
                            resolve('failed');
                            return;
                        }
                    }

                    // 检查成功缓存
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(domain);

                    request.onsuccess = () => {
                        if (request.result) {
                            // 永久缓存，不检查过期（只有删除书签时才删除缓存）
                            this.memoryCache.set(domain, request.result.dataUrl);
                            resolve(request.result.dataUrl);
                        } else {
                            resolve(null);
                        }
                    };

                    request.onerror = () => resolve(null);
                };

                failureRequest.onerror = () => resolve(null);
            });
        } catch (e) {
            return null;
        }
    },

    // 保存favicon到缓存
    async save(url, dataUrl) {
        if (this.isInvalidUrl(url)) return;

        try {
            const urlObj = new URL(url);
            const domain = urlObj.hostname;

            // 更新内存缓存
            this.memoryCache.set(domain, dataUrl);

            // 保存到 IndexedDB
            if (!this.db) await this.init();

            const transaction = this.db.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);

            store.put({
                domain: domain,
                dataUrl: dataUrl,
                timestamp: Date.now()
            });

            // 从失败缓存中移除（如果存在）
            this.failureCache.delete(domain);
            this.removeFailure(domain);

        } catch (e) {
            // 静默处理
        }
    },

    // 记录失败
    async saveFailure(url) {
        if (this.isInvalidUrl(url)) return;

        try {
            const urlObj = new URL(url);
            const domain = urlObj.hostname;

            // 更新内存缓存
            this.failureCache.add(domain);

            // 保存到 IndexedDB
            if (!this.db) await this.init();

            const transaction = this.db.transaction([this.failureStoreName], 'readwrite');
            const store = transaction.objectStore(this.failureStoreName);

            store.put({
                domain: domain,
                timestamp: Date.now()
            });

        } catch (e) {
            // 静默处理
        }
    },

    // 移除失败记录（当URL被修改时）
    async removeFailure(domain) {
        try {
            if (!this.db) await this.init();

            const transaction = this.db.transaction([this.failureStoreName], 'readwrite');
            const store = transaction.objectStore(this.failureStoreName);
            store.delete(domain);
        } catch (e) {
            // 静默失败
        }
    },

    // 清除特定URL的缓存（用于书签URL修改时）
    async clear(url) {
        if (this.isInvalidUrl(url)) return;

        try {
            const urlObj = new URL(url);
            const domain = urlObj.hostname;

            // 清除内存缓存
            this.memoryCache.delete(domain);
            this.failureCache.delete(domain);

            // 清除 IndexedDB
            if (!this.db) await this.init();

            const transaction = this.db.transaction([this.storeName, this.failureStoreName], 'readwrite');
            transaction.objectStore(this.storeName).delete(domain);
            transaction.objectStore(this.failureStoreName).delete(domain);

        } catch (e) {
            // 静默处理
        }
    },

    // 获取favicon（带缓存和请求合并）
    async fetch(url) {
        if (this.isInvalidUrl(url)) {
            return fallbackIcon;
        }

        try {
            const urlObj = new URL(url);
            const domain = urlObj.hostname;

            // 1. 检查缓存
            const cached = await this.get(url);
            if (cached === 'failed') {
                return fallbackIcon;
            }
            if (cached) {
                return cached;
            }

            // 2. 检查是否已有相同请求在进行中（避免重复请求）
            if (this.pendingRequests.has(domain)) {
                return this.pendingRequests.get(domain);
            }

            // 3. 发起新请求
            const requestPromise = this._fetchFavicon(url);
            this.pendingRequests.set(domain, requestPromise);

            try {
                const result = await requestPromise;
                return result;
            } finally {
                this.pendingRequests.delete(domain);
            }

        } catch (e) {
            return fallbackIcon;
        }
    },

    // 实际请求favicon - 多源降级策略
    // 注意：不再直接请求网站的 /favicon.ico，因为某些网站（如需要认证的网站）
    // 可能返回 HTML 页面而非图标，导致浏览器解析其中的 preload 标签并产生警告
    async _fetchFavicon(url) {
        return new Promise(async (resolve) => {
            try {
                const urlObj = new URL(url);
                const domain = urlObj.hostname;

                // 定义多个 favicon 源，按优先级尝试
                // 只使用第三方服务，避免直接请求可能返回 HTML 的网站
                const faviconSources = [
                    // 1. DuckDuckGo（全球可用，国内可访问，推荐首选）
                    `https://icons.duckduckgo.com/ip3/${domain}.ico`,
                    // 2. Google S2（功能强大，但中国大陆被墙）
                    `https://www.google.com/s2/favicons?domain=${domain}&sz=32`
                ];

                // 尝试每个源
                for (let i = 0; i < faviconSources.length; i++) {
                    const faviconUrl = faviconSources[i];
                    const sourceName = ['DuckDuckGo', 'Google S2'][i];

                    const result = await this._tryLoadFavicon(faviconUrl, url, sourceName);
                    if (result && result !== fallbackIcon) {
                        resolve(result);
                        return;
                    }
                }

                // 所有源都失败，记录失败并返回 fallback（静默）
                this.saveFailure(url);
                resolve(fallbackIcon);

            } catch (e) {
                // 静默处理错误
                this.saveFailure(url);
                resolve(fallbackIcon);
            }
        });
    },

    // 尝试从单个源加载 favicon
    async _tryLoadFavicon(faviconUrl, originalUrl, sourceName) {
        return new Promise((resolve) => {
            const img = new Image();
            // 不设置 crossOrigin，避免 CORS 预检请求导致的错误
            // img.crossOrigin = 'anonymous';

            const timeout = setTimeout(() => {
                img.src = '';
                resolve(null); // 超时，尝试下一个源
            }, 3000); // 每个源最多等待3秒

            img.onload = () => {
                clearTimeout(timeout);

                // 检查是否是有效的图片（某些服务器返回1x1的占位图）
                if (img.width < 8 || img.height < 8) {
                    resolve(null);
                    return;
                }

                // 尝试转换为 Base64（可能因 CORS 失败，但不显示错误）
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const dataUrl = canvas.toDataURL('image/png');

                    // 保存到缓存
                    this.save(originalUrl, dataUrl);
                    resolve(dataUrl);
                } catch (e) {
                    // CORS 限制，直接使用原 URL（静默处理，不输出日志）
                    this.save(originalUrl, faviconUrl);
                    resolve(faviconUrl);
                }
            };

            img.onerror = () => {
                clearTimeout(timeout);
                resolve(null); // 失败，尝试下一个源
            };

            img.src = faviconUrl;
        });
    }
};

// 浏览器 API 兼容性
const browserAPI = (typeof chrome !== 'undefined') ? chrome : browser;

function getCacheStorageArea() {
    try {
        if (browserAPI && browserAPI.storage && browserAPI.storage.local) {
            return browserAPI.storage.local;
        }
    } catch (_) {
        // ignore
    }
    return null;
}

function readCachedValue(key) {
    return new Promise((resolve) => {
        const storageArea = getCacheStorageArea();
        if (storageArea) {
            storageArea.get([key], (result) => {
                if (browserAPI.runtime && browserAPI.runtime.lastError) {
                    console.warn('[Cache] 读取失败:', browserAPI.runtime.lastError.message);
                    resolve(null);
                    return;
                }
                resolve(result ? result[key] : null);
            });
            return;
        }

        try {
            const raw = localStorage.getItem(key);
            resolve(raw ? JSON.parse(raw) : null);
        } catch (error) {
            console.warn('[Cache] 读取 localStorage 失败:', error);
            resolve(null);
        }
    });
}

function writeCachedValue(key, value) {
    return new Promise((resolve) => {
        const storageArea = getCacheStorageArea();
        if (storageArea) {
            storageArea.set({ [key]: value }, () => {
                if (browserAPI.runtime && browserAPI.runtime.lastError) {
                    console.warn('[Cache] 写入失败:', browserAPI.runtime.lastError.message);
                }
                resolve();
            });
            return;
        }

        try {
            localStorage.setItem(key, JSON.stringify(value));
        } catch (error) {
            console.warn('[Cache] 写入 localStorage 失败:', error);
        }
        resolve();
    });
}

function normalizeBookmarkCacheEntry(entry) {
    if (!entry || !entry.url) return null;
    const timestamp = typeof entry.dateAdded === 'number'
        ? entry.dateAdded
        : (entry.dateAdded instanceof Date ? entry.dateAdded.getTime() : Date.now());
    return {
        id: entry.id,
        title: entry.title || entry.url || '',
        url: entry.url || '',
        dateAdded: timestamp,
        parentId: entry.parentId || '',
        path: entry.path || ''
    };
}

async function ensureAdditionsCacheLoaded(skipRender) {
    if (additionsCacheRestored || allBookmarks.length > 0) {
        return;
    }
    try {
        const cached = await readCachedValue(DATA_CACHE_KEYS.additions);
        if (cached && Array.isArray(cached.bookmarks)) {
            allBookmarks = cached.bookmarks
                .map(normalizeBookmarkCacheEntry)
                .filter(Boolean);
            additionsCacheRestored = true;
            rebuildBookmarkUrlSet();
            console.log('[AdditionsCache] 已从缓存恢复记录:', allBookmarks.length);
            if (!skipRender) {
                renderAdditionsView();
            }
        }
    } catch (error) {
        console.warn('[AdditionsCache] 恢复失败:', error);
    }
}

async function persistAdditionsCache() {
    try {
        const payload = {
            timestamp: Date.now(),
            bookmarks: allBookmarks.map(normalizeBookmarkCacheEntry).filter(Boolean)
        };
        await writeCachedValue(DATA_CACHE_KEYS.additions, payload);
        console.log('[AdditionsCache] 已保存:', payload.bookmarks.length);
    } catch (error) {
        console.warn('[AdditionsCache] 保存失败:', error);
    }
}

function scheduleAdditionsCacheSave() {
    if (saveAdditionsCacheTimer) {
        clearTimeout(saveAdditionsCacheTimer);
    }
    saveAdditionsCacheTimer = setTimeout(() => {
        saveAdditionsCacheTimer = null;
        persistAdditionsCache();
    }, 600);
}

function handleAdditionsDataMutation(forceRender = true) {
    additionsCacheRestored = true;
    scheduleAdditionsCacheSave();
    if (forceRender && currentView === 'additions') {
        renderAdditionsView();
    }
}

function addBookmarkToAdditionsCache(bookmark) {
    const normalized = normalizeBookmarkCacheEntry(bookmark);
    if (!normalized) return;
    allBookmarks.push(normalized);
    addUrlToBookmarkSet(normalized.url);
    const normalizedTitle = normalizeBookmarkTitle(normalized.title);
    if (normalizedTitle) {
        bookmarkTitleSet.add(normalizedTitle);
    }
    handleAdditionsDataMutation(true);
}

function removeBookmarkFromAdditionsCache(bookmarkId) {
    if (!bookmarkId) return;
    const index = allBookmarks.findIndex(item => item.id === bookmarkId);
    if (index === -1) return;
    removeUrlFromBookmarkSet(allBookmarks[index].url);
    allBookmarks.splice(index, 1);
    handleAdditionsDataMutation(true);
}

function updateBookmarkInAdditionsCache(bookmarkId, changeInfo = {}) {
    if (!bookmarkId) return;
    const target = allBookmarks.find(item => item.id === bookmarkId);
    if (!target) return;
    const prevUrl = target.url;
    if (typeof changeInfo.title !== 'undefined') {
        target.title = changeInfo.title;
        const normalizedTitle = normalizeBookmarkTitle(changeInfo.title);
        if (normalizedTitle) {
            bookmarkTitleSet.add(normalizedTitle);
        }
    }
    if (typeof changeInfo.url !== 'undefined') {
        target.url = changeInfo.url;
        removeUrlFromBookmarkSet(prevUrl);
        addUrlToBookmarkSet(changeInfo.url);
    }
    handleAdditionsDataMutation(true);
}

function moveBookmarkInAdditionsCache(bookmarkId, moveInfo = {}) {
    if (!bookmarkId) return;
    const target = allBookmarks.find(item => item.id === bookmarkId);
    if (!target) return;
    if (typeof moveInfo.parentId !== 'undefined') {
        target.parentId = moveInfo.parentId;
    }
    handleAdditionsDataMutation(false);
}

function normalizeBookmarkTitle(title) {
    if (!title || typeof title !== 'string') return null;
    const trimmed = title.trim();
    return trimmed || null;
}

function normalizeBookmarkUrl(url) {
    if (!url || typeof url !== 'string') return null;
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
        return null;
    }
    return url.trim();
}

function rebuildBookmarkUrlSet() {
    bookmarkUrlSet.clear();
    bookmarkTitleSet.clear();
    allBookmarks.forEach(item => {
        const normalized = normalizeBookmarkUrl(item.url);
        if (normalized) {
            bookmarkUrlSet.add(normalized);
        }
        const normalizedTitle = normalizeBookmarkTitle(item.title);
        if (normalizedTitle) {
            bookmarkTitleSet.add(normalizedTitle);
        }
    });
}

function addUrlToBookmarkSet(url) {
    const normalized = normalizeBookmarkUrl(url);
    if (normalized) {
        bookmarkUrlSet.add(normalized);
    }
}

function removeUrlFromBookmarkSet(url) {
    const normalized = normalizeBookmarkUrl(url);
    if (normalized) {
        bookmarkUrlSet.delete(normalized);
    }
}

function scheduleHistoryRefresh({ forceFull = false } = {}) {
    console.log('[History] 安排刷新，forceFull:', forceFull);
    pendingHistoryRefreshForceFull = pendingHistoryRefreshForceFull || forceFull;
    if (pendingHistoryRefreshTimer) {
        clearTimeout(pendingHistoryRefreshTimer);
    }
    pendingHistoryRefreshTimer = setTimeout(() => {
        console.log('[History] 执行刷新，forceFull:', pendingHistoryRefreshForceFull);
        pendingHistoryRefreshTimer = null;
        const shouldForce = pendingHistoryRefreshForceFull;
        pendingHistoryRefreshForceFull = false;
        refreshBrowsingHistoryData({ forceFull: shouldForce, silent: true });
    }, 500);
}

function handleHistoryVisited(result) {
    if (!result || !result.url) return;
    console.log('[History] onVisited:', result.url, 'title:', result.title);
    // 不在这里做 URL/标题过滤，统一交给 BrowsingHistoryCalendar.loadBookmarkData()
    // 中的 URL + 标题并集规则处理（增量只扫描 lastSyncTime 之后的历史）。
    scheduleHistoryRefresh({ forceFull: false });

    // 增量更新：background.js 的 history.onVisited 监听器会处理S值增量更新
    // 这里不需要再调用，避免重复
}

function handleHistoryVisitRemoved(details) {
    if (!details) return;
    console.log('[History] onVisitRemoved:', details);

    // 无论是清除所有历史，还是删除特定URL，都可能影响：
    // - 通过 URL 匹配到的点击记录
    // - 仅通过标题匹配到的点击记录
    // 因此这里一律触发一次全量重建（仅限最近一年的点击记录）。
    scheduleHistoryRefresh({ forceFull: true });
}

let historyRealtimeBound = false;
function setupBrowsingHistoryRealtimeListeners() {
    if (historyRealtimeBound) {
        console.log('[History] 实时监听器已绑定，跳过');
        return;
    }
    if (!browserAPI.history) {
        console.warn('[History] 浏览器历史API不可用');
        return;
    }
    if (browserAPI.history.onVisited && typeof browserAPI.history.onVisited.addListener === 'function') {
        console.log('[History] 绑定 onVisited 监听器');
        browserAPI.history.onVisited.addListener(handleHistoryVisited);
        historyRealtimeBound = true;
    }
    if (browserAPI.history.onVisitRemoved && typeof browserAPI.history.onVisitRemoved.addListener === 'function') {
        console.log('[History] 绑定 onVisitRemoved 监听器');
        browserAPI.history.onVisitRemoved.addListener(handleHistoryVisitRemoved);
    }
}

async function refreshBrowsingHistoryData(options = {}) {
    const { forceFull = false, silent = false } = options;
    const inst = window.browsingHistoryCalendarInstance;
    if (!inst || typeof inst.loadBookmarkData !== 'function') {
        return;
    }

    if (browsingHistoryRefreshPromise) {
        try {
            await browsingHistoryRefreshPromise;
        } catch (_) {
            // ignore
        }
    }

    // 如果已经有 lastSyncTime，则可以安全地做增量更新
    const incremental = !forceFull && !!(inst.historyCacheMeta && inst.historyCacheMeta.lastSyncTime);
    browsingHistoryRefreshPromise = (async () => {
        try {
            await inst.loadBookmarkData({ incremental });

            // 重建 bookmarkUrlSet（用于实时更新判断）
            if (typeof rebuildBookmarkUrlSet === 'function' && allBookmarks.length > 0) {
                rebuildBookmarkUrlSet();
            }

            if (typeof inst.render === 'function') {
                inst.render();
            }
            if (typeof inst.updateSelectModeButton === 'function') {
                inst.updateSelectModeButton();
            }

            // 清除缓存，让下次加载时重新获取
            browsingClickRankingStats = null;

            // 注意：不在这里直接调用 refresh 函数，而是依赖事件系统
            // 日历的 announceHistoryDataUpdated() 会派发 browsingHistoryCacheUpdated 事件
            // 事件监听器会调用 refreshActiveBrowsingRankingIfVisible() 和 refreshBrowsingRelatedHistory()
        } catch (error) {
            if (!silent) {
                console.warn('[BrowsingHistory] 刷新失败:', error);
            }
            throw error;
        } finally {
            browsingHistoryRefreshPromise = null;
        }
    })();

    try {
        await browsingHistoryRefreshPromise;
    } catch (_) {
        // already logged
    }
}

// 实时更新状态控制
let viewerInitialized = false;
let deferredAnalysisMessage = null;
let messageListenerRegistered = false;
let realtimeUpdateInProgress = false;
let pendingAnalysisMessage = null;
let lastAnalysisSignature = null;
// 显式移动集合（基于 onMoved 事件），用于同级移动标识，设置短期有效期
let explicitMovedIds = new Map(); // id -> expiryTimestamp

// 页面刷新/重新打开时，恢复“显式移动”标记：
// - Canvas 永久栏目懒加载模式下会跳过全量 diff 检测
// - 因此移动蓝标主要依赖 explicitMovedIds（而它是内存态）
// - 通过 background.js 持久化的 recentMovedIds 来恢复，避免“刷新后移动标识消失”
async function restoreExplicitMovedIdsFromStorage() {
    try {
        if (!browserAPI || !browserAPI.storage || !browserAPI.storage.local) return;
        const data = await browserAPI.storage.local.get(['recentMovedIds']);
        const recentMovedIds = data && Array.isArray(data.recentMovedIds) ? data.recentMovedIds : [];
        if (!recentMovedIds.length) return;

        // 防止极端情况下列表过大导致初始化变慢：只恢复最近 N 条（备份成功后会清空）
        const MAX_RESTORE = 2000;
        const slice = recentMovedIds.length > MAX_RESTORE ? recentMovedIds.slice(-MAX_RESTORE) : recentMovedIds;
        slice.forEach(entry => {
            if (!entry || typeof entry.id === 'undefined' || entry.id === null) return;
            explicitMovedIds.set(String(entry.id), Infinity);
        });
        console.log('[移动标识] 已从storage恢复显式移动ID数量:', explicitMovedIds.size);
    } catch (e) {
        console.warn('[移动标识] 从storage恢复显式移动ID失败:', e);
    }
}

// 详情面板相关全局变量
let currentDetailRecordTime = null; // 当前打开的详情面板对应的记录时间

// =============================================================================
// 辅助函数 - URL 处理
// =============================================================================

// 安全地获取网站图标 URL（同步版本，用于兼容旧代码）
// 注意：这个函数会触发后台异步加载，初次调用返回fallbackIcon
function getFaviconUrl(url) {
    if (!url) return fallbackIcon;

    // 验证是否是有效的 HTTP/HTTPS URL
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
        return fallbackIcon;
    }

    // 检查是否是无效URL
    if (FaviconCache.isInvalidUrl(url)) {
        return fallbackIcon;
    }

    try {
        const urlObj = new URL(url);
        const domain = urlObj.hostname;

        // 【关键修复】先检查内存缓存（在 renderTreeView 时已预热）
        if (FaviconCache.memoryCache.has(domain)) {
            return FaviconCache.memoryCache.get(domain);
        }

        // 检查失败缓存
        if (FaviconCache.failureCache.has(domain)) {
            return fallbackIcon;
        }

        // 触发后台异步加载（不等待结果）
        // 注意：由于在 renderTreeView 时已经预热了缓存，
        // 这里只是作为兜底机制，处理动态添加的书签
        FaviconCache.fetch(url).then(dataUrl => {
            // 加载完成后，查找并更新所有使用这个URL的img标签
            if (dataUrl && dataUrl !== fallbackIcon) {
                updateFaviconImages(url, dataUrl);
            }
        });

        // 立即返回 fallback 图标作为占位符
        return fallbackIcon;
    } catch (error) {
        return fallbackIcon;
    }
}

// 更新页面上所有指定URL的favicon图片
function updateFaviconImages(url, dataUrl) {
    let updatedCount = 0;
    try {
        const urlObj = new URL(url);
        const domain = urlObj.hostname;

        // 查找所有相关的img标签（通过data-favicon-domain或父元素的data-node-url）
        const allImages = document.querySelectorAll('img.tree-icon, img.addition-icon, img.change-tree-item-icon, img.canvas-bookmark-icon, img.tracking-favicon, img.ranking-favicon, img.add-result-favicon, img.heatmap-detail-favicon');

        allImages.forEach(img => {
            // 检查是否是fallback图标（SVG data URL）且对应的书签URL匹配
            const isFallback = img.src.startsWith('data:image/svg+xml') || img.src === fallbackIcon;
            const item = img.closest('[data-node-url], [data-bookmark-url]');

            if (item) {
                const itemUrl = item.dataset.nodeUrl || item.dataset.bookmarkUrl;
                if (itemUrl) {
                    try {
                        const itemDomain = new URL(itemUrl).hostname;
                        if (itemDomain === domain) {
                            // 更新图标（不管是否是fallback，都更新为最新的）
                            img.src = dataUrl;
                            updatedCount++;
                        }
                    } catch (e) {
                        // 忽略无效URL
                    }
                }
            }
        });
    } catch (e) {
        // 静默处理
    }
    return updatedCount;
}

// 全局图片错误处理（使用事件委托，避免CSP内联事件处理器）
function setupGlobalImageErrorHandler() {
    document.addEventListener('error', (e) => {
        if (e.target.tagName === 'IMG' &&
            (e.target.classList.contains('tree-icon') ||
                e.target.classList.contains('addition-icon') ||
                e.target.classList.contains('change-tree-item-icon') ||
                e.target.classList.contains('canvas-bookmark-icon') ||
                e.target.classList.contains('tracking-favicon') ||
                e.target.classList.contains('ranking-favicon') ||
                e.target.classList.contains('add-result-favicon') ||
                e.target.classList.contains('heatmap-detail-favicon'))) {
            // 只在src不是fallbackIcon时才替换，避免无限循环
            // fallbackIcon 是 data URL，不会加载失败
            if (e.target.src !== fallbackIcon && !e.target.src.startsWith('data:image/svg+xml')) {
                e.target.src = fallbackIcon;
            }
        }
    }, true); // 使用捕获阶段
}

// 异步获取favicon（推荐使用，支持完整缓存）
async function getFaviconUrlAsync(url) {
    if (!url) return fallbackIcon;

    if (!url.startsWith('http://') && !url.startsWith('https://')) {
        return fallbackIcon;
    }

    return await FaviconCache.fetch(url);
}

// Fallback 图标 - 星标书签图标
const fallbackIcon = 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 16 16%22%3E%3Cpath fill=%22%23999%22 d=%22M8 0l2.8 5.5 6.2 0.5-4.5 4 1.5 6-5.5-3.5-5.5 3.5 1.5-6-4.5-4 6.2-0.5z%22/%3E%3C/svg%3E';

// Edge/Chrome 内置页面 scheme 不同（仅用于展示/跳转提示）
const internalScheme = (navigator.userAgent || '').includes('Edg/') ? 'edge://' : 'chrome://';

// =============================================================================
// 国际化文本
// =============================================================================

const i18n = {
    pageTitle: {
        'zh_CN': '备份历史查看器',
        'en': 'Backup History Viewer'
    },
    pageSubtitle: {
        'zh_CN': '类似 Git 的书签变化追踪',
        'en': 'Git-like Bookmark Change Tracking'
    },
    searchPlaceholder: {
        'zh_CN': '搜索书签、文件夹...',
        'en': 'Search bookmarks, folders...'
    },
    helpTooltip: {
        'zh_CN': '开源信息与快捷键',
        'en': 'Open Source Info & Shortcuts'
    },
    navCurrentChanges: {
        'zh_CN': '当前变化',
        'en': 'Current Changes'
    },
    navHistory: {
        'zh_CN': '备份历史',
        'en': 'Backup History'
    },
    navAdditions: {
        'zh_CN': '书签记录',
        'en': 'Bookmark Records'
    },
    navCanvas: {
        'zh_CN': '书签画布',
        'en': 'Bookmark Canvas'
    },
    navRecommend: {
        'zh_CN': '书签推荐',
        'en': 'Bookmark Recommend'
    },
    additionsTabReview: {
        'zh_CN': '书签添加记录',
        'en': 'Bookmark additions'
    },
    additionsTabBrowsing: {
        'zh_CN': '书签浏览记录',
        'en': 'Browsing History'
    },
    additionsTabTracking: {
        'zh_CN': '时间捕捉',
        'en': 'Time Tracking'
    },
    trackingPanelDesc: {
        'zh_CN': '追踪书签页面的活跃浏览时间',
        'en': 'Track active browsing time on bookmark pages'
    },
    clearTrackingText: {
        'zh_CN': '清除',
        'en': 'Clear'
    },
    browsingTabHistory: {
        'zh_CN': '点击记录',
        'en': 'Click History'
    },
    browsingTabRanking: {
        'zh_CN': '点击排行',
        'en': 'Click Ranking'
    },
    browsingTabRelated: {
        'zh_CN': '关联记录',
        'en': 'Related History'
    },
    browsingRankingTitle: {
        'zh_CN': '点击排行',
        'en': 'Click Ranking'
    },
    browsingRankingDescription: {
        'zh_CN': '基于浏览器历史记录，按点击次数统计当前书签的热门程度。',
        'en': 'Based on browser history, rank your bookmarks by click counts.'
    },
    browsingRelatedTitle: {
        'zh_CN': '关联记录',
        'en': 'Related History'
    },
    browsingRelatedDescription: {
        'zh_CN': '显示浏览器历史记录，并用绿色边框凸显书签相关的记录。',
        'en': 'Shows browser history, highlighting bookmark-related entries with green borders.'
    },
    browsingRelatedBadgeText: {
        'zh_CN': '书签',
        'en': 'Bookmark'
    },
    browsingRelatedLoadingText: {
        'zh_CN': '正在读取历史记录...',
        'en': 'Loading history...'
    },
    browsingRelatedFilterDay: {
        'zh_CN': '当天',
        'en': 'Today'
    },
    browsingRelatedFilterWeek: {
        'zh_CN': '当周',
        'en': 'This Week'
    },
    browsingRelatedFilterMonth: {
        'zh_CN': '当月',
        'en': 'This Month'
    },
    browsingRelatedFilterYear: {
        'zh_CN': '当年',
        'en': 'This Year'
    },
    browsingRelatedFilterAll: {
        'zh_CN': '全部',
        'en': 'All'
    },
    browsingRankingFilterToday: {
        'zh_CN': '当天',
        'en': 'Today'
    },
    browsingRankingFilterWeek: {
        'zh_CN': '当周',
        'en': 'This week'
    },
    browsingRankingFilterMonth: {
        'zh_CN': '当月',
        'en': 'This month'
    },
    browsingRankingFilterYear: {
        'zh_CN': '当年',
        'en': 'This year'
    },
    browsingRankingFilterAll: {
        'zh_CN': '全部',
        'en': 'All'
    },
    browsingRankingEmptyTitle: {
        'zh_CN': '暂无点击记录',
        'en': 'No click records found'
    },
    browsingRankingEmptyDescription: {
        'zh_CN': '当前时间范围内尚未找到这些书签的访问记录。',
        'en': 'No visit records for your bookmarks were found in the selected time range.'
    },
    browsingRankingNotSupportedTitle: {
        'zh_CN': '当前环境不支持历史记录统计',
        'en': 'History statistics are not available in this environment'
    },
    browsingRankingNotSupportedDesc: {
        'zh_CN': '请确认扩展已获得浏览器的历史记录权限。',
        'en': 'Please ensure the extension has permission to access browser history.'
    },
    browsingRankingNoBookmarksTitle: {
        'zh_CN': '暂无书签可统计',
        'en': 'No bookmarks to analyze'
    },
    browsingCalendarLoading: {
        'zh_CN': '正在加载日历...',
        'en': 'Loading calendar...'
    },
    timeTrackingWidgetTitle: {
        'zh_CN': '时间捕捉',
        'en': 'Time Tracking'
    },
    timeTrackingWidgetEmpty: {
        'zh_CN': '暂无追踪中的书签',
        'en': 'No bookmarks being tracked'
    },
    timeTrackingWidgetMore: {
        'zh_CN': '还有 {count} 个...',
        'en': '{count} more...'
    },
    timeTrackingWidgetRankingTitle: {
        'zh_CN': '点击排行',
        'en': 'Click Ranking'
    },
    currentChangesViewTitle: {
        'zh_CN': '当前变化',
        'en': 'Current Changes'
    },
    historyViewTitle: {
        'zh_CN': '备份历史',
        'en': 'Backup History'
    },
    clearBackupHistoryTooltip: {
        'zh_CN': '清除记录',
        'en': 'Clear history'
    },
    clearBackupHistoryModalTitle: {
        'zh_CN': '清除记录',
        'en': 'Clear Records'
    },
    clearBackupHistoryModalDesc: {
        'zh_CN': '选择要删除的备份历史记录数量：',
        'en': 'Select the number of backup history records to delete:'
    },
    clearBackupHistoryModalWarning: {
        'zh_CN': '此操作不可撤销。<br>不会删除你的书签本身，也不会删除已导出的备份文件。',
        'en': 'This action cannot be undone.<br>This will NOT delete your actual bookmarks or any exported backup files.'
    },
    clearHistoryModePercentLabel: {
        'zh_CN': '按百分比删除',
        'en': 'Delete by percentage'
    },
    clearHistoryModeCountLabel: {
        'zh_CN': '按条数删除',
        'en': 'Delete by count'
    },
    clearHistoryPercentLabelBefore: {
        'zh_CN': '删除最旧的',
        'en': 'Delete the oldest'
    },
    clearHistoryCountLabelBefore: {
        'zh_CN': '删除最旧的',
        'en': 'Delete the oldest'
    },
    clearHistoryCountLabelAfter: {
        'zh_CN': '条记录',
        'en': 'records'
    },
    clearHistoryPreviewText: {
        'zh_CN': (total, toDelete) => `当前共 ${total} 条记录，将删除 ${toDelete} 条`,
        'en': (total, toDelete) => `Total ${total} records, ${toDelete} will be deleted`
    },
    clearBackupHistoryExportFirstBtn: {
        'zh_CN': '先备份',
        'en': 'Export First'
    },
    clearBackupHistoryCancelBtn: {
        'zh_CN': '取消',
        'en': 'Cancel'
    },
    clearBackupHistoryConfirmBtn: {
        'zh_CN': '确认删除',
        'en': 'Confirm Delete'
    },
    clearBackupHistorySuccess: {
        'zh_CN': (deleted) => `已删除 ${deleted} 条历史记录`,
        'en': (deleted) => `Deleted ${deleted} history records`
    },
    clearBackupHistoryFailed: {
        'zh_CN': '删除历史记录失败',
        'en': 'Failed to delete history'
    },
    // 二次确认弹窗
    clearHistorySecondConfirmTitle: {
        'zh_CN': '确认删除',
        'en': 'Confirm Delete'
    },
    clearHistorySecondConfirmText: {
        'zh_CN': (count) => `即将删除 ${count} 条记录`,
        'en': (count) => `About to delete ${count} records`
    },
    clearHistorySecondConfirmPrefix: {
        'zh_CN': '即将删除',
        'en': 'About to delete'
    },
    clearHistorySecondConfirmSuffix: {
        'zh_CN': '条记录',
        'en': 'records'
    },
    clearHistorySecondConfirmWarning: {
        'zh_CN': '此操作不可撤销，建议先备份再删除',
        'en': 'This action cannot be undone. We recommend exporting first.'
    },
    clearHistoryExportFirstBtn: {
        'zh_CN': '先备份这些记录',
        'en': 'Export these records first'
    },
    clearHistoryDirectDeleteBtn: {
        'zh_CN': '直接删除',
        'en': 'Delete directly'
    },
    clearHistorySecondConfirmCancelBtn: {
        'zh_CN': '返回修改',
        'en': 'Go back'
    },
    additionsViewTitle: {
        'zh_CN': '书签记录',
        'en': 'Bookmark Records'
    },
    canvasViewTitle: {
        'zh_CN': '书签画布',
        'en': 'Bookmark Canvas'
    },
    importCanvasText: {
        'zh_CN': '导入',
        'en': 'Import'
    },
    exportCanvasText: {
        'zh_CN': '导出',
        'en': 'Export'
    },
    clearMenuText: {
        'zh_CN': '清除',
        'en': 'Clear'
    },
    clearByClickText: {
        'zh_CN': '点击清除',
        'en': 'Click to Clear'
    },
    clearTempNodesText: {
        'zh_CN': '清空未标注节点',
        'en': 'Clear Unmarked Nodes'
    },
    clearAllText: {
        'zh_CN': '清除全部（永久栏目除外）',
        'en': 'Clear All (Except Permanent)'
    },
    clearRulesTooltipTitle: {
        'zh_CN': '清除规则',
        'en': 'Clear Rules'
    },
    clearRulesWillClear: {
        'zh_CN': '会被清除：',
        'en': 'Will be cleared:'
    },
    clearRulesWillKeep: {
        'zh_CN': '会被保留：',
        'en': 'Will be kept:'
    },
    clearRuleTemp: {
        'zh_CN': '<strong>书签型临时栏目</strong>：无说明 + 默认标题 + 无连接线',
        'en': '<strong>Temp Section</strong>: No description + Default title + No edges'
    },
    clearRuleMd: {
        'zh_CN': '<strong>空白栏目</strong>：内容为空 + 无连接线',
        'en': '<strong>Blank Node</strong>: Empty content + No edges'
    },
    clearRuleKeepDesc: {
        'zh_CN': '<i class="fas fa-check"></i> 有说明文字',
        'en': '<i class="fas fa-check"></i> Has description'
    },
    clearRuleKeepTitle: {
        'zh_CN': '<i class="fas fa-check"></i> 标题被修改过',
        'en': '<i class="fas fa-check"></i> Custom title'
    },
    clearRuleKeepEdge: {
        'zh_CN': '<i class="fas fa-check"></i> 有连接线',
        'en': '<i class="fas fa-check"></i> Has edges'
    },
    canvasFullscreenEnter: {
        'zh_CN': '全屏',
        'en': 'Fullscreen'
    },
    canvasFullscreenExit: {
        'zh_CN': '退出',
        'en': 'Exit'
    },
    canvasZoomLabel: {
        'zh_CN': '缩放',
        'en': 'Zoom'
    },
    canvasZoomHint: {
        'zh_CN': '<kbd style="font-size: 9px; padding: 2px 4px; background: #f6f8fa; border: 1px solid #d0d7de; border-radius: 3px;">Ctrl</kbd> + 滚轮 | <kbd style="font-size: 9px; padding: 2px 4px; background: #f6f8fa; border: 1px solid #d0d7de; border-radius: 3px;">空格</kbd> 拖动',
        'en': '<kbd style="font-size: 9px; padding: 2px 4px; background: #f6f8fa; border: 1px solid #d0d7de; border-radius: 3px;">Ctrl</kbd> + Wheel | <kbd style="font-size: 9px; padding: 2px 4px; background: #f6f8fa; border: 1px solid #d0d7de; border-radius: 3px;">Space</kbd> Drag'
    },
    zoomInTitle: {
        'zh_CN': '放大 (10%)',
        'en': 'Zoom In (10%)'
    },
    zoomOutTitle: {
        'zh_CN': '缩小 (10%)',
        'en': 'Zoom Out (10%)'
    },
    zoomLocateTitle: {
        'zh_CN': '定位到永久栏目',
        'en': 'Locate to Permanent Section'
    },
    zoomLocateText: {
        'zh_CN': '定位',
        'en': 'Locate'
    },
    canvasManageText: {
        'zh_CN': '管理',
        'en': 'Manage'
    },
    canvasManageTitle: {
        'zh_CN': '画布管理',
        'en': 'Canvas Manage'
    },
    canvasHelpBtnTitle: {
        'zh_CN': '说明',
        'en': 'Help'
    },
    canvasHelpModalTitle: {
        'zh_CN': '说明',
        'en': 'Help'
    },
    canvasHelpCtrlTitle: {
        'zh_CN': 'Ctrl 键操作',
        'en': 'Ctrl Key Actions'
    },
    canvasHelpCtrlLeftClick: {
        'zh_CN': '左键（按住）',
        'en': 'Left Click (Hold)'
    },
    canvasHelpCtrlLeftDesc: {
        'zh_CN': '拖动画布 或 栏目卡片',
        'en': 'Drag canvas or section card'
    },
    canvasHelpCtrlWheel: {
        'zh_CN': '滚轮',
        'en': 'Wheel'
    },
    canvasHelpCtrlWheelDesc: {
        'zh_CN': '缩放',
        'en': 'Zoom'
    },
    canvasHelpCtrlRightClick: {
        'zh_CN': '右键（单击）',
        'en': 'Right Click'
    },
    canvasHelpCtrlRightDesc: {
        'zh_CN': '更改栏目卡片的大小',
        'en': 'Resize section card'
    },
    canvasHelpSpaceTitle: {
        'zh_CN': '空格键操作',
        'en': 'Space Key Actions'
    },
    canvasHelpSpaceKey: {
        'zh_CN': '空格',
        'en': 'Space'
    },
    canvasHelpSpaceLeftClick: {
        'zh_CN': '左键（按住）',
        'en': 'Left Click (Hold)'
    },
    canvasHelpSpaceDesc: {
        'zh_CN': '拖动画布',
        'en': 'Drag canvas'
    },
    canvasHelpTouchpadTitle: {
        'zh_CN': '触控板操作',
        'en': 'Touchpad Actions'
    },
    canvasHelpTouchpadPinch: {
        'zh_CN': '双指捏合',
        'en': 'Pinch'
    },
    canvasHelpTouchpadPinchDesc: {
        'zh_CN': '缩放画布',
        'en': 'Zoom canvas'
    },
    canvasHelpTouchpadScroll: {
        'zh_CN': '双指滑动',
        'en': 'Two-finger Scroll'
    },
    canvasHelpTouchpadScrollDesc: {
        'zh_CN': '拖动画布',
        'en': 'Pan canvas'
    },
    canvasShortcutRecorderText: {
        'zh_CN': '请按下新的快捷键...',
        'en': 'Press new shortcut key...'
    },
    canvasShortcutRecorderCancel: {
        'zh_CN': '取消',
        'en': 'Cancel'
    },
    canvasShortcutEditTitle: {
        'zh_CN': '点击修改快捷键',
        'en': 'Click to change shortcut'
    },
    recorderHelpTitle: {
        'zh_CN': '可用按键',
        'en': 'Available Keys'
    },
    recorderHelpBtnTitle: {
        'zh_CN': '查看可用按键',
        'en': 'View available keys'
    },
    tooltipModifierLabel: {
        'zh_CN': '修饰键:',
        'en': 'Modifiers:'
    },
    tooltipSpecialLabel: {
        'zh_CN': '特殊键:',
        'en': 'Special:'
    },
    tooltipLetterLabel: {
        'zh_CN': '字母键:',
        'en': 'Letters:'
    },
    tooltipNumberLabel: {
        'zh_CN': '数字键:',
        'en': 'Numbers:'
    },
    permanentSectionTitle: {
        'zh_CN': '书签树 (永久栏目)',
        'en': 'Bookmark Tree (Permanent)'
    },
    permanentSectionTip: {
        'zh_CN': '点击添加说明...',
        'en': 'Click to add description...'
    },
    filterAll: {
        'zh_CN': '全部',
        'en': 'All'
    },
    filterBackedUp: {
        'zh_CN': '已备份',
        'en': 'Backed Up'
    },
    filterNotBackedUp: {
        'zh_CN': '未备份',
        'en': 'Not Backed Up'
    },
    modalTitle: {
        'zh_CN': '变化详情',
        'en': 'Change Details'
    },
    shortcutsModalTitle: {
        'zh_CN': '开源信息与快捷键',
        'en': 'Open Source Info & Shortcuts'
    },
    openSourceGithubLabel: {
        'zh_CN': 'GitHub 仓库:',
        'en': 'GitHub Repository:'
    },
    openSourceIssueLabel: {
        'zh_CN': '问题反馈:',
        'en': 'Feedback / Issues:'
    },
    openSourceIssueText: {
        'zh_CN': '提交问题',
        'en': 'Submit Issue'
    },
    shortcutsTitle: {
        'zh_CN': '当前可用快捷键',
        'en': 'Available Shortcuts'
    },
    shortcutsTableHeaderKey: {
        'zh_CN': '按键',
        'en': 'Key'
    },
    shortcutsTableHeaderAction: {
        'zh_CN': '功能',
        'en': 'Action'
    },
    shortcutsSettingsTooltip: {
        'zh_CN': '在浏览器中管理快捷键',
        'en': 'Manage shortcuts in browser'
    },
    shortcutCurrentChanges: {
        'zh_CN': '打开「当前变化」视图',
        'en': 'Open "Current Changes" view'
    },
    shortcutHistory: {
        'zh_CN': '打开「备份历史」视图',
        'en': 'Open "Backup History" view'
    },
    shortcutCanvas: {
        'zh_CN': '打开「书签画布」视图',
        'en': 'Open "Bookmark Canvas" view'
    },
    shortcutAdditions: {
        'zh_CN': '打开「书签记录」视图',
        'en': 'Open "Bookmark Records" view'
    },
    shortcutRecommend: {
        'zh_CN': '打开「书签推荐」视图',
        'en': 'Open "Bookmark Recommend" view'
    },
    closeShortcutsText: {
        'zh_CN': '关闭',
        'en': 'Close'
    },
    autoBackup: {
        'zh_CN': '自动',
        'en': 'Auto'
    },
    manualBackup: {
        'zh_CN': '手动',
        'en': 'Manual'
    },
    success: {
        'zh_CN': '成功',
        'en': 'Success'
    },
    error: {
        'zh_CN': '失败',
        'en': 'Error'
    },
    added: {
        'zh_CN': '新增',
        'en': 'Added'
    },
    deleted: {
        'zh_CN': '删除',
        'en': 'Deleted'
    },
    modified: {
        'zh_CN': '修改',
        'en': 'Modified'
    },
    moved: {
        'zh_CN': '移动',
        'en': 'Moved'
    },
    bookmarks: {
        'zh_CN': '书签',
        'en': 'bookmarks'
    },
    folders: {
        'zh_CN': '文件夹',
        'en': 'folders'
    },
    backedUp: {
        'zh_CN': '已备份',
        'en': 'Backed Up'
    },
    notBackedUp: {
        'zh_CN': '未备份',
        'en': 'Not Backed Up'
    },
    noChanges: {
        'zh_CN': '无变化',
        'en': 'No changes'
    },
    noChangesDesc: {
        'zh_CN': '当前没有未备份的书签变化',
        'en': 'No unbacked bookmark changes'
    },
    changesTreeTitle: {
        'zh_CN': '书签结构预览',
        'en': 'Bookmark Structure Preview'
    },
    changesTreeEdit: {
        'zh_CN': '编辑',
        'en': 'Edit'
    },
    legendAdded: {
        'zh_CN': '新增',
        'en': 'Added'
    },
    legendDeleted: {
        'zh_CN': '删除',
        'en': 'Deleted'
    },
    legendMoved: {
        'zh_CN': '移动',
        'en': 'Moved'
    },
    legendModified: {
        'zh_CN': '修改',
        'en': 'Modified'
    },
    emptyHistory: {
        'zh_CN': '暂无备份记录',
        'en': 'No backup records'
    },
    globalExport: {
        'zh_CN': '全局导出',
        'en': 'Global Export'
    },
    globalExportModalTitle: {
        'zh_CN': '全局备份导出',
        'en': 'Global Backup Export'
    },
    globalExportFormatTitle: {
        'zh_CN': '导出格式',
        'en': 'Export Format'
    },
    globalExportFormatHint: {
        'zh_CN': '勾选即可导出对应格式文件',
        'en': 'Select to export the corresponding file formats'
    },
    globalExportPackTitle: {
        'zh_CN': '打包结构',
        'en': 'Packaging'
    },
    globalExportPackZip: {
        'zh_CN': 'ZIP 归档',
        'en': 'ZIP'
    },
    globalExportPackMerge: {
        'zh_CN': '单一文件合并',
        'en': 'Merge'
    },
    globalExportPackHint: {
        'zh_CN': 'ZIP归档将包含多个独立文件<br>单一文件合并将生成一个汇总文件',
        'en': 'ZIP contains separate files<br>Merge generates a summary file'
    },
    globalExportSelectTitle: {
        'zh_CN': '选择备份记录',
        'en': 'Select Backup Records'
    },
    globalExportRangeEnabledText: {
        'zh_CN': '自动勾选',
        'en': 'Auto select'
    },
    globalExportThSeq: {
        'zh_CN': '序号',
        'en': 'No.'
    },
    globalExportThNote: {
        'zh_CN': '备注',
        'en': 'Note'
    },
    globalExportThHash: {
        'zh_CN': '哈希值',
        'en': 'Hash'
    },
    globalExportThViewMode: {
        'zh_CN': '视图模式',
        'en': 'View Mode'
    },
    globalExportThTime: {
        'zh_CN': '时间',
        'en': 'Time'
    },
    globalExportCancel: {
        'zh_CN': '取消',
        'en': 'Cancel'
    },
    globalExportConfirm: {
        'zh_CN': '导出选中项',
        'en': 'Export Selected'
    },

    historyDetailModeSimple: {
        'zh_CN': '简略',
        'en': 'Simple'
    },
    historyDetailModeDetailed: {
        'zh_CN': '详细',
        'en': 'Detailed'
    },
    revertAll: {
        'zh_CN': '全部撤销',
        'en': 'Revert All'
    },
    revertConfirmTitle: {
        'zh_CN': '确认撤销全部变化？',
        'en': 'Revert all changes?'
    },
    revertConfirmDesc: {
        'zh_CN': '这将撤销所有未提交的变化（新增/删除/修改/移动），并恢复到上次备份状态。此操作不可撤销。',
        'en': 'This will revert all uncommitted changes (add/delete/modify/move) and restore to the last backup. This cannot be undone.'
    },
    revertConfirmSecondary: {
        'zh_CN': '再次确认：是否撤销全部变化？',
        'en': 'Confirm again: revert all changes?'
    },
    revertSuccess: {
        'zh_CN': '已撤销全部变化，已恢复到上次备份',
        'en': 'All changes reverted. Restored to last backup.'
    },
    revertFailed: {
        'zh_CN': '撤销失败：',
        'en': 'Revert failed: '
    },
    emptyAdditions: {
        'zh_CN': '暂无书签记录',
        'en': 'No bookmark records'
    },
    emptyTree: {
        'zh_CN': '无法加载书签树',
        'en': 'Unable to load bookmark tree'
    },
    loading: {
        'zh_CN': '加载中...',
        'en': 'Loading...'
    },
    // 日历视图翻译
    calendarWeekLabel: {
        'zh_CN': '周',
        'en': 'Week'
    },
    calendarWeek: {
        'zh_CN': '第{0}周',
        'en': 'Week {0}'
    },
    calendarMonth: {
        'zh_CN': '{0}月',
        'en': 'Month {0}'
    },
    calendarMonthDay: {
        'zh_CN': '{0}月{1}日',
        'en': '{0}/{1}'
    },
    calendarYear: {
        'zh_CN': '{0}年',
        'en': 'Year {0}'
    },
    calendarYearMonthDay: {
        'zh_CN': '{0}年{1}月{2}日',
        'en': '{0}/{1}/{2}'
    },
    calendarWeekdays: {
        'zh_CN': ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
        'en': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
    },
    calendarWeekdaysFull: {
        'zh_CN': ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
        'en': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    },
    calendarMonthNames: {
        'zh_CN': ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
        'en': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    },
    calendarYearMonth: {
        'zh_CN': '{0}年{1}',
        'en': '{1} {0}'
    },
    calendarBookmarkCount: {
        'zh_CN': '{0}个',
        'en': '{0}'
    },
    calendarBookmarksCount: {
        'zh_CN': '{0}个书签',
        'en': '{0} bookmarks'
    },
    calendarTotalThisMonth: {
        'zh_CN': '本月共 {0} 个书签',
        'en': 'Total {0} bookmarks this month'
    },
    calendarTotalThisWeek: {
        'zh_CN': '本周共 {0} 个书签',
        'en': 'Total {0} bookmarks this week'
    },
    calendarTotalThisDay: {
        'zh_CN': '共 {0} 个书签',
        'en': 'Total {0} bookmarks'
    },
    calendarExpandMore: {
        'zh_CN': '展开更多 (还有{0}个)',
        'en': 'Show more ({0} more)'
    },
    calendarCollapse: {
        'zh_CN': '收起',
        'en': 'Collapse'
    },
    calendarSelectMode: {
        'zh_CN': '勾选',
        'en': 'Select'
    },
    calendarLocateToday: {
        'zh_CN': '定位至今天',
        'en': 'Locate Today'
    },
    calendarNoBookmarksThisMonth: {
        'zh_CN': '本月没有书签',
        'en': 'No bookmarks this month'
    },
    calendarNoBookmarksThisDay: {
        'zh_CN': '这天没有书签',
        'en': 'No bookmarks on this day'
    },
    calendarLoading: {
        'zh_CN': '正在加载日历...',
        'en': 'Loading calendar...'
    },
    calendarSortAscending: {
        'zh_CN': '正序排列',
        'en': 'Ascending'
    },
    calendarSortDescending: {
        'zh_CN': '倒序排列',
        'en': 'Descending'
    },
    currentAscending: {
        'zh_CN': '当前：正序',
        'en': 'Current: Ascending'
    },
    currentDescending: {
        'zh_CN': '当前：倒序',
        'en': 'Current: Descending'
    },
    refreshTooltip: {
        'zh_CN': '刷新',
        'en': 'Refresh'
    },
    themeTooltip: {
        'zh_CN': '切换主题',
        'en': 'Toggle Theme'
    },
    langTooltip: {
        'zh_CN': '切换语言',
        'en': 'Switch Language'
    },
    noChanges: {
        'zh_CN': '无变化',
        'en': 'No changes'
    },
    firstBackup: {
        'zh_CN': '首次备份',
        'en': 'First Backup'
    },
    addedBookmarks: {
        'zh_CN': '新增书签',
        'en': 'Added Bookmarks'
    },
    deletedBookmarks: {
        'zh_CN': '删除书签',
        'en': 'Deleted Bookmarks'
    },
    modifiedBookmarks: {
        'zh_CN': '修改书签',
        'en': 'Modified Bookmarks'
    },
    movedBookmarks: {
        'zh_CN': '移动书签',
        'en': 'Moved Bookmarks'
    },
    addedFolders: {
        'zh_CN': '新增文件夹',
        'en': 'Added Folders'
    },
    deletedFolders: {
        'zh_CN': '删除文件夹',
        'en': 'Deleted Folders'
    },
    filterStatus: {
        'zh_CN': '状态',
        'en': 'Status'
    },
    filterTime: {
        'zh_CN': '时间',
        'en': 'Time'
    },
    timeFilterAll: {
        'zh_CN': '全部',
        'en': 'All'
    },
    timeFilterYear: {
        'zh_CN': '按年',
        'en': 'By Year'
    },
    timeFilterMonth: {
        'zh_CN': '按月',
        'en': 'By Month'
    },
    timeFilterDay: {
        'zh_CN': '按日',
        'en': 'By Day'
    },
    treeViewMode: {
        'zh_CN': '树形视图',
        'en': 'Tree View'
    },
    jsonViewMode: {
        'zh_CN': 'JSON',
        'en': 'JSON'
    },
    bookmarkGitTitle: {
        'zh_CN': '书签Git',
        'en': 'Bookmark Git'
    },
    bookmarkToolboxTitle: {
        'zh_CN': '书签工具箱',
        'en': 'Bookmark Toolbox'
    },
    horizontalScrollHint: {
        'zh_CN': 'Shift + 滚轮',
        'en': 'Shift + Wheel'
    },
    nativeHistoryButtonText: {
        'zh_CN': `历史记录 (${internalScheme}history/)`,
        'en': `History (${internalScheme}history/)`
    },
    groupedHistoryButtonText: {
        'zh_CN': `分组历史 (${internalScheme}history/grouped)`,
        'en': `Grouped History (${internalScheme}history/grouped)`
    },
    bookmarkRankingDescription: {
        'zh_CN': '结合浏览器历史记录，对当前书签的点击次数进行「书签点击排行」。点击某一行可展开查看不同时间范围的统计。',
        'en': 'Based on browser history, rank your bookmarks by click counts. Click a row to see statistics for different time ranges.'
    },
    additionsAnkiTitle: {
        'zh_CN': '书签Anki（规划中）',
        'en': 'Bookmark Anki (planned)'
    },
    additionsAnkiDescription: {
        'zh_CN': '未来会在这里加入基于 Anki 的复习节奏，帮助你按记忆曲线重新回顾书签。',
        'en': 'An Anki-based review flow will be added here to help you revisit bookmarks along a memory curve.'
    },
    // ==================== 导出变化功能翻译 ====================
    exportChangesModalTitle: {
        'zh_CN': '导出书签变化',
        'en': 'Export Bookmark Changes'
    },
    exportChangesFormatLabel: {
        'zh_CN': '导出格式',
        'en': 'Export Format'
    },
    exportChangesLegendHelp: {
        'zh_CN': '标记说明',
        'en': 'Legend'
    },
    exportChangesLegendTitle: {
        'zh_CN': '标记说明：',
        'en': 'Legend:'
    },
    legendAdded: {
        'zh_CN': '新增',
        'en': 'Added'
    },
    legendDeleted: {
        'zh_CN': '删除',
        'en': 'Deleted'
    },
    legendModified: {
        'zh_CN': '修改',
        'en': 'Modified'
    },
    legendMoved: {
        'zh_CN': '移动',
        'en': 'Moved'
    },
    exportChangesModeLabel: {
        'zh_CN': '导出模式',
        'en': 'Export Mode'
    },
    exportChangesModeSimple: {
        'zh_CN': '简略',
        'en': 'Simple'
    },
    exportChangesModeDetailed: {
        'zh_CN': '详细',
        'en': 'Detailed'
    },
    exportChangesDetailedHelp: {
        'zh_CN': '功能说明',
        'en': 'Function Info'
    },
    exportChangesActionLabel: {
        'zh_CN': '操作方式',
        'en': 'Action'
    },
    exportChangesActionDownload: {
        'zh_CN': '导出文件',
        'en': 'Download File'
    },
    exportChangesActionCopy: {
        'zh_CN': '复制到剪贴板',
        'en': 'Copy to Clipboard'
    },
    exportChangesDepthLabel: {
        'zh_CN': '扩展层级',
        'en': 'Depth'
    },
    exportChangesDepth0: {
        'zh_CN': '仅同级',
        'en': 'Siblings only'
    },
    // ==================== 导出变化功能翻译 ====================
    exportChangesModalTitle: {
        'zh_CN': '导出书签变化',
        'en': 'Export Bookmark Changes'
    },
    exportChangesFormatLabel: {
        'zh_CN': '导出格式',
        'en': 'Export Format'
    },
    exportChangesLegendHelp: {
        'zh_CN': '标记说明',
        'en': 'Legend'
    },
    exportChangesLegendTitle: {
        'zh_CN': '标记说明：',
        'en': 'Legend:'
    },
    legendAdded: {
        'zh_CN': '新增',
        'en': 'Added'
    },
    legendDeleted: {
        'zh_CN': '删除',
        'en': 'Deleted'
    },
    legendModified: {
        'zh_CN': '修改',
        'en': 'Modified'
    },
    legendMoved: {
        'zh_CN': '移动',
        'en': 'Moved'
    },
    exportChangesModeLabel: {
        'zh_CN': '导出模式',
        'en': 'Export Mode'
    },
    exportChangesModeSimple: {
        'zh_CN': '简略',
        'en': 'Simple'
    },
    exportChangesModeDetailed: {
        'zh_CN': '详细',
        'en': 'Detailed'
    },
    exportChangesDetailedHelp: {
        'zh_CN': '功能说明',
        'en': 'Function Info'
    },
    exportChangesActionLabel: {
        'zh_CN': '操作方式',
        'en': 'Action'
    },
    exportChangesActionDownload: {
        'zh_CN': '导出文件',
        'en': 'Download File'
    },
    exportChangesActionCopy: {
        'zh_CN': '复制到剪贴板',
        'en': 'Copy to Clipboard'
    },
    exportChangesDepthLabel: {
        'zh_CN': '扩展层级',
        'en': 'Depth'
    },
    exportChangesDepth0: {
        'zh_CN': '仅同级',
        'en': 'Siblings only'
    },
    doExportChangesBtnText: {
        'zh_CN': '确认',
        'en': 'Confirm'
    },
    // 导出功能翻译
    exportTooltip: {
        'zh_CN': '导出记录',
        'en': 'Export Records'
    },
    exportModalTitle: {
        'zh_CN': '导出书签记录',
        'en': 'Export Bookmarks'
    },
    exportScopeLabel: {
        'zh_CN': '导出范围',
        'en': 'Export Scope'
    },
    exportScopeCurrent: {
        'zh_CN': '当前视图: ',
        'en': 'Current View: '
    },
    exportScopeSelected: {
        'zh_CN': '当前勾选 ({0} 个日期)',
        'en': 'Selected ({0} dates)'
    },
    exportModeLabel: {
        'zh_CN': '导出模式',
        'en': 'Export Mode'
    },
    exportModeRecords: {
        'zh_CN': '仅导出添加记录',
        'en': 'Records Only'
    },
    exportModeRecordsDesc: {
        'zh_CN': '(仅现有记录)',
        'en': '(Current records only)'
    },
    exportModeContext: {
        'zh_CN': '现记录关联导出',
        'en': 'Context Export'
    },
    exportModeContextDesc: {
        'zh_CN': '(包含同文件夹下的其他书签)',
        'en': '(Includes siblings in folder)'
    },
    exportModeCollection: {
        'zh_CN': '集合导出到日期文件夹',
        'en': 'Collection Export'
    },
    exportModeCollectionDesc: {
        'zh_CN': '(按日期归档，不保留原目录名)',
        'en': '(Group by date, flat structure)'
    },
    exportFormatLabel: {
        'zh_CN': '导出格式',
        'en': 'Export Format'
    },
    exportFormatHtml: {
        'zh_CN': 'HTML (浏览器可导入)',
        'en': 'HTML (Importable)'
    },
    exportFormatJson: {
        'zh_CN': 'JSON',
        'en': 'JSON'
    },
    exportFormatCopy: {
        'zh_CN': '复制到剪贴板',
        'en': 'Copy to Clipboard'
    },
    exportBtnStart: {
        'zh_CN': '开始导出',
        'en': 'Start Export'
    },
    exportBtnProcessing: {
        'zh_CN': '正在处理...',
        'en': 'Processing...'
    },
    exportSuccessCopy: {
        'zh_CN': '已复制到剪贴板',
        'en': 'Copied to clipboard'
    },
    exportErrorNoFormat: {
        'zh_CN': '请至少选择一种导出格式',
        'en': 'Please select at least one format'
    },
    exportErrorNoData: {
        'zh_CN': '当前范围内没有可导出的书签',
        'en': 'No bookmarks to export in current scope'
    },
    exportFolderName: {
        'zh_CN': '书签添加记录',
        'en': 'Bookmark Records'
    },
    exportRootTitle: {
        'zh_CN': '书签导出',
        'en': 'Bookmark Export'
    },
    // 点击记录导出翻译
    browsingExportTooltip: {
        'zh_CN': '导出记录',
        'en': 'Export Records'
    },
    browsingExportModalTitle: {
        'zh_CN': '导出点击记录',
        'en': 'Export Click History'
    },
    browsingExportModeRecords: {
        'zh_CN': '仅导出点击记录',
        'en': 'Click Records Only'
    },
    browsingExportFolderName: {
        'zh_CN': '点击记录',
        'en': 'Click History'
    },
    // 时间捕捉翻译
    trackingTitle: {
        'zh_CN': '时间捕捉',
        'en': 'Time Tracking'
    },
    trackingToggleOn: {
        'zh_CN': '开启',
        'en': 'On'
    },
    trackingToggleOff: {
        'zh_CN': '关闭',
        'en': 'Off'
    },
    trackingClearBtn: {
        'zh_CN': '清除记录',
        'en': 'Clear Records'
    },
    trackingBlockBtn: {
        'zh_CN': '屏蔽管理',
        'en': 'Block Manager'
    },
    trackingBlockModalTitle: {
        'zh_CN': '时间追踪屏蔽管理',
        'en': 'Time Tracking Block Manager'
    },
    trackingBlockedBookmarksTitle: {
        'zh_CN': '已屏蔽书签',
        'en': 'Blocked Bookmarks'
    },
    trackingBlockedFoldersTitle: {
        'zh_CN': '已屏蔽文件夹',
        'en': 'Blocked Folders'
    },
    trackingBlockedDomainsTitle: {
        'zh_CN': '已屏蔽域名',
        'en': 'Blocked Domains'
    },
    trackingBlockedBookmarksEmpty: {
        'zh_CN': '暂无已屏蔽书签',
        'en': 'No blocked bookmarks'
    },
    trackingBlockedFoldersEmpty: {
        'zh_CN': '暂无已屏蔽文件夹',
        'en': 'No blocked folders'
    },
    trackingBlockedDomainsEmpty: {
        'zh_CN': '暂无已屏蔽域名',
        'en': 'No blocked domains'
    },
    addTrackingBlockDomainModalTitle: {
        'zh_CN': '添加屏蔽域名（时间追踪）',
        'en': 'Add Block Domain (Time Tracking)'
    },
    selectTrackingBlockFolderModalTitle: {
        'zh_CN': '选择要屏蔽的文件夹（时间追踪）',
        'en': 'Select Folder to Block (Time Tracking)'
    },
    addTrackingBlockBookmarkModalTitle: {
        'zh_CN': '添加屏蔽书签（时间追踪）',
        'en': 'Add Block Bookmark (Time Tracking)'
    },
    trackingBlockBookmarkTabTracking: {
        'zh_CN': '正在追踪',
        'en': 'Tracking'
    },
    trackingBlockBookmarkTabRanking: {
        'zh_CN': '综合排行',
        'en': 'Ranking'
    },
    trackingBlockBookmarkTabTree: {
        'zh_CN': '搜索',
        'en': 'Search'
    },
    trackingCurrentTitle: {
        'zh_CN': '正在追踪的书签',
        'en': 'Currently Tracking'
    },
    trackingNoActive: {
        'zh_CN': '暂无正在追踪的书签',
        'en': 'No active tracking sessions'
    },
    trackingHeaderState: {
        'zh_CN': '状态',
        'en': 'Status'
    },
    trackingHeaderTitle: {
        'zh_CN': '书签',
        'en': 'Bookmark'
    },
    trackingHeaderTime: {
        'zh_CN': '综合时间（当前）',
        'en': 'Composite Time (Current)'
    },
    trackingHeaderWakes: {
        'zh_CN': '唤醒',
        'en': 'Wakes'
    },
    trackingHeaderRatio: {
        'zh_CN': '活跃',
        'en': 'Active'
    },
    trackingRankingTitle: {
        'zh_CN': '综合排行',
        'en': 'Ranking'
    },
    trackingRankingTypeComposite: {
        'zh_CN': '综合时间',
        'en': 'Composite Time'
    },
    trackingRankingTypeWakes: {
        'zh_CN': '唤醒次数',
        'en': 'Wake Count'
    },
    trackingRangeToday: {
        'zh_CN': '今天',
        'en': 'Today'
    },
    trackingRangeWeek: {
        'zh_CN': '本周',
        'en': 'This Week'
    },
    trackingRangeMonth: {
        'zh_CN': '本月',
        'en': 'This Month'
    },
    trackingRangeYear: {
        'zh_CN': '当年',
        'en': 'This Year'
    },
    trackingRangeAll: {
        'zh_CN': '全部',
        'en': 'All Time'
    },
    trackingNoData: {
        'zh_CN': '暂无活跃时间数据',
        'en': 'No active time data'
    },
    trackingClearConfirm: {
        'zh_CN': '确定要清除所有时间追踪记录吗？此操作不可撤销。',
        'en': 'Are you sure you want to clear all tracking records? This action cannot be undone.'
    },
    trackingClearRangeConfirm: {
        'zh_CN': '确定要清除{range}以前的综合排行数据吗？',
        'en': 'Are you sure you want to clear ranking data older than {range}?'
    },
    trackingClearCurrentConfirm: {
        'zh_CN': '确定要清除正在追踪的会话吗？',
        'en': 'Are you sure you want to clear current tracking sessions?'
    },
    trackingClearRange: {
        'zh_CN': { week: '一周', month: '一个月', year: '一年', all: '全部' },
        'en': { week: '1 week', month: '1 month', year: '1 year', all: 'all time' }
    },
    trackingCleared: {
        'zh_CN': '追踪记录已清除',
        'en': 'Tracking records cleared'
    },
    trackingClearedCount: {
        'zh_CN': '已清除 {count} 条记录',
        'en': 'Cleared {count} records'
    },
    trackingSyncBtn: {
        'zh_CN': '数据同步',
        'en': 'Sync Data'
    },
    trackingSynced: {
        'zh_CN': '数据已同步',
        'en': 'Data synced'
    },
    trackingNoSyncNeeded: {
        'zh_CN': '数据一致，无需同步',
        'en': 'Data consistent, no sync needed'
    },
    trackingIdle: {
        'zh_CN': '挂机',
        'en': 'Idle'
    },
    trackingLoadFailed: {
        'zh_CN': '排行加载失败',
        'en': 'Failed to load ranking'
    },
    // 书签推荐翻译
    recommendViewTitle: {
        'zh_CN': '书签推荐',
        'en': 'Bookmark Recommendations'
    },
    recommendHelpTooltip: {
        'zh_CN': '帮助',
        'en': 'Help'
    },
    legendScore: {
        'zh_CN': '推荐分数',
        'en': 'Score'
    },
    legendRecall: {
        'zh_CN': '记忆度',
        'en': 'Recall'
    },
    recallDesc: {
        'zh_CN': '（FSRS遗忘曲线：复习后锐减，逐渐恢复）',
        'en': ' (FSRS curve: drops after review, gradually recovers)'
    },
    legendFreshness: {
        'zh_CN': '新鲜度',
        'en': 'Freshness'
    },
    legendColdness: {
        'zh_CN': '冷门度',
        'en': 'Coldness'
    },
    legendTimeDegree: {
        'zh_CN': '时间度',
        'en': 'Time Degree'
    },
    legendForgetting: {
        'zh_CN': '遗忘度',
        'en': 'Forgetting'
    },
    legendLaterReview: {
        'zh_CN': '待复习',
        'en': 'Later Review'
    },
    laterReviewDesc: {
        'zh_CN': '（手动添加后=1）',
        'en': '(=1 when manually added)'
    },
    thresholdFreshnessSuffix: {
        'zh_CN': '天',
        'en': ' days'
    },
    thresholdColdnessSuffix: {
        'zh_CN': '次',
        'en': ' clicks'
    },
    thresholdTimeDegreeSuffix: {
        'zh_CN': '分钟',
        'en': ' min'
    },
    thresholdForgettingSuffix: {
        'zh_CN': '天',
        'en': ' days'
    },
    presetDefault: {
        'zh_CN': '默认模式',
        'en': 'Default'
    },
    presetDefaultTip: {
        'zh_CN': '均衡推荐',
        'en': 'Balanced recommendation'
    },
    presetArchaeology: {
        'zh_CN': '考古模式',
        'en': 'Archaeology'
    },
    presetArchaeologyTip: {
        'zh_CN': '挖掘尘封已久的书签',
        'en': 'Dig up long-forgotten bookmarks'
    },
    presetConsolidate: {
        'zh_CN': '巩固模式',
        'en': 'Consolidate'
    },
    presetConsolidateTip: {
        'zh_CN': '经常访问但还没深入阅读的',
        'en': 'Frequently visited but not deeply read'
    },
    presetPriority: {
        'zh_CN': '优先巩固',
        'en': 'Priority'
    },
    presetPriorityTip: {
        'zh_CN': '优先复习手动添加的书签',
        'en': 'Prioritize manually added bookmarks'
    },
    presetWander: {
        'zh_CN': '漫游模式',
        'en': 'Wander'
    },
    presetWanderTip: {
        'zh_CN': '随机探索发现',
        'en': 'Random exploration'
    },
    resetFormulaText: {
        'zh_CN': '恢复默认',
        'en': 'Reset'
    },
    cardRefreshText: {
        'zh_CN': '刷新推荐',
        'en': 'Refresh'
    },
    refreshSettingsTitle: {
        'zh_CN': '自动刷新设置',
        'en': 'Auto Refresh Settings'
    },
    refreshEveryNOpensLabel: {
        'zh_CN': '每打开',
        'en': 'Every'
    },
    refreshEveryNOpensUnit: {
        'zh_CN': '次刷新',
        'en': 'opens, refresh'
    },
    refreshAfterHoursLabel: {
        'zh_CN': '距上次刷新超过',
        'en': 'After'
    },
    refreshAfterHoursUnit: {
        'zh_CN': '小时',
        'en': 'hours'
    },
    refreshAfterDaysLabel: {
        'zh_CN': '距上次刷新超过',
        'en': 'After'
    },
    refreshAfterDaysUnit: {
        'zh_CN': '天',
        'en': 'days'
    },
    refreshSettingsSave: {
        'zh_CN': '保存',
        'en': 'Save'
    },
    // 热力图
    heatmapTitle: {
        'zh_CN': '复习热力图',
        'en': 'Review Heatmap'
    },
    heatmapLoading: {
        'zh_CN': '热力图数据加载中...',
        'en': 'Loading heatmap data...'
    },
    // 待复习主区域
    postponedTitle: {
        'zh_CN': '待复习',
        'en': 'To Review'
    },
    priorityModeBadge: {
        'zh_CN': '⚡优先',
        'en': '⚡Priority'
    },
    postponedEmptyText: {
        'zh_CN': '暂无待复习的书签',
        'en': 'No bookmarks to review'
    },
    // 「Add to Review」弹窗
    addPostponedModalTitle: {
        'zh_CN': '添加到待复习',
        'en': 'Add to Review'
    },
    postponedAddBtnTitle: {
        'zh_CN': '添加书签到待复习',
        'en': 'Add bookmarks to review'
    },
    cardLaterTitle: {
        'zh_CN': '待复习',
        'en': 'To Review'
    },
    addTabFolder: {
        'zh_CN': '从文件夹',
        'en': 'From folder'
    },
    addTabSearch: {
        'zh_CN': '搜索书签',
        'en': 'Search bookmarks'
    },
    addTabDomain: {
        'zh_CN': '按域名',
        'en': 'By domain'
    },
    addFolderLabel: {
        'zh_CN': '选择文件夹：',
        'en': 'Choose folder:'
    },
    addCountLabel: {
        'zh_CN': '抽取数量：',
        'en': 'Count:'
    },
    addSelectAllLabel: {
        'zh_CN': '全部',
        'en': 'All'
    },
    addModeLabel: {
        'zh_CN': '抽取方式：',
        'en': 'Mode:'
    },
    addModeRandom: {
        'zh_CN': '随机',
        'en': 'Random'
    },
    addModeSequential: {
        'zh_CN': '顺序',
        'en': 'Sequential'
    },
    addIncludeSubfolders: {
        'zh_CN': '包含子文件夹',
        'en': 'Include subfolders'
    },
    addSearchPlaceholder: {
        'zh_CN': '搜索书签标题或URL...',
        'en': 'Search title or URL...'
    },
    addSearchEmpty: {
        'zh_CN': '输入关键词搜索书签',
        'en': 'Enter keyword to search bookmarks'
    },
    addSearchSelectedText: {
        'zh_CN': '已选择',
        'en': 'Selected'
    },
    addDomainSearchPlaceholder: {
        'zh_CN': '搜索域名...',
        'en': 'Search domain...'
    },
    addDomainLoading: {
        'zh_CN': '加载域名列表中...',
        'en': 'Loading domain list...'
    },
    addDomainSelectedText: {
        'zh_CN': '已选择',
        'en': 'Selected'
    },
    addDomainSelectedLabel: {
        'zh_CN': '个域名',
        'en': 'domains'
    },
    addPostponedCancelText: {
        'zh_CN': '取消',
        'en': 'Cancel'
    },
    addPostponedConfirmText: {
        'zh_CN': '添加',
        'en': 'Add'
    },
    // 屏蔽管理
    blockManageTitle: {
        'zh_CN': '屏蔽管理',
        'en': 'Block Management'
    },
    blockedBookmarksTitle: {
        'zh_CN': '已屏蔽书签',
        'en': 'Blocked Bookmarks'
    },
    blockedBookmarksEmptyText: {
        'zh_CN': '暂无已屏蔽书签',
        'en': 'No blocked bookmarks'
    },
    blockedFoldersTitle: {
        'zh_CN': '已屏蔽文件夹',
        'en': 'Blocked Folders'
    },
    blockedDomainsTitle: {
        'zh_CN': '已屏蔽域名',
        'en': 'Blocked Domains'
    },
    blockedFoldersEmptyText: {
        'zh_CN': '暂无已屏蔽文件夹',
        'en': 'No blocked folders'
    },
    blockedDomainsEmptyText: {
        'zh_CN': '暂无已屏蔽域名',
        'en': 'No blocked domains'
    },
    addDomainModalTitle: {
        'zh_CN': '添加屏蔽域名',
        'en': 'Add Blocked Domain'
    },
    addDomainModalDesc: {
        'zh_CN': '输入要屏蔽的域名（如 example.com）：',
        'en': 'Enter domain to block (e.g. example.com):'
    },
    addDomainCancelBtn: {
        'zh_CN': '取消',
        'en': 'Cancel'
    },
    addDomainConfirmBtn: {
        'zh_CN': '添加',
        'en': 'Add'
    },
    selectFolderModalTitle: {
        'zh_CN': '选择要屏蔽的文件夹',
        'en': 'Select Folder to Block'
    },
    folderBookmarkCount: {
        'zh_CN': '个书签',
        'en': 'bookmarks'
    },
    unnamedFolderLabel: {
        'zh_CN': '未命名文件夹',
        'en': 'Untitled folder'
    },
    // 稍后复习弹窗
    laterRecommendLabel: {
        'zh_CN': '根据浏览习惯推荐',
        'en': 'Recommended based on browsing'
    },
    laterOrText: {
        'zh_CN': '或自定义',
        'en': 'or custom'
    }
};
window.i18n = i18n; // 暴露给其他模块使用

// =============================================================================
// 初始化
// =============================================================================

document.addEventListener('DOMContentLoaded', async () => {
    console.log('历史查看器初始化...');

    // ========================================================================
    // 【关键步骤 -1】检测是否需要清除 localStorage（"恢复到初始状态"功能触发）
    // ========================================================================
    try {
        const resetCheck = await new Promise(resolve => {
            browserAPI.storage.local.get(['needClearLocalStorage'], result => resolve(result));
        });

        if (resetCheck && resetCheck.needClearLocalStorage === true) {
            console.log('[初始化] 检测到重置标志，正在清除 localStorage...');

            // 清除当前页面上下文的所有 localStorage
            localStorage.clear();

            // 移除重置标志（避免重复清除）
            await new Promise(resolve => {
                browserAPI.storage.local.remove(['needClearLocalStorage'], resolve);
            });

            console.log('[初始化] localStorage 已清除，重置标志已移除');
        }
    } catch (error) {
        console.warn('[初始化] 检测重置标志时出错:', error);
    }

    // ========================================================================
    // 【关键步骤 0】初始化 Favicon 缓存系统
    // ========================================================================
    try {
        await FaviconCache.init();
    } catch (error) {
        // 静默处理
    }

    // ========================================================================
    // 【关键步骤 0.5】迁移并加载历史视图设置（统一存储架构）
    // 将 localStorage 中的视图设置迁移到 chrome.storage.local
    // 这样 background.js 也能访问这些设置，实现 WYSIWYG 导出
    // ========================================================================
    try {
        await migrateHistoryViewSettingsFromLocalStorage();
        await loadHistoryViewSettings();
        console.log('[初始化] 历史视图设置已加载，当前模式:', historyDetailMode);
    } catch (error) {
        console.warn('[初始化] 加载历史视图设置失败:', error);
    }


    // 设置全局图片错误处理（避免CSP内联事件处理器）
    setupGlobalImageErrorHandler();

    // ========================================================================
    // 【关键步骤 1】最优先：立即恢复并应用视图状态
    // ========================================================================
    const urlParams = new URLSearchParams(window.location.search);
    const viewParam = urlParams.get('view');

    // 优先级：URL参数 > localStorage > 默认值
    if (viewParam && ['current-changes', 'history', 'additions', 'tree', 'canvas', 'recommend'].includes(viewParam)) {
        currentView = viewParam === 'tree' ? 'canvas' : viewParam;
        console.log('[初始化] 从URL参数设置视图:', currentView);

        // 【关键】应用 URL 参数后，立即从 URL 中移除 view 参数
        // 这样刷新页面时就会使用 localStorage，实现持久化
        const newUrl = new URL(window.location.href);
        newUrl.searchParams.delete('view');
        window.history.replaceState({}, '', newUrl.toString());
        console.log('[初始化] 已从URL中移除view参数，刷新时将使用localStorage');
    } else {
        const lastView = localStorage.getItem('lastActiveView');
        if (lastView && ['current-changes', 'history', 'additions', 'tree', 'canvas', 'recommend'].includes(lastView)) {
            currentView = lastView === 'tree' ? 'canvas' : lastView;
            console.log('[初始化] 从localStorage恢复视图:', currentView);
        } else {
            console.log('[初始化] 使用默认视图:', currentView);
        }
    }

    // 立即应用视图状态到DOM
    console.log('[初始化] >>>立即应用视图状态<<<:', currentView);
    document.querySelectorAll('.nav-tab').forEach(tab => {
        if (tab.dataset.view === currentView) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });
    document.querySelectorAll('.view').forEach(view => {
        if (view.id === `${currentView}View`) {
            view.classList.add('active');
        } else {
            view.classList.remove('active');
        }
    });
    localStorage.setItem('lastActiveView', currentView);
    console.log('[初始化] 视图状态已应用完成');

    // ========================================================================
    // 其他初始化
    // ========================================================================
    const recordTime = urlParams.get('record');
    console.log('[URL参数] 完整URL:', window.location.href);
    console.log('[URL参数] recordTime:', recordTime, 'viewParam:', viewParam);

    // 加载用户设置
    await loadUserSettings();

    // 初始化 UI（此时currentView已经是正确的值）
    initializeUI();

    // 初始化侧边栏收起功能
    initSidebarToggle();
    // 初始化全局导出功能
    initGlobalExport();

    // 初始化时间捕捉小组件
    initTimeTrackingWidget();

    // 初始化时间追踪屏蔽管理
    initTrackingBlockModal();
    initSelectTrackingBlockFolderModal();
    initAddTrackingBlockDomainModal();
    initAddTrackingBlockBookmarkModal();

    // 初始化右键菜单和拖拽功能
    if (typeof initContextMenu === 'function') {
        initContextMenu();
    }
    if (typeof initDragDrop === 'function') {
        initDragDrop();
    }

    // 初始化批量操作相关功能
    if (typeof initBatchToolbar === 'function') {
        initBatchToolbar();
        console.log('[主程序] 批量工具栏已初始化');
    }
    if (typeof initKeyboardShortcuts === 'function') {
        initKeyboardShortcuts();
        console.log('[主程序] 快捷键已初始化');
    }
    if (typeof initClickSelect === 'function') {
        initClickSelect();
        console.log('[主程序] 点击选择已初始化');
    }

    // 注册消息监听
    setupRealtimeMessageListener();

    // 设置事件委托处理所有按钮的data-action属性
    setupEventDelegation();

    // 恢复移动蓝标（避免 Canvas 懒加载模式下“刷新后移动效果消失”）
    await restoreExplicitMovedIdsFromStorage();

    // 先加载基础数据
    console.log('[初始化] 加载基础数据...');
    await loadAllData();

    // 如果有 recordTime 参数，立即打开详情弹窗（在UI渲染之前）
    if (recordTime) {
        console.log('[初始化] 快速打开详情面板，recordTime:', recordTime);
        const record = syncHistory.find(r => r.time == recordTime);
        if (record) {
            console.log('[初始化] 找到记录，立即打开详情面板');
            // 立即打开详情面板，不等待UI渲染
            setTimeout(() => showDetailModal(record), 0);

            // 清除 URL 中的 record 参数，避免刷新后再次弹出详情
            // 使用 replaceState 避免产生新的浏览历史记录
            try {
                const cleanUrl = new URL(window.location.href);
                cleanUrl.searchParams.delete('record');
                window.history.replaceState({}, '', cleanUrl.toString());
                console.log('[初始化] 已清除 URL 中的 record 参数');
            } catch (e) {
                console.warn('[初始化] 清除 record 参数失败:', e);
            }
        }
    }

    // 使用智能等待：尝试渲染，如果数据不完整则等待后重试
    // 初始化时强制刷新缓存，确保显示最新数据
    console.log('[初始化] 开始渲染当前视图:', currentView);

    // 根据当前视图渲染
    if (currentView === 'current-changes') {
        await renderCurrentChangesViewWithRetry(3, true);
    } else {
        await renderCurrentView();

        // 如果通过 window_marker.html 传入了定位参数，则在 Canvas 视图渲染后执行一次定位
        try {
            const lt = urlParams.get('lt'); // 'permanent' | 'temporary'
            const sid = urlParams.get('sid');
            const nid = urlParams.get('nid');
            const titleParam = urlParams.get('t');
            const typeParam = urlParams.get('type'); // 'hyperlink' 或 undefined

            if (titleParam && typeof titleParam === 'string' && titleParam.trim()) {
                // 根据type参数设置不同的标题格式
                if (typeParam === 'hyperlink') {
                    // 超链接系统：使用 "Hyperlink N" 格式
                    document.title = `Hyperlink ${titleParam.trim()}`;
                } else {
                    // 书签系统：直接使用数字
                    document.title = titleParam.trim();
                }
            }

            const waitFor = (predicate, timeout = 5000, interval = 50) => new Promise((resolve, reject) => {
                const start = Date.now();
                const tick = () => {
                    try {
                        if (predicate()) return resolve(true);
                        if (Date.now() - start >= timeout) return resolve(false);
                    } catch (_) { }
                    setTimeout(tick, interval);
                };
                tick();
            });

            if (currentView === 'canvas' && (lt === 'permanent' || lt === 'temporary')) {
                // 等待 Canvas 初始化完成
                await waitFor(() => window.CanvasModule && document.getElementById('canvasWorkspace'));
                if (lt === 'permanent') {
                    if (window.CanvasModule && typeof window.CanvasModule.locatePermanent === 'function') {
                        window.CanvasModule.locatePermanent();
                    }
                    if (nid) {
                        // 等待树节点渲染完成后滚动到对应书签
                        await waitFor(() => document.querySelector('#permanentSection .permanent-section-body .tree-item'));
                        const body = document.querySelector('#permanentSection .permanent-section-body');
                        const target = body ? body.querySelector(`.tree-item[data-node-id="${CSS.escape(nid)}"]`) : null;
                        if (target && target.scrollIntoView) {
                            try { target.scrollIntoView({ block: 'center', behavior: 'instant' }); } catch (_) { target.scrollIntoView(); }
                        }
                    }
                } else if (lt === 'temporary' && sid) {
                    if (window.CanvasModule && typeof window.CanvasModule.locateSection === 'function') {
                        try { window.CanvasModule.locateSection(sid); } catch (_) { }
                    }
                }
            }
        } catch (e) {
            console.warn('[初始化] Canvas 定位参数处理失败:', e);
        }
    }

    // 并行预加载其他视图和图标（不阻塞）
    Promise.all([
        preloadAllViews(),
        preloadCommonIcons()
    ]).then(() => {
        console.log('[初始化] 所有资源预加载完成');
    }).catch(error => {
        console.error('[初始化] 预加载失败:', error);
    });

    // 监听存储变化（实时更新）
    browserAPI.storage.onChanged.addListener(handleStorageChange);

    // 监听书签API变化（实时更新书签树视图）
    setupBookmarkListener();
    setupBrowsingHistoryRealtimeListeners();

    viewerInitialized = true;
    if (deferredAnalysisMessage) {
        const pendingMessage = deferredAnalysisMessage;
        deferredAnalysisMessage = null;
        handleAnalysisUpdatedMessage(pendingMessage);
    }

    console.log('历史查看器初始化完成');
});

// =============================================================================
// 用户设置
// =============================================================================

// 检查是否有覆盖设置
function hasThemeOverride() {
    try {
        return localStorage.getItem('historyViewerHasCustomTheme') === 'true';
    } catch (e) {
        return false;
    }
}

function hasLangOverride() {
    try {
        return localStorage.getItem('historyViewerHasCustomLang') === 'true';
    } catch (e) {
        return false;
    }
}

// 获取覆盖设置
function getThemeOverride() {
    try {
        return localStorage.getItem('historyViewerCustomTheme');
    } catch (e) {
        return null;
    }
}

function getLangOverride() {
    try {
        return localStorage.getItem('historyViewerCustomLang');
    } catch (e) {
        return null;
    }
}

async function loadUserSettings() {
    return new Promise((resolve) => {
        browserAPI.storage.local.get(['preferredLang', 'currentTheme'], (result) => {
            const mainUILang = result.preferredLang || 'zh_CN';
            const prefersDark = typeof window !== 'undefined'
                && window.matchMedia
                && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const mainUITheme = result.currentTheme || (prefersDark ? 'dark' : 'light');

            // 优先使用覆盖设置，否则使用主UI设置
            if (hasThemeOverride()) {
                currentTheme = getThemeOverride() || mainUITheme;
                console.log('[加载用户设置] 使用History Viewer的主题覆盖:', currentTheme);
            } else {
                currentTheme = mainUITheme;
                console.log('[加载用户设置] 跟随主UI主题:', currentTheme);
            }

            if (hasLangOverride()) {
                currentLang = getLangOverride() || mainUILang;
                window.currentLang = currentLang; // 同步到 window
                console.log('[加载用户设置] 使用History Viewer的语言覆盖:', currentLang);
            } else {
                currentLang = mainUILang;
                window.currentLang = currentLang; // 同步到 window
                console.log('[加载用户设置] 跟随主UI语言:', currentLang);
            }

            // 应用主题
            document.documentElement.setAttribute('data-theme', currentTheme);

            // 更新主题切换按钮图标
            const themeIcon = document.querySelector('#themeToggle i');
            if (themeIcon) {
                themeIcon.className = currentTheme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
            }

            // 应用语言
            applyLanguage();

            // 更新语言切换按钮文本
            const langText = document.querySelector('#langToggle .lang-text');
            if (langText) {
                langText.textContent = currentLang === 'zh_CN' ? 'EN' : '中';
            }

            resolve();
        });
    });
}

function applyLanguage() {
    // 更新所有文本
    document.getElementById('pageTitle').textContent = i18n.pageTitle[currentLang];
    document.getElementById('pageSubtitle').textContent = i18n.pageSubtitle[currentLang];
    document.getElementById('searchInput').placeholder = i18n.searchPlaceholder[currentLang];
    document.getElementById('navCurrentChangesText').textContent = i18n.navCurrentChanges[currentLang];
    document.getElementById('navHistoryText').textContent = i18n.navHistory[currentLang];
    document.getElementById('navAdditionsText').textContent = i18n.navAdditions[currentLang];
    document.getElementById('navCanvasText').textContent = i18n.navCanvas[currentLang];
    const navRecommendText = document.getElementById('navRecommendText');
    if (navRecommendText) navRecommendText.textContent = i18n.navRecommend[currentLang];
    document.getElementById('bookmarkGitTitle').textContent = i18n.bookmarkGitTitle[currentLang];
    document.getElementById('bookmarkToolboxTitle').textContent = i18n.bookmarkToolboxTitle[currentLang];

    const timeTrackingWidgetTitle = document.getElementById('timeTrackingWidgetTitle');
    if (timeTrackingWidgetTitle) timeTrackingWidgetTitle.textContent = i18n.timeTrackingWidgetTitle[currentLang];
    const timeTrackingWidgetEmptyText = document.getElementById('timeTrackingWidgetEmptyText');
    if (timeTrackingWidgetEmptyText) timeTrackingWidgetEmptyText.textContent = i18n.timeTrackingWidgetEmpty[currentLang];

    const currentChangesViewTitle = document.getElementById('currentChangesViewTitle');
    if (currentChangesViewTitle) currentChangesViewTitle.textContent = i18n.currentChangesViewTitle[currentLang];
    document.getElementById('historyViewTitle').textContent = i18n.historyViewTitle[currentLang];

    // 备份历史：清除记录按钮与确认弹窗
    const clearBackupHistoryBtn = document.getElementById('clearBackupHistoryBtn');
    if (clearBackupHistoryBtn) {
        // 使用 data-title + CSS tooltip，避免浏览器原生 title 的二次 tooltip
        clearBackupHistoryBtn.setAttribute('data-title', i18n.clearBackupHistoryTooltip[currentLang]);
        clearBackupHistoryBtn.removeAttribute('title');
    }
    const clearBackupHistoryModalTitle = document.getElementById('clearBackupHistoryModalTitle');
    if (clearBackupHistoryModalTitle) clearBackupHistoryModalTitle.textContent = i18n.clearBackupHistoryModalTitle[currentLang];
    const clearBackupHistoryModalDesc = document.getElementById('clearBackupHistoryModalDesc');
    if (clearBackupHistoryModalDesc) clearBackupHistoryModalDesc.textContent = i18n.clearBackupHistoryModalDesc[currentLang];

    // 删除选项控件
    const clearHistoryModePercentLabel = document.getElementById('clearHistoryModePercentLabel');
    if (clearHistoryModePercentLabel) clearHistoryModePercentLabel.textContent = i18n.clearHistoryModePercentLabel[currentLang];
    const clearHistoryModeCountLabel = document.getElementById('clearHistoryModeCountLabel');
    if (clearHistoryModeCountLabel) clearHistoryModeCountLabel.textContent = i18n.clearHistoryModeCountLabel[currentLang];
    const clearHistoryPercentLabelBefore = document.getElementById('clearHistoryPercentLabelBefore');
    if (clearHistoryPercentLabelBefore) clearHistoryPercentLabelBefore.textContent = i18n.clearHistoryPercentLabelBefore[currentLang];
    const clearHistoryCountLabelBefore = document.getElementById('clearHistoryCountLabelBefore');
    if (clearHistoryCountLabelBefore) clearHistoryCountLabelBefore.textContent = i18n.clearHistoryCountLabelBefore[currentLang];
    const clearHistoryCountLabelAfter = document.getElementById('clearHistoryCountLabelAfter');
    if (clearHistoryCountLabelAfter) clearHistoryCountLabelAfter.textContent = i18n.clearHistoryCountLabelAfter[currentLang];

    const clearBackupHistoryCancelBtn = document.getElementById('clearBackupHistoryCancelBtn');
    if (clearBackupHistoryCancelBtn) clearBackupHistoryCancelBtn.textContent = i18n.clearBackupHistoryCancelBtn[currentLang];
    const clearBackupHistoryConfirmBtn = document.getElementById('clearBackupHistoryConfirmBtn');
    if (clearBackupHistoryConfirmBtn) clearBackupHistoryConfirmBtn.textContent = i18n.clearBackupHistoryConfirmBtn[currentLang];

    // 二次确认弹窗
    const clearHistorySecondConfirmTitle = document.getElementById('clearHistorySecondConfirmTitle');
    if (clearHistorySecondConfirmTitle) clearHistorySecondConfirmTitle.textContent = i18n.clearHistorySecondConfirmTitle[currentLang];
    const clearHistorySecondConfirmPrefix = document.getElementById('clearHistorySecondConfirmPrefix');
    if (clearHistorySecondConfirmPrefix) clearHistorySecondConfirmPrefix.textContent = i18n.clearHistorySecondConfirmPrefix[currentLang];
    const clearHistorySecondConfirmSuffix = document.getElementById('clearHistorySecondConfirmSuffix');
    if (clearHistorySecondConfirmSuffix) clearHistorySecondConfirmSuffix.textContent = i18n.clearHistorySecondConfirmSuffix[currentLang];
    const clearHistorySecondConfirmWarning = document.getElementById('clearHistorySecondConfirmWarning');
    if (clearHistorySecondConfirmWarning) clearHistorySecondConfirmWarning.textContent = i18n.clearHistorySecondConfirmWarning[currentLang];
    const clearHistoryExportFirstText = document.getElementById('clearHistoryExportFirstText');
    if (clearHistoryExportFirstText) clearHistoryExportFirstText.textContent = i18n.clearHistoryExportFirstBtn[currentLang];
    const clearHistoryDirectDeleteText = document.getElementById('clearHistoryDirectDeleteText');
    if (clearHistoryDirectDeleteText) clearHistoryDirectDeleteText.textContent = i18n.clearHistoryDirectDeleteBtn[currentLang];
    const clearHistorySecondConfirmCancelText = document.getElementById('clearHistorySecondConfirmCancelText');
    if (clearHistorySecondConfirmCancelText) clearHistorySecondConfirmCancelText.textContent = i18n.clearHistorySecondConfirmCancelBtn[currentLang];

    // 备份历史详略模式切换按钮
    const historyDetailModeSimpleText = document.getElementById('historyDetailModeSimpleText');
    if (historyDetailModeSimpleText) historyDetailModeSimpleText.textContent = i18n.historyDetailModeSimple[currentLang];
    const historyDetailModeDetailedText = document.getElementById('historyDetailModeDetailedText');
    if (historyDetailModeDetailedText) historyDetailModeDetailedText.textContent = i18n.historyDetailModeDetailed[currentLang];
    const historyDetailModeSimpleModalText = document.getElementById('historyDetailModeSimpleModalText');
    if (historyDetailModeSimpleModalText) historyDetailModeSimpleModalText.textContent = i18n.historyDetailModeSimple[currentLang];
    const historyDetailModeDetailedModalText = document.getElementById('historyDetailModeDetailedModalText');
    if (historyDetailModeDetailedModalText) historyDetailModeDetailedModalText.textContent = i18n.historyDetailModeDetailed[currentLang];
    const modalTitle = document.getElementById('modalTitle');
    if (modalTitle) modalTitle.textContent = i18n.modalTitle[currentLang];
    const detailExportChangesBtn = document.getElementById('detailExportChangesBtn');
    if (detailExportChangesBtn) {
        detailExportChangesBtn.title = currentLang === 'zh_CN' ? '导出变化' : 'Export Changes';
    }
    const globalExportBtn = document.getElementById('globalExportBtn');
    if (globalExportBtn) {
        // 使用 data-title + CSS tooltip，避免浏览器原生 title 的二次 tooltip
        globalExportBtn.setAttribute('data-title', i18n.globalExport[currentLang]);
        globalExportBtn.removeAttribute('title');
    }
    const globalExportModalTitle = document.getElementById('globalExportModalTitle');
    if (globalExportModalTitle) globalExportModalTitle.textContent = i18n.globalExportModalTitle[currentLang];
    const globalExportFormatTitle = document.getElementById('globalExportFormatTitle');
    if (globalExportFormatTitle) globalExportFormatTitle.textContent = i18n.globalExportFormatTitle[currentLang];
    const globalExportFormatHint = document.getElementById('globalExportFormatHint');
    if (globalExportFormatHint) globalExportFormatHint.textContent = i18n.globalExportFormatHint[currentLang];
    const globalExportPackTitle = document.getElementById('globalExportPackTitle');
    if (globalExportPackTitle) globalExportPackTitle.textContent = i18n.globalExportPackTitle[currentLang];
    const globalExportPackZipText = document.getElementById('globalExportPackZipText');
    if (globalExportPackZipText) globalExportPackZipText.textContent = i18n.globalExportPackZip[currentLang];
    const globalExportPackMergeText = document.getElementById('globalExportPackMergeText');
    if (globalExportPackMergeText) globalExportPackMergeText.textContent = i18n.globalExportPackMerge[currentLang];
    const globalExportPackHint = document.getElementById('globalExportPackHint');
    if (globalExportPackHint) globalExportPackHint.innerHTML = i18n.globalExportPackHint[currentLang];
    const globalExportSelectTitle = document.getElementById('globalExportSelectTitle');
    if (globalExportSelectTitle) globalExportSelectTitle.textContent = i18n.globalExportSelectTitle[currentLang];
    const globalExportRangeEnabledText = document.getElementById('globalExportRangeEnabledText');
    if (globalExportRangeEnabledText) globalExportRangeEnabledText.textContent = i18n.globalExportRangeEnabledText[currentLang];
    const globalExportThSeq = document.getElementById('globalExportThSeq');
    if (globalExportThSeq) globalExportThSeq.textContent = i18n.globalExportThSeq[currentLang];
    const globalExportThNote = document.getElementById('globalExportThNote');
    if (globalExportThNote) globalExportThNote.textContent = i18n.globalExportThNote[currentLang];
    const globalExportThHash = document.getElementById('globalExportThHash');
    if (globalExportThHash) globalExportThHash.textContent = i18n.globalExportThHash[currentLang];
    const globalExportThViewMode = document.getElementById('globalExportThViewMode');
    if (globalExportThViewMode) globalExportThViewMode.textContent = i18n.globalExportThViewMode[currentLang];
    const globalExportThTime = document.getElementById('globalExportThTime');
    if (globalExportThTime) globalExportThTime.textContent = i18n.globalExportThTime[currentLang];
    const globalExportCancelBtn = document.getElementById('globalExportCancelBtn');
    if (globalExportCancelBtn) globalExportCancelBtn.textContent = i18n.globalExportCancel[currentLang];
    const globalExportConfirmText = document.getElementById('globalExportConfirmText');
    if (globalExportConfirmText) globalExportConfirmText.textContent = i18n.globalExportConfirm[currentLang];
    const globalExportStatus = document.getElementById('globalExportStatus');
    if (globalExportStatus) {
        try {
            updateGlobalExportStatus();
            updateGlobalExportRangePreviewText();
        } catch (e) {
            // ignore (function may not be available yet during early init)
        }
    }

    // 导出书签变化模态框
    const exportChangesModalTitle = document.getElementById('exportChangesModalTitle');
    if (exportChangesModalTitle) exportChangesModalTitle.textContent = i18n.exportChangesModalTitle[currentLang];
    const exportChangesFormatLabel = document.getElementById('exportChangesFormatLabel');
    if (exportChangesFormatLabel) exportChangesFormatLabel.textContent = i18n.exportChangesFormatLabel[currentLang];
    const exportChangesLegendHelp = document.getElementById('exportChangesLegendHelp');
    if (exportChangesLegendHelp) exportChangesLegendHelp.title = i18n.exportChangesLegendHelp[currentLang];
    const legendAdded = document.getElementById('legendAdded');
    if (legendAdded) legendAdded.textContent = i18n.legendAdded[currentLang];
    const legendDeleted = document.getElementById('legendDeleted');
    if (legendDeleted) legendDeleted.textContent = i18n.legendDeleted[currentLang];
    const legendModified = document.getElementById('legendModified');
    if (legendModified) legendModified.textContent = i18n.legendModified[currentLang];
    const legendMoved = document.getElementById('legendMoved');
    if (legendMoved) legendMoved.textContent = i18n.legendMoved[currentLang];
    const exportChangesModeLabel = document.getElementById('exportChangesModeLabel');
    if (exportChangesModeLabel) exportChangesModeLabel.textContent = i18n.exportChangesModeLabel[currentLang];
    const exportChangesModeSimple = document.getElementById('exportChangesModeSimple');
    if (exportChangesModeSimple) exportChangesModeSimple.textContent = i18n.exportChangesModeSimple[currentLang];
    const exportChangesModeDetailed = document.getElementById('exportChangesModeDetailed');
    if (exportChangesModeDetailed) exportChangesModeDetailed.textContent = i18n.exportChangesModeDetailed[currentLang];
    const exportChangesDetailedHelp = document.getElementById('exportChangesDetailedHelp');
    if (exportChangesDetailedHelp) exportChangesDetailedHelp.title = i18n.exportChangesDetailedHelp[currentLang];
    const exportChangesActionLabel = document.getElementById('exportChangesActionLabel');
    if (exportChangesActionLabel) exportChangesActionLabel.textContent = i18n.exportChangesActionLabel[currentLang];
    const exportChangesActionDownload = document.getElementById('exportChangesActionDownload');
    if (exportChangesActionDownload) exportChangesActionDownload.textContent = i18n.exportChangesActionDownload[currentLang];
    const exportChangesActionCopy = document.getElementById('exportChangesActionCopy');
    if (exportChangesActionCopy) exportChangesActionCopy.textContent = i18n.exportChangesActionCopy[currentLang];
    const exportChangesDepthLabel = document.getElementById('exportChangesDepthLabel');
    if (exportChangesDepthLabel) exportChangesDepthLabel.textContent = i18n.exportChangesDepthLabel[currentLang];
    const exportChangesDepth0 = document.getElementById('exportChangesDepth0');
    if (exportChangesDepth0) exportChangesDepth0.textContent = i18n.exportChangesDepth0[currentLang];

    // update doExportChangesBtnText which has HTML content
    const doExportChangesBtnText = document.getElementById('doExportChangesBtnText');
    if (doExportChangesBtnText) {
        doExportChangesBtnText.innerHTML = i18n.doExportChangesBtnText[currentLang];
    }

    // 更新 hidden legend title (hacky way because it is inside a structure that might not exist or be hidden)
    // We can query it by selector if we give it a class or ID. I gave it no ID.
    // Wait, I should have given the "Legend:" span an ID in previous steps. 
    // I added <span style="font-weight: bold; color: var(--text-primary);">标记说明：</span> in step 3. 
    // It has no ID. I should fix that in HTML first or just rely on the new translations for next render. But UI update is live.
    // For now I will skip the "Legend:" static text update in live mode, or I can select it via parent.
    const legendHelpContent = document.getElementById('exportChangesLegendHelpContent');
    if (legendHelpContent) {
        const titleSpan = legendHelpContent.querySelector('span[style*="font-weight: bold"]');
        if (titleSpan && i18n.exportChangesLegendTitle) titleSpan.textContent = i18n.exportChangesLegendTitle[currentLang];
    }

    // 书签树映射预览翻译
    const changesTreeTitleText = document.getElementById('changesTreeTitleText');
    if (changesTreeTitleText) changesTreeTitleText.textContent = i18n.changesTreeTitle[currentLang];
    const changesTreeEditText = document.getElementById('changesTreeEditText');
    if (changesTreeEditText) changesTreeEditText.textContent = i18n.changesTreeEdit[currentLang];
    const legendAddedText = document.getElementById('legendAddedText');
    if (legendAddedText) legendAddedText.textContent = i18n.legendAdded[currentLang];
    const legendDeletedText = document.getElementById('legendDeletedText');
    if (legendDeletedText) legendDeletedText.textContent = i18n.legendDeleted[currentLang];
    const legendMovedText = document.getElementById('legendMovedText');
    if (legendMovedText) legendMovedText.textContent = i18n.legendMoved[currentLang];
    const legendModifiedText = document.getElementById('legendModifiedText');
    if (legendModifiedText) legendModifiedText.textContent = i18n.legendModified[currentLang];
    document.getElementById('additionsViewTitle').textContent = i18n.additionsViewTitle[currentLang];
    // Canvas 视图按钮翻译
    const importCanvasText = document.getElementById('importCanvasText');
    if (importCanvasText) importCanvasText.textContent = i18n.importCanvasText[currentLang];
    const exportCanvasText = document.getElementById('exportCanvasText');
    if (exportCanvasText) exportCanvasText.textContent = i18n.exportCanvasText[currentLang];
    const clearMenuText = document.getElementById('clearMenuText');
    if (clearMenuText) clearMenuText.textContent = i18n.clearMenuText[currentLang];
    const clearByClickText = document.getElementById('clearByClickText');
    if (clearByClickText) clearByClickText.textContent = i18n.clearByClickText[currentLang];
    const clearTempNodesText = document.getElementById('clearTempNodesText');
    if (clearTempNodesText) clearTempNodesText.textContent = i18n.clearTempNodesText[currentLang];
    const clearAllText = document.getElementById('clearAllText');
    if (clearAllText) clearAllText.textContent = i18n.clearAllText[currentLang];

    // 清除规则提示框翻译
    const clearRulesTooltipTitle = document.getElementById('clearRulesTooltipTitle');
    if (clearRulesTooltipTitle) clearRulesTooltipTitle.textContent = i18n.clearRulesTooltipTitle[currentLang];
    const clearRulesWillClear = document.getElementById('clearRulesWillClear');
    if (clearRulesWillClear) clearRulesWillClear.textContent = i18n.clearRulesWillClear[currentLang];
    const clearRulesWillKeep = document.getElementById('clearRulesWillKeep');
    if (clearRulesWillKeep) clearRulesWillKeep.textContent = i18n.clearRulesWillKeep[currentLang];
    const clearRuleTemp = document.getElementById('clearRuleTemp');
    if (clearRuleTemp) clearRuleTemp.innerHTML = i18n.clearRuleTemp[currentLang];
    const clearRuleMd = document.getElementById('clearRuleMd');
    if (clearRuleMd) clearRuleMd.innerHTML = i18n.clearRuleMd[currentLang];
    const clearRuleKeepDesc = document.getElementById('clearRuleKeepDesc');
    if (clearRuleKeepDesc) clearRuleKeepDesc.innerHTML = i18n.clearRuleKeepDesc[currentLang];
    const clearRuleKeepTitle = document.getElementById('clearRuleKeepTitle');
    if (clearRuleKeepTitle) clearRuleKeepTitle.innerHTML = i18n.clearRuleKeepTitle[currentLang];
    const clearRuleKeepEdge = document.getElementById('clearRuleKeepEdge');
    if (clearRuleKeepEdge) clearRuleKeepEdge.innerHTML = i18n.clearRuleKeepEdge[currentLang];

    // Canvas 缩放控制器
    const canvasZoomLabel = document.getElementById('canvasZoomLabel');
    if (canvasZoomLabel) canvasZoomLabel.textContent = i18n.canvasZoomLabel[currentLang];

    // 日历加载文本
    const calendarLoadingText = document.getElementById('calendarLoadingText');
    if (calendarLoadingText) calendarLoadingText.textContent = i18n.calendarLoading[currentLang];

    // 日历按钮文本
    const calendarSelectModeText = document.getElementById('calendarSelectModeText');
    if (calendarSelectModeText) calendarSelectModeText.textContent = i18n.calendarSelectMode[currentLang];
    const calendarLocateTodayText = document.getElementById('calendarLocateTodayText');
    if (calendarLocateTodayText) calendarLocateTodayText.textContent = i18n.calendarLocateToday[currentLang];

    // 更新日历视图翻译
    if (typeof updateBookmarkCalendarLanguage === 'function') {
        updateBookmarkCalendarLanguage();
    }
    if (typeof updateBrowsingHistoryCalendarLanguage === 'function') {
        updateBrowsingHistoryCalendarLanguage();
    }
    const zoomInBtn = document.getElementById('zoomInBtn');
    if (zoomInBtn) zoomInBtn.title = i18n.zoomInTitle[currentLang];
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    if (zoomOutBtn) zoomOutBtn.title = i18n.zoomOutTitle[currentLang];
    const zoomLocateBtn = document.getElementById('zoomLocateBtn');
    if (zoomLocateBtn) zoomLocateBtn.title = i18n.zoomLocateTitle[currentLang];
    const zoomLocateText = document.getElementById('zoomLocateText');
    if (zoomLocateText) zoomLocateText.textContent = i18n.zoomLocateText[currentLang];

    // Canvas 管理和帮助按钮翻译
    const canvasManageText = document.getElementById('canvasManageText');
    if (canvasManageText) canvasManageText.textContent = i18n.canvasManageText[currentLang];
    const canvasManageBtn = document.getElementById('canvasManageBtn');
    if (canvasManageBtn) canvasManageBtn.title = i18n.canvasManageTitle[currentLang];
    const canvasHelpBtn = document.getElementById('canvasHelpBtn');
    if (canvasHelpBtn) canvasHelpBtn.title = i18n.canvasHelpBtnTitle[currentLang];

    // Canvas 管理弹窗翻译
    const canvasManageModalTitle = document.getElementById('canvasManageModalTitle');
    if (canvasManageModalTitle) canvasManageModalTitle.textContent = i18n.canvasManageTitle[currentLang];

    // Canvas 快捷键帮助弹窗翻译
    const canvasHelpModalTitle = document.getElementById('canvasHelpModalTitle');
    if (canvasHelpModalTitle) canvasHelpModalTitle.textContent = i18n.canvasHelpModalTitle[currentLang];
    const canvasHelpCtrlTitle = document.getElementById('canvasHelpCtrlTitle');
    if (canvasHelpCtrlTitle) canvasHelpCtrlTitle.textContent = i18n.canvasHelpCtrlTitle[currentLang];
    const canvasHelpCtrlLeftClick = document.getElementById('canvasHelpCtrlLeftClick');
    if (canvasHelpCtrlLeftClick) canvasHelpCtrlLeftClick.textContent = i18n.canvasHelpCtrlLeftClick[currentLang];
    const canvasHelpCtrlLeftDesc = document.getElementById('canvasHelpCtrlLeftDesc');
    if (canvasHelpCtrlLeftDesc) canvasHelpCtrlLeftDesc.textContent = i18n.canvasHelpCtrlLeftDesc[currentLang];
    const canvasHelpCtrlWheel = document.getElementById('canvasHelpCtrlWheel');
    if (canvasHelpCtrlWheel) canvasHelpCtrlWheel.textContent = i18n.canvasHelpCtrlWheel[currentLang];
    const canvasHelpCtrlWheelDesc = document.getElementById('canvasHelpCtrlWheelDesc');
    if (canvasHelpCtrlWheelDesc) canvasHelpCtrlWheelDesc.textContent = i18n.canvasHelpCtrlWheelDesc[currentLang];
    const canvasHelpCtrlRightClick = document.getElementById('canvasHelpCtrlRightClick');
    if (canvasHelpCtrlRightClick) canvasHelpCtrlRightClick.textContent = i18n.canvasHelpCtrlRightClick[currentLang];
    const canvasHelpCtrlRightDesc = document.getElementById('canvasHelpCtrlRightDesc');
    if (canvasHelpCtrlRightDesc) canvasHelpCtrlRightDesc.textContent = i18n.canvasHelpCtrlRightDesc[currentLang];
    const canvasHelpSpaceTitle = document.getElementById('canvasHelpSpaceTitle');
    if (canvasHelpSpaceTitle) canvasHelpSpaceTitle.textContent = i18n.canvasHelpSpaceTitle[currentLang];
    const canvasHelpSpaceKey = document.getElementById('canvasHelpSpaceKey');
    if (canvasHelpSpaceKey) canvasHelpSpaceKey.textContent = i18n.canvasHelpSpaceKey[currentLang];
    const canvasHelpSpaceLeftClick = document.getElementById('canvasHelpSpaceLeftClick');
    if (canvasHelpSpaceLeftClick) canvasHelpSpaceLeftClick.textContent = i18n.canvasHelpSpaceLeftClick[currentLang];
    const canvasHelpSpaceDesc = document.getElementById('canvasHelpSpaceDesc');
    if (canvasHelpSpaceDesc) canvasHelpSpaceDesc.textContent = i18n.canvasHelpSpaceDesc[currentLang];
    const canvasHelpTouchpadTitle = document.getElementById('canvasHelpTouchpadTitle');
    if (canvasHelpTouchpadTitle) canvasHelpTouchpadTitle.textContent = i18n.canvasHelpTouchpadTitle[currentLang];
    const canvasHelpTouchpadPinch = document.getElementById('canvasHelpTouchpadPinch');
    if (canvasHelpTouchpadPinch) canvasHelpTouchpadPinch.textContent = i18n.canvasHelpTouchpadPinch[currentLang];
    const canvasHelpTouchpadPinchDesc = document.getElementById('canvasHelpTouchpadPinchDesc');
    if (canvasHelpTouchpadPinchDesc) canvasHelpTouchpadPinchDesc.textContent = i18n.canvasHelpTouchpadPinchDesc[currentLang];
    const canvasHelpTouchpadScroll = document.getElementById('canvasHelpTouchpadScroll');
    if (canvasHelpTouchpadScroll) canvasHelpTouchpadScroll.textContent = i18n.canvasHelpTouchpadScroll[currentLang];
    const canvasHelpTouchpadScrollDesc = document.getElementById('canvasHelpTouchpadScrollDesc');
    if (canvasHelpTouchpadScrollDesc) canvasHelpTouchpadScrollDesc.textContent = i18n.canvasHelpTouchpadScrollDesc[currentLang];

    // 快捷键编辑按钮和录制器翻译
    const editCtrlKeyBtn = document.getElementById('editCtrlKeyBtn');
    if (editCtrlKeyBtn) editCtrlKeyBtn.title = i18n.canvasShortcutEditTitle[currentLang];
    const editSpaceKeyBtn = document.getElementById('editSpaceKeyBtn');
    if (editSpaceKeyBtn) editSpaceKeyBtn.title = i18n.canvasShortcutEditTitle[currentLang];
    const recorderCancelBtn = document.getElementById('recorderCancelBtn');
    if (recorderCancelBtn) recorderCancelBtn.textContent = i18n.canvasShortcutRecorderCancel[currentLang];
    const recorderHelpBtn = document.getElementById('recorderHelpBtn');
    if (recorderHelpBtn) recorderHelpBtn.title = i18n.recorderHelpBtnTitle[currentLang];
    const recorderHelpTitle = document.getElementById('recorderHelpTitle');
    if (recorderHelpTitle) recorderHelpTitle.textContent = i18n.recorderHelpTitle[currentLang];
    const tooltipModifierLabel = document.getElementById('tooltipModifierLabel');
    if (tooltipModifierLabel) tooltipModifierLabel.textContent = i18n.tooltipModifierLabel[currentLang];
    const tooltipSpecialLabel = document.getElementById('tooltipSpecialLabel');
    if (tooltipSpecialLabel) tooltipSpecialLabel.textContent = i18n.tooltipSpecialLabel[currentLang];
    const tooltipLetterLabel = document.getElementById('tooltipLetterLabel');
    if (tooltipLetterLabel) tooltipLetterLabel.textContent = i18n.tooltipLetterLabel[currentLang];
    const tooltipNumberLabel = document.getElementById('tooltipNumberLabel');
    if (tooltipNumberLabel) tooltipNumberLabel.textContent = i18n.tooltipNumberLabel[currentLang];

    // 更新快捷键显示（如果CanvasModule已加载）
    if (window.CanvasModule && typeof window.CanvasModule.updateShortcutDisplays === 'function') {
        window.CanvasModule.updateShortcutDisplays();
    }

    const fullscreenBtn = document.getElementById('canvasFullscreenBtn');
    if (fullscreenBtn) {
        // Always update fullscreen button to ensure language changes are applied
        if (window.CanvasModule && typeof window.CanvasModule.updateFullscreenButton === 'function') {
            window.CanvasModule.updateFullscreenButton();
        }
        // Also apply text directly to ensure it's set in current language
        const container = document.querySelector('.canvas-main-container');
        const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        const isFullscreen = container && fullscreenElement === container;
        const key = isFullscreen ? 'canvasFullscreenExit' : 'canvasFullscreenEnter';
        const text = i18n[key] && i18n[key][currentLang] ? i18n[key][currentLang] : (key === 'canvasFullscreenExit' ? (currentLang === 'en' ? 'Exit' : '退出') : (currentLang === 'en' ? 'Fullscreen' : '全屏'));
        fullscreenBtn.textContent = text;
        fullscreenBtn.setAttribute('aria-label', text);
        fullscreenBtn.classList.toggle('fullscreen-active', Boolean(isFullscreen));
        fullscreenBtn.setAttribute('aria-pressed', isFullscreen ? 'true' : 'false');
    }

    // Canvas永久栏目文本
    const permanentSectionTitle = document.getElementById('permanentSectionTitle');
    if (permanentSectionTitle) permanentSectionTitle.textContent = i18n.permanentSectionTitle[currentLang];
    const permanentSectionTip = document.getElementById('permanentSectionTip');
    if (permanentSectionTip) {
        // 若用户已自定义说明，则保留用户内容；仅在无自定义时应用 placeholder（不写入内容）
        const placeholder = i18n.permanentSectionTip[currentLang];
        try {
            permanentSectionTip.setAttribute('data-placeholder', placeholder);
            permanentSectionTip.setAttribute('aria-label', placeholder);
        } catch (_) { }

        let savedTip = '';
        try { savedTip = localStorage.getItem('canvas-permanent-tip-text') || ''; } catch { }
        if (!savedTip.trim()) {
            // 兼容旧逻辑：若 DOM 里残留了“点击添加说明...”等占位文本，清空以启用 :empty::before
            const t = (permanentSectionTip.textContent || '').trim();
            const zh = i18n.permanentSectionTip['zh_CN'];
            const en = i18n.permanentSectionTip['en'];
            if (t === zh || t === en) {
                permanentSectionTip.innerHTML = '';
            }
        }
    }

    // 更新按钮文本

    const revertAllCurrentText = document.getElementById('revertAllCurrentText');
    if (revertAllCurrentText) revertAllCurrentText.textContent = i18n.revertAll[currentLang];

    // 以下元素在「书签点击排行」UI中，已被删除，需要安全检查
    const filterAll = document.getElementById('filterAll');
    if (filterAll) filterAll.textContent = i18n.filterAll[currentLang];
    const filterBackedUp = document.getElementById('filterBackedUp');
    if (filterBackedUp) filterBackedUp.textContent = i18n.filterBackedUp[currentLang];
    const filterNotBackedUp = document.getElementById('filterNotBackedUp');
    if (filterNotBackedUp) filterNotBackedUp.textContent = i18n.filterNotBackedUp[currentLang];
    const filterStatusLabel = document.getElementById('filterStatusLabel');
    if (filterStatusLabel) filterStatusLabel.textContent = i18n.filterStatus[currentLang];
    const filterTimeLabel = document.getElementById('filterTimeLabel');
    if (filterTimeLabel) filterTimeLabel.textContent = i18n.filterTime[currentLang];
    const timeFilterAll = document.getElementById('timeFilterAll');
    if (timeFilterAll) timeFilterAll.textContent = i18n.timeFilterAll[currentLang];
    const timeFilterYear = document.getElementById('timeFilterYear');
    if (timeFilterYear) timeFilterYear.textContent = i18n.timeFilterYear[currentLang];
    const timeFilterMonth = document.getElementById('timeFilterMonth');
    if (timeFilterMonth) timeFilterMonth.textContent = i18n.timeFilterMonth[currentLang];
    const timeFilterDay = document.getElementById('timeFilterDay');
    if (timeFilterDay) timeFilterDay.textContent = i18n.timeFilterDay[currentLang];
    // 已删除JSON视图，不再需要更新这些元素
    // document.getElementById('treeViewModeText').textContent = i18n.treeViewMode[currentLang];
    // document.getElementById('jsonViewModeText').textContent = i18n.jsonViewMode[currentLang];
    document.getElementById('modalTitle').textContent = i18n.modalTitle[currentLang];

    // 更新工具按钮气泡
    const refreshTooltip = document.getElementById('refreshTooltip');
    if (refreshTooltip) refreshTooltip.textContent = i18n.refreshTooltip[currentLang];
    const themeTooltip = document.getElementById('themeTooltip');
    if (themeTooltip) themeTooltip.textContent = i18n.themeTooltip[currentLang];
    const langTooltip = document.getElementById('langTooltip');
    if (langTooltip) langTooltip.textContent = i18n.langTooltip[currentLang];
    const helpTooltip = document.getElementById('helpTooltip');
    if (helpTooltip) {
        helpTooltip.textContent = i18n.helpTooltip[currentLang];
    }

    // 更新快捷键弹窗文本
    const shortcutsModalTitle = document.getElementById('shortcutsModalTitle');
    if (shortcutsModalTitle) {
        shortcutsModalTitle.textContent = i18n.shortcutsModalTitle[currentLang];
    }
    const openSourceGithubLabel = document.getElementById('openSourceGithubLabel');
    if (openSourceGithubLabel) {
        openSourceGithubLabel.textContent = i18n.openSourceGithubLabel[currentLang];
    }
    const openSourceIssueLabel = document.getElementById('openSourceIssueLabel');
    if (openSourceIssueLabel) {
        openSourceIssueLabel.textContent = i18n.openSourceIssueLabel[currentLang];
    }
    const openSourceIssueText = document.getElementById('openSourceIssueText');
    if (openSourceIssueText) {
        openSourceIssueText.textContent = i18n.openSourceIssueText[currentLang];
    }
    const shortcutsContent = document.getElementById('shortcutsContent');
    if (shortcutsContent) {
        updateShortcutsDisplay();
    }
    const closeShortcutsText = document.getElementById('closeShortcutsText');
    if (closeShortcutsText) {
        closeShortcutsText.textContent = i18n.closeShortcutsText[currentLang];
    }

    // 更新横向滚动条提示文字
    const scrollbarHint = document.querySelector('.canvas-scrollbar.horizontal .scrollbar-hint');
    if (scrollbarHint) scrollbarHint.textContent = i18n.horizontalScrollHint[currentLang];

    // 书签温故子标签与文案
    const additionsTabReview = document.getElementById('additionsTabReview');
    if (additionsTabReview) additionsTabReview.textContent = i18n.additionsTabReview[currentLang];
    const additionsTabBrowsing = document.getElementById('additionsTabBrowsing');
    if (additionsTabBrowsing) additionsTabBrowsing.textContent = i18n.additionsTabBrowsing[currentLang];

    const additionsTabTracking = document.getElementById('additionsTabTracking');
    if (additionsTabTracking) additionsTabTracking.textContent = i18n.additionsTabTracking[currentLang];

    const trackingPanelDesc = document.getElementById('trackingPanelDesc');
    if (trackingPanelDesc) trackingPanelDesc.textContent = i18n.trackingPanelDesc[currentLang];

    const clearTrackingText = document.getElementById('clearTrackingText');
    if (clearTrackingText) clearTrackingText.textContent = i18n.clearTrackingText[currentLang];

    // 浏览记录子标签
    const browsingTabHistory = document.getElementById('browsingTabHistory');
    if (browsingTabHistory) browsingTabHistory.textContent = i18n.browsingTabHistory[currentLang];
    const browsingTabRanking = document.getElementById('browsingTabRanking');
    const browsingTabRelated = document.getElementById('browsingTabRelated');
    if (browsingTabRelated) browsingTabRelated.textContent = i18n.browsingTabRelated[currentLang];
    if (browsingTabRanking) browsingTabRanking.textContent = i18n.browsingTabRanking[currentLang];

    // 浏览记录相关文本
    const browsingRankingTitle = document.getElementById('browsingRankingTitle');
    if (browsingRankingTitle) browsingRankingTitle.textContent = i18n.browsingRankingTitle[currentLang];
    const browsingRankingDescription = document.getElementById('browsingRankingDescription');
    if (browsingRankingDescription) browsingRankingDescription.textContent = i18n.browsingRankingDescription[currentLang];
    const browsingRankingFilterDay = document.getElementById('browsingRankingFilterDay');
    if (browsingRankingFilterDay) browsingRankingFilterDay.textContent = i18n.browsingRankingFilterToday[currentLang];
    const browsingRankingFilterWeek = document.getElementById('browsingRankingFilterWeek');
    if (browsingRankingFilterWeek) browsingRankingFilterWeek.textContent = i18n.browsingRankingFilterWeek[currentLang];
    const browsingRankingFilterMonth = document.getElementById('browsingRankingFilterMonth');
    if (browsingRankingFilterMonth) browsingRankingFilterMonth.textContent = i18n.browsingRankingFilterMonth[currentLang];
    const browsingRankingFilterYear = document.getElementById('browsingRankingFilterYear');
    if (browsingRankingFilterYear) browsingRankingFilterYear.textContent = i18n.browsingRankingFilterYear[currentLang];
    const browsingRankingFilterAll = document.getElementById('browsingRankingFilterAll');
    if (browsingRankingFilterAll) browsingRankingFilterAll.textContent = i18n.browsingRankingFilterAll[currentLang];

    // 书签关联记录相关文本
    const browsingRelatedTitle = document.getElementById('browsingRelatedTitle');
    if (browsingRelatedTitle) browsingRelatedTitle.textContent = i18n.browsingRelatedTitle[currentLang];
    const browsingRelatedDescription = document.getElementById('browsingRelatedDescription');
    if (browsingRelatedDescription) browsingRelatedDescription.textContent = i18n.browsingRelatedDescription[currentLang];
    const browsingRelatedLoadingText = document.getElementById('browsingRelatedLoadingText');
    if (browsingRelatedLoadingText) browsingRelatedLoadingText.textContent = i18n.browsingRelatedLoadingText[currentLang];
    const browsingRelatedFilterDay = document.getElementById('browsingRelatedFilterDay');
    if (browsingRelatedFilterDay) browsingRelatedFilterDay.textContent = i18n.browsingRelatedFilterDay[currentLang];
    const browsingRelatedFilterWeek = document.getElementById('browsingRelatedFilterWeek');
    if (browsingRelatedFilterWeek) browsingRelatedFilterWeek.textContent = i18n.browsingRelatedFilterWeek[currentLang];
    const browsingRelatedFilterMonth = document.getElementById('browsingRelatedFilterMonth');
    if (browsingRelatedFilterMonth) browsingRelatedFilterMonth.textContent = i18n.browsingRelatedFilterMonth[currentLang];
    const browsingRelatedFilterYear = document.getElementById('browsingRelatedFilterYear');
    if (browsingRelatedFilterYear) browsingRelatedFilterYear.textContent = i18n.browsingRelatedFilterYear[currentLang];
    const browsingRelatedFilterAll = document.getElementById('browsingRelatedFilterAll');
    if (browsingRelatedFilterAll) browsingRelatedFilterAll.textContent = i18n.browsingRelatedFilterAll[currentLang];
    const browsingCalendarLoadingText = document.getElementById('browsingCalendarLoadingText');
    if (browsingCalendarLoadingText) browsingCalendarLoadingText.textContent = i18n.browsingCalendarLoading[currentLang];

    const nativeHistoryText = document.getElementById('nativeHistoryButtonText');
    if (nativeHistoryText) nativeHistoryText.textContent = i18n.nativeHistoryButtonText[currentLang];
    const groupedHistoryText = document.getElementById('groupedHistoryButtonText');
    if (groupedHistoryText) groupedHistoryText.textContent = i18n.groupedHistoryButtonText[currentLang];

    const additionsAnkiTitle = document.getElementById('additionsAnkiTitle');
    if (additionsAnkiTitle) additionsAnkiTitle.textContent = i18n.additionsAnkiTitle[currentLang];
    const additionsAnkiDescription = document.getElementById('additionsAnkiDescription');
    if (additionsAnkiDescription) additionsAnkiDescription.textContent = i18n.additionsAnkiDescription[currentLang];

    // 导出相关翻译
    const exportTooltip = document.getElementById('calendarExportTooltip');
    if (exportTooltip) exportTooltip.textContent = i18n.exportTooltip[currentLang];

    const exportModalTitle = document.getElementById('exportModalTitle');
    if (exportModalTitle) exportModalTitle.textContent = i18n.exportModalTitle[currentLang];

    const doExportBtn = document.getElementById('doExportBtn');
    if (doExportBtn) {
        // 保留图标
        const icon = doExportBtn.querySelector('i');
        doExportBtn.childNodes[doExportBtn.childNodes.length - 1].textContent = ' ' + i18n.exportBtnStart[currentLang];
    }

    // 更新导出弹窗内的标签（需要遍历查找，因为没有ID，或者我们给它们加ID）
    // 这里为了简单，我们在HTML中添加data-i18n属性会更好，但现在直接操作DOM
    // 重新打开弹窗时也会触发文本更新（见 BookmarkCalendar.openExportModal）
    // 但我们需要在 applyLanguage 中也处理一下静态文本

    document.querySelectorAll('#exportModal h4').forEach((h4, index) => {
        if (index === 0) h4.textContent = i18n.exportScopeLabel[currentLang];
        if (index === 1) h4.textContent = i18n.exportModeLabel[currentLang];
        if (index === 2) h4.textContent = i18n.exportFormatLabel[currentLang];
    });

    // 导出选项文本更新
    const updateRadioLabel = (val, titleKey, descKey) => {
        const input = document.querySelector(`input[name="exportMode"][value="${val}"]`);
        if (input && input.nextElementSibling) {
            const span = input.nextElementSibling;
            span.innerHTML = `${i18n[titleKey][currentLang]} <small style="color: var(--text-tertiary);">${i18n[descKey][currentLang]}</small>`;
        }
    };

    updateRadioLabel('records', 'exportModeRecords', 'exportModeRecordsDesc');
    updateRadioLabel('context', 'exportModeContext', 'exportModeContextDesc');
    updateRadioLabel('collection', 'exportModeCollection', 'exportModeCollectionDesc');

    const updateCheckboxLabel = (val, titleKey) => {
        const input = document.querySelector(`input[name="exportFormat"][value="${val}"]`);
        if (input && input.nextElementSibling) {
            input.nextElementSibling.textContent = i18n[titleKey][currentLang];
        }
    };

    updateCheckboxLabel('html', 'exportFormatHtml');
    updateCheckboxLabel('json', 'exportFormatJson');
    updateCheckboxLabel('copy', 'exportFormatCopy');

    // 导出相关翻译 (点击记录)
    const browsingExportTooltip = document.getElementById('browsingCalendarExportTooltip');
    if (browsingExportTooltip) browsingExportTooltip.textContent = i18n.browsingExportTooltip[currentLang];

    const browsingSelectModeText = document.getElementById('browsingCalendarSelectModeText');
    if (browsingSelectModeText) browsingSelectModeText.textContent = i18n.calendarSelectMode[currentLang];

    const browsingLocateTodayText = document.getElementById('browsingCalendarLocateTodayText');
    if (browsingLocateTodayText) browsingLocateTodayText.textContent = i18n.calendarLocateToday[currentLang];

    const browsingExportModalTitle = document.getElementById('browsingExportModalTitle');
    if (browsingExportModalTitle) browsingExportModalTitle.textContent = i18n.browsingExportModalTitle[currentLang];

    const doBrowsingExportBtn = document.getElementById('doBrowsingExportBtn');
    if (doBrowsingExportBtn) {
        // 保留图标
        const icon = doBrowsingExportBtn.querySelector('i');
        doBrowsingExportBtn.childNodes[doBrowsingExportBtn.childNodes.length - 1].textContent = ' ' + i18n.exportBtnStart[currentLang];
    }

    // 更新点击记录导出弹窗内的标签
    document.querySelectorAll('#browsingExportModal h4').forEach((h4, index) => {
        if (index === 0) h4.textContent = i18n.exportScopeLabel[currentLang];
        if (index === 1) h4.textContent = i18n.exportModeLabel[currentLang];
        if (index === 2) h4.textContent = i18n.exportFormatLabel[currentLang];
    });

    // 导出选项文本更新 (点击记录)
    const updateBrowsingRadioLabel = (val, titleKey, descKey) => {
        const input = document.querySelector(`input[name="browsingExportMode"][value="${val}"]`);
        if (input && input.nextElementSibling) {
            const span = input.nextElementSibling;
            span.innerHTML = `${i18n[titleKey][currentLang]} <small style="color: var(--text-tertiary);">${i18n[descKey][currentLang]}</small>`;
        }
    };

    updateBrowsingRadioLabel('records', 'browsingExportModeRecords', 'exportModeRecordsDesc');
    updateBrowsingRadioLabel('context', 'exportModeContext', 'exportModeContextDesc');
    updateBrowsingRadioLabel('collection', 'exportModeCollection', 'exportModeCollectionDesc');

    const updateBrowsingCheckboxLabel = (val, titleKey) => {
        const input = document.querySelector(`input[name="browsingExportFormat"][value="${val}"]`);
        if (input && input.nextElementSibling) {
            input.nextElementSibling.textContent = i18n[titleKey][currentLang];
        }
    };

    updateBrowsingCheckboxLabel('html', 'exportFormatHtml');
    updateBrowsingCheckboxLabel('json', 'exportFormatJson');
    updateBrowsingCheckboxLabel('copy', 'exportFormatCopy');

    // 时间捕捉翻译
    const trackingTitle = document.getElementById('trackingTitle');
    if (trackingTitle) trackingTitle.textContent = i18n.trackingTitle[currentLang];

    const trackingToggleText = document.getElementById('trackingToggleText');
    if (trackingToggleText) {
        const toggleBtn = document.getElementById('trackingToggleBtn');
        const isActive = toggleBtn && toggleBtn.classList.contains('active');
        trackingToggleText.textContent = isActive ?
            i18n.trackingToggleOn[currentLang] : i18n.trackingToggleOff[currentLang];
    }

    const clearTrackingBtn = document.getElementById('clearTrackingBtn');
    if (clearTrackingBtn) clearTrackingBtn.title = i18n.trackingClearBtn[currentLang];

    // 时间追踪屏蔽按钮和弹窗国际化
    const trackingBlockBtn = document.getElementById('trackingBlockBtn');
    if (trackingBlockBtn) {
        trackingBlockBtn.title = i18n.trackingBlockBtn[currentLang];
        const textSpan = trackingBlockBtn.querySelector('#trackingBlockText');
        if (textSpan) textSpan.textContent = currentLang === 'en' ? 'Block' : '屏蔽';
    }

    const trackingBlockModalTitle = document.getElementById('trackingBlockModalTitle');
    if (trackingBlockModalTitle) trackingBlockModalTitle.textContent = i18n.trackingBlockModalTitle[currentLang];

    const trackingBlockedBookmarksTitle = document.getElementById('trackingBlockedBookmarksTitle');
    if (trackingBlockedBookmarksTitle) trackingBlockedBookmarksTitle.textContent = i18n.trackingBlockedBookmarksTitle[currentLang];

    const trackingBlockedFoldersTitle = document.getElementById('trackingBlockedFoldersTitle');
    if (trackingBlockedFoldersTitle) trackingBlockedFoldersTitle.textContent = i18n.trackingBlockedFoldersTitle[currentLang];

    const trackingBlockedDomainsTitle = document.getElementById('trackingBlockedDomainsTitle');
    if (trackingBlockedDomainsTitle) trackingBlockedDomainsTitle.textContent = i18n.trackingBlockedDomainsTitle[currentLang];

    const trackingBlockedBookmarksEmptyText = document.getElementById('trackingBlockedBookmarksEmptyText');
    if (trackingBlockedBookmarksEmptyText) trackingBlockedBookmarksEmptyText.textContent = i18n.trackingBlockedBookmarksEmpty[currentLang];

    const trackingBlockedFoldersEmptyText = document.getElementById('trackingBlockedFoldersEmptyText');
    if (trackingBlockedFoldersEmptyText) trackingBlockedFoldersEmptyText.textContent = i18n.trackingBlockedFoldersEmpty[currentLang];

    const trackingBlockedDomainsEmptyText = document.getElementById('trackingBlockedDomainsEmptyText');
    if (trackingBlockedDomainsEmptyText) trackingBlockedDomainsEmptyText.textContent = i18n.trackingBlockedDomainsEmpty[currentLang];

    const addTrackingBlockDomainModalTitle = document.getElementById('addTrackingBlockDomainModalTitle');
    if (addTrackingBlockDomainModalTitle) addTrackingBlockDomainModalTitle.textContent = i18n.addTrackingBlockDomainModalTitle[currentLang];

    const selectTrackingBlockFolderModalTitle = document.getElementById('selectTrackingBlockFolderModalTitle');
    if (selectTrackingBlockFolderModalTitle) selectTrackingBlockFolderModalTitle.textContent = i18n.selectTrackingBlockFolderModalTitle[currentLang];

    // 添加域名弹窗的国际化
    const addTrackingBlockDomainSearchInput = document.getElementById('addTrackingBlockDomainSearchInput');
    if (addTrackingBlockDomainSearchInput) addTrackingBlockDomainSearchInput.placeholder = currentLang === 'en' ? 'Search or enter domain...' : '搜索或输入域名...';

    const addTrackingBlockDomainSelectedText = document.getElementById('addTrackingBlockDomainSelectedText');
    if (addTrackingBlockDomainSelectedText) addTrackingBlockDomainSelectedText.textContent = currentLang === 'en' ? 'Selected' : '已选择';

    const addTrackingBlockDomainCancelBtn = document.getElementById('addTrackingBlockDomainCancelBtn');
    if (addTrackingBlockDomainCancelBtn) addTrackingBlockDomainCancelBtn.textContent = currentLang === 'en' ? 'Cancel' : '取消';

    const addTrackingBlockDomainConfirmBtn = document.getElementById('addTrackingBlockDomainConfirmBtn');
    if (addTrackingBlockDomainConfirmBtn) addTrackingBlockDomainConfirmBtn.textContent = currentLang === 'en' ? 'Add Block' : '添加屏蔽';

    // 添加书签弹窗的国际化
    const addTrackingBlockBookmarkModalTitle = document.getElementById('addTrackingBlockBookmarkModalTitle');
    if (addTrackingBlockBookmarkModalTitle) addTrackingBlockBookmarkModalTitle.textContent = i18n.addTrackingBlockBookmarkModalTitle[currentLang];

    const trackingBlockBookmarkTabTracking = document.getElementById('trackingBlockBookmarkTabTracking');
    if (trackingBlockBookmarkTabTracking) {
        trackingBlockBookmarkTabTracking.innerHTML = `<i class="fas fa-broadcast-tower"></i> ${i18n.trackingBlockBookmarkTabTracking[currentLang]}`;
    }

    const trackingBlockBookmarkTabRanking = document.getElementById('trackingBlockBookmarkTabRanking');
    if (trackingBlockBookmarkTabRanking) {
        trackingBlockBookmarkTabRanking.innerHTML = `<i class="fas fa-chart-bar"></i> ${i18n.trackingBlockBookmarkTabRanking[currentLang]}`;
    }

    const trackingBlockBookmarkTabTree = document.getElementById('trackingBlockBookmarkTabTree');
    if (trackingBlockBookmarkTabTree) {
        trackingBlockBookmarkTabTree.innerHTML = `<i class="fas fa-search"></i> ${i18n.trackingBlockBookmarkTabTree[currentLang]}`;
    }

    const addTrackingBlockBookmarkSearchInput = document.getElementById('addTrackingBlockBookmarkSearchInput');
    if (addTrackingBlockBookmarkSearchInput) addTrackingBlockBookmarkSearchInput.placeholder = currentLang === 'en' ? 'Search bookmarks...' : '搜索书签...';

    const addTrackingBlockBookmarkSelectedText = document.getElementById('addTrackingBlockBookmarkSelectedText');
    if (addTrackingBlockBookmarkSelectedText) addTrackingBlockBookmarkSelectedText.textContent = currentLang === 'en' ? 'Selected' : '已选择';

    const addTrackingBlockBookmarkCancelBtn = document.getElementById('addTrackingBlockBookmarkCancelBtn');
    if (addTrackingBlockBookmarkCancelBtn) addTrackingBlockBookmarkCancelBtn.textContent = currentLang === 'en' ? 'Cancel' : '取消';

    const addTrackingBlockBookmarkConfirmBtn = document.getElementById('addTrackingBlockBookmarkConfirmBtn');
    if (addTrackingBlockBookmarkConfirmBtn) addTrackingBlockBookmarkConfirmBtn.textContent = currentLang === 'en' ? 'Add Block' : '添加屏蔽';

    const trackingCurrentTitle = document.getElementById('trackingCurrentTitle');
    if (trackingCurrentTitle) trackingCurrentTitle.textContent = i18n.trackingCurrentTitle[currentLang];

    const trackingNoActiveText = document.getElementById('trackingNoActiveText');
    if (trackingNoActiveText) trackingNoActiveText.textContent = i18n.trackingNoActive[currentLang];

    const trackingHeaderState = document.getElementById('trackingHeaderState');
    if (trackingHeaderState) {
        // 更新文本 span，保留帮助图标
        const textSpan = trackingHeaderState.querySelector('.tracking-header-text');
        if (textSpan) {
            textSpan.textContent = i18n.trackingHeaderState[currentLang];
        }
        // 更新图标的 title
        const helpIcon = trackingHeaderState.querySelector('.tracking-state-help');
        if (helpIcon) {
            helpIcon.title = currentLang === 'en' ? 'State Guide' : '状态说明';
        }
    }
    const trackingHeaderTitle = document.getElementById('trackingHeaderTitle');
    if (trackingHeaderTitle) trackingHeaderTitle.textContent = i18n.trackingHeaderTitle[currentLang];
    const trackingHeaderTime = document.getElementById('trackingHeaderTime');
    if (trackingHeaderTime) trackingHeaderTime.textContent = i18n.trackingHeaderTime[currentLang];
    const trackingHeaderWakes = document.getElementById('trackingHeaderWakes');
    if (trackingHeaderWakes) trackingHeaderWakes.textContent = i18n.trackingHeaderWakes[currentLang];
    const trackingHeaderRatio = document.getElementById('trackingHeaderRatio');
    if (trackingHeaderRatio) trackingHeaderRatio.textContent = i18n.trackingHeaderRatio[currentLang];

    const trackingRankingTitle = document.getElementById('trackingRankingTitle');
    if (trackingRankingTitle) trackingRankingTitle.textContent = i18n.trackingRankingTitle[currentLang];

    const trackingRankingTypeComposite = document.getElementById('trackingRankingTypeComposite');
    if (trackingRankingTypeComposite) trackingRankingTypeComposite.textContent = i18n.trackingRankingTypeComposite[currentLang];

    const trackingRankingTypeWakes = document.getElementById('trackingRankingTypeWakes');
    if (trackingRankingTypeWakes) trackingRankingTypeWakes.textContent = i18n.trackingRankingTypeWakes[currentLang];

    const trackingRangeToday = document.getElementById('trackingRangeToday');
    if (trackingRangeToday) trackingRangeToday.textContent = i18n.trackingRangeToday[currentLang];

    const trackingRangeWeek = document.getElementById('trackingRangeWeek');
    if (trackingRangeWeek) trackingRangeWeek.textContent = i18n.trackingRangeWeek[currentLang];

    const trackingRangeMonth = document.getElementById('trackingRangeMonth');
    if (trackingRangeMonth) trackingRangeMonth.textContent = i18n.trackingRangeMonth[currentLang];

    const trackingRangeYear = document.getElementById('trackingRangeYear');
    if (trackingRangeYear) trackingRangeYear.textContent = i18n.trackingRangeYear[currentLang];

    const trackingRangeAll = document.getElementById('trackingRangeAll');
    if (trackingRangeAll) trackingRangeAll.textContent = i18n.trackingRangeAll[currentLang];

    const trackingNoDataText = document.getElementById('trackingNoDataText');
    if (trackingNoDataText) trackingNoDataText.textContent = i18n.trackingNoData[currentLang];

    // 书签推荐翻译
    const recommendViewTitle = document.getElementById('recommendViewTitle');
    if (recommendViewTitle) recommendViewTitle.textContent = i18n.recommendViewTitle[currentLang];

    const recommendHelpBtn = document.getElementById('recommendHelpBtn');
    if (recommendHelpBtn) recommendHelpBtn.title = i18n.recommendHelpTooltip[currentLang];

    const legendScore = document.getElementById('legendScore');
    if (legendScore) legendScore.textContent = i18n.legendScore[currentLang];

    const legendFreshness = document.getElementById('legendFreshness');
    if (legendFreshness) legendFreshness.textContent = i18n.legendFreshness[currentLang];

    const legendColdness = document.getElementById('legendColdness');
    if (legendColdness) legendColdness.textContent = i18n.legendColdness[currentLang];

    const legendTimeDegree = document.getElementById('legendTimeDegree');
    if (legendTimeDegree) legendTimeDegree.textContent = i18n.legendTimeDegree[currentLang];

    const legendForgetting = document.getElementById('legendForgetting');
    if (legendForgetting) legendForgetting.textContent = i18n.legendForgetting[currentLang];

    const legendLaterReview = document.getElementById('legendLaterReview');
    if (legendLaterReview) legendLaterReview.textContent = i18n.legendLaterReview[currentLang];

    const legendRecall = document.getElementById('legendRecall');
    if (legendRecall) legendRecall.textContent = i18n.legendRecall[currentLang];

    const recallDesc = document.getElementById('recallDesc');
    if (recallDesc) recallDesc.textContent = i18n.recallDesc[currentLang];

    const laterReviewDesc = document.getElementById('laterReviewDesc');
    if (laterReviewDesc) laterReviewDesc.textContent = i18n.laterReviewDesc[currentLang];

    // 公式阈值（需要特殊处理，保留输入框）- 使用幂函数衰减公式
    document.querySelectorAll('.threshold-item').forEach((item, index) => {
        const input = item.querySelector('input');
        if (input) {
            const formulas = [
                { zh: 'F = 1/(1+(添加天数/', en: 'F = 1/(1+(days/' },
                { zh: 'C = 1/(1+(点击数/', en: 'C = 1/(1+(clicks/' },
                { zh: 'T = 1/(1+(综合时间/', en: 'T = 1/(1+(time/' },
                { zh: 'D = 1-1/(1+(未访问/', en: 'D = 1-1/(1+(unvisited/' }
            ];
            const suffixes = [
                { zh: ')⁰·⁷)', en: ')⁰·⁷)' },
                { zh: ')⁰·⁷)', en: ')⁰·⁷)' },
                { zh: '分钟)⁰·⁷)', en: 'min)⁰·⁷)' },
                { zh: '天)⁰·⁷)', en: 'days)⁰·⁷)' }
            ];
            const prefix = currentLang === 'en' ? formulas[index].en : formulas[index].zh;
            const suffix = currentLang === 'en' ? suffixes[index].en : suffixes[index].zh;
            // 重建内容
            const inputValue = input.value;
            const inputId = input.id;
            const inputClass = input.className;
            item.innerHTML = `${prefix}<input type="text" class="${inputClass}" id="${inputId}" value="${inputValue}">${suffix}`;
        }
    });

    // 预设模式按钮
    document.querySelectorAll('.preset-btn').forEach(btn => {
        const mode = btn.dataset.mode;
        const span = btn.querySelector('span');
        if (mode === 'default' && span) {
            span.textContent = i18n.presetDefault[currentLang];
            btn.title = i18n.presetDefaultTip[currentLang];
        } else if (mode === 'archaeology' && span) {
            span.textContent = i18n.presetArchaeology[currentLang];
            btn.title = i18n.presetArchaeologyTip[currentLang];
        } else if (mode === 'consolidate' && span) {
            span.textContent = i18n.presetConsolidate[currentLang];
            btn.title = i18n.presetConsolidateTip[currentLang];
        } else if (mode === 'wander' && span) {
            span.textContent = i18n.presetWander[currentLang];
            btn.title = i18n.presetWanderTip[currentLang];
        } else if (mode === 'priority' && span) {
            span.textContent = i18n.presetPriority[currentLang];
            btn.title = i18n.presetPriorityTip[currentLang];
        }
    });

    const resetFormulaText = document.getElementById('resetFormulaText');
    if (resetFormulaText) resetFormulaText.textContent = i18n.resetFormulaText[currentLang];

    const cardRefreshText = document.getElementById('cardRefreshText');
    if (cardRefreshText) cardRefreshText.textContent = i18n.cardRefreshText[currentLang];

    const refreshSettingsTitle = document.getElementById('refreshSettingsTitle');
    if (refreshSettingsTitle) refreshSettingsTitle.textContent = i18n.refreshSettingsTitle[currentLang];

    const refreshEveryNOpensLabel = document.getElementById('refreshEveryNOpensLabel');
    if (refreshEveryNOpensLabel) refreshEveryNOpensLabel.textContent = i18n.refreshEveryNOpensLabel[currentLang];

    const refreshEveryNOpensUnit = document.getElementById('refreshEveryNOpensUnit');
    if (refreshEveryNOpensUnit) refreshEveryNOpensUnit.textContent = i18n.refreshEveryNOpensUnit[currentLang];

    const refreshAfterHoursLabel = document.getElementById('refreshAfterHoursLabel');
    if (refreshAfterHoursLabel) refreshAfterHoursLabel.textContent = i18n.refreshAfterHoursLabel[currentLang];

    const refreshAfterHoursUnit = document.getElementById('refreshAfterHoursUnit');
    if (refreshAfterHoursUnit) refreshAfterHoursUnit.textContent = i18n.refreshAfterHoursUnit[currentLang];

    const refreshAfterDaysLabel = document.getElementById('refreshAfterDaysLabel');
    if (refreshAfterDaysLabel) refreshAfterDaysLabel.textContent = i18n.refreshAfterDaysLabel[currentLang];

    const refreshAfterDaysUnit = document.getElementById('refreshAfterDaysUnit');
    if (refreshAfterDaysUnit) refreshAfterDaysUnit.textContent = i18n.refreshAfterDaysUnit[currentLang];

    const refreshSettingsSaveText = document.getElementById('refreshSettingsSaveText');
    if (refreshSettingsSaveText) refreshSettingsSaveText.textContent = i18n.refreshSettingsSave[currentLang];

    const heatmapTitle = document.getElementById('heatmapTitle');
    if (heatmapTitle) heatmapTitle.textContent = i18n.heatmapTitle[currentLang];

    const heatmapLoadingText = document.getElementById('heatmapLoadingText');
    if (heatmapLoadingText) heatmapLoadingText.textContent = i18n.heatmapLoading[currentLang];

    // 待复习区域翻译
    const postponedTitle = document.getElementById('postponedTitle');
    if (postponedTitle) postponedTitle.textContent = i18n.postponedTitle[currentLang];

    const priorityBadge = document.getElementById('postponedPriorityBadge');
    if (priorityBadge) priorityBadge.textContent = i18n.priorityModeBadge[currentLang];

    const postponedEmptyText = document.getElementById('postponedEmptyText');
    if (postponedEmptyText) postponedEmptyText.textContent = i18n.postponedEmptyText[currentLang];

    const addPostponedModalTitle = document.getElementById('addPostponedModalTitle');
    if (addPostponedModalTitle) addPostponedModalTitle.textContent = i18n.addPostponedModalTitle[currentLang];

    const postponedAddBtn = document.getElementById('postponedAddBtn');
    if (postponedAddBtn) postponedAddBtn.title = i18n.postponedAddBtnTitle[currentLang];

    // 「Add to Review」弹窗翻译
    const addTabFolder = document.getElementById('addTabFolder');
    if (addTabFolder) addTabFolder.textContent = i18n.addTabFolder[currentLang];

    const addTabSearch = document.getElementById('addTabSearch');
    if (addTabSearch) addTabSearch.textContent = i18n.addTabSearch[currentLang];

    const addTabDomain = document.getElementById('addTabDomain');
    if (addTabDomain) addTabDomain.textContent = i18n.addTabDomain[currentLang];

    const addFolderLabel = document.getElementById('addFolderLabel');
    if (addFolderLabel) addFolderLabel.textContent = i18n.addFolderLabel[currentLang];

    const addCountLabel = document.getElementById('addCountLabel');
    if (addCountLabel) addCountLabel.textContent = i18n.addCountLabel[currentLang];

    const addSelectAllLabel = document.getElementById('addSelectAllLabel');
    if (addSelectAllLabel) addSelectAllLabel.textContent = i18n.addSelectAllLabel[currentLang];

    const addModeLabel = document.getElementById('addModeLabel');
    if (addModeLabel) addModeLabel.textContent = i18n.addModeLabel[currentLang];

    const addModeRandom = document.getElementById('addModeRandom');
    if (addModeRandom) addModeRandom.textContent = i18n.addModeRandom[currentLang];

    const addModeSequential = document.getElementById('addModeSequential');
    if (addModeSequential) addModeSequential.textContent = i18n.addModeSequential[currentLang];

    const addIncludeSubfolders = document.getElementById('addIncludeSubfolders');
    if (addIncludeSubfolders) addIncludeSubfolders.textContent = i18n.addIncludeSubfolders[currentLang];

    const addSearchInput = document.getElementById('addSearchInput');
    if (addSearchInput) addSearchInput.placeholder = i18n.addSearchPlaceholder[currentLang];

    const addSearchEmpty = document.getElementById('addSearchEmpty');
    if (addSearchEmpty) addSearchEmpty.textContent = i18n.addSearchEmpty[currentLang];

    const addSearchSelectedText = document.getElementById('addSearchSelectedText');
    if (addSearchSelectedText) addSearchSelectedText.textContent = i18n.addSearchSelectedText[currentLang];

    const addDomainSearchInput = document.getElementById('addDomainSearchInput');
    if (addDomainSearchInput) addDomainSearchInput.placeholder = i18n.addDomainSearchPlaceholder[currentLang];

    const addDomainLoading = document.getElementById('addDomainLoading');
    if (addDomainLoading) addDomainLoading.textContent = i18n.addDomainLoading[currentLang];

    const addDomainSelectedText = document.getElementById('addDomainSelectedText');
    if (addDomainSelectedText) addDomainSelectedText.textContent = i18n.addDomainSelectedText[currentLang];

    const addDomainSelectedLabel = document.getElementById('addDomainSelectedLabel');
    if (addDomainSelectedLabel) addDomainSelectedLabel.textContent = i18n.addDomainSelectedLabel[currentLang];

    const addPostponedCancelBtn = document.getElementById('addPostponedCancelBtn');
    if (addPostponedCancelBtn) addPostponedCancelBtn.textContent = i18n.addPostponedCancelText[currentLang];

    const addPostponedConfirmBtn = document.getElementById('addPostponedConfirmBtn');
    if (addPostponedConfirmBtn) addPostponedConfirmBtn.textContent = i18n.addPostponedConfirmText[currentLang];

    // 卡片按钮title
    document.querySelectorAll('.card-btn-later').forEach(btn => {
        btn.title = i18n.cardLaterTitle[currentLang];
    });

    // 屏蔽管理翻译
    const blockManageTitle = document.getElementById('blockManageTitle');
    if (blockManageTitle) blockManageTitle.textContent = i18n.blockManageTitle[currentLang];

    const blockedBookmarksTitle = document.getElementById('blockedBookmarksTitle');
    if (blockedBookmarksTitle) blockedBookmarksTitle.textContent = i18n.blockedBookmarksTitle[currentLang];

    const blockedBookmarksEmptyText = document.getElementById('blockedBookmarksEmptyText');
    if (blockedBookmarksEmptyText) blockedBookmarksEmptyText.textContent = i18n.blockedBookmarksEmptyText[currentLang];

    const blockedFoldersTitle = document.getElementById('blockedFoldersTitle');
    if (blockedFoldersTitle) blockedFoldersTitle.textContent = i18n.blockedFoldersTitle[currentLang];

    const blockedDomainsTitle = document.getElementById('blockedDomainsTitle');
    if (blockedDomainsTitle) blockedDomainsTitle.textContent = i18n.blockedDomainsTitle[currentLang];

    const blockedFoldersEmptyText = document.getElementById('blockedFoldersEmptyText');
    if (blockedFoldersEmptyText) blockedFoldersEmptyText.textContent = i18n.blockedFoldersEmptyText[currentLang];

    const blockedDomainsEmptyText = document.getElementById('blockedDomainsEmptyText');
    if (blockedDomainsEmptyText) blockedDomainsEmptyText.textContent = i18n.blockedDomainsEmptyText[currentLang];

    const addDomainModalTitle = document.getElementById('addDomainModalTitle');
    if (addDomainModalTitle) addDomainModalTitle.textContent = i18n.addDomainModalTitle[currentLang];

    const addDomainModalDesc = document.getElementById('addDomainModalDesc');
    if (addDomainModalDesc) addDomainModalDesc.textContent = i18n.addDomainModalDesc[currentLang];

    const addDomainCancelBtn = document.getElementById('addDomainCancelBtn');
    if (addDomainCancelBtn) addDomainCancelBtn.textContent = i18n.addDomainCancelBtn[currentLang];

    const addDomainConfirmBtn = document.getElementById('addDomainConfirmBtn');
    if (addDomainConfirmBtn) addDomainConfirmBtn.textContent = i18n.addDomainConfirmBtn[currentLang];

    const selectFolderModalTitle = document.getElementById('selectFolderModalTitle');
    if (selectFolderModalTitle) selectFolderModalTitle.textContent = i18n.selectFolderModalTitle[currentLang];

    // 稍后复习弹窗翻译
    const laterRecommendLabel = document.getElementById('laterRecommendLabel');
    if (laterRecommendLabel) laterRecommendLabel.textContent = i18n.laterRecommendLabel[currentLang];

    const laterOrText = document.getElementById('laterOrText');
    if (laterOrText) laterOrText.textContent = i18n.laterOrText[currentLang];

    // 更新语言切换按钮
    document.querySelector('#langToggle .lang-text').textContent = currentLang === 'zh_CN' ? 'EN' : '中';

    // 更新主题切换按钮图标
    const themeIcon = document.querySelector('#themeToggle i');
    if (currentTheme === 'dark') {
        themeIcon.className = 'fas fa-sun';
    } else {
        themeIcon.className = 'fas fa-moon';
    }
}

// =============================================================================
// UI 初始化
// =============================================================================

function initializeUI() {
    // 导航标签切换
    document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.addEventListener('click', () => switchView(tab.dataset.view));
    });

    // 状态过滤按钮（已删除，但保留代码以防恢复）
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            currentFilter = btn.dataset.filter;
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            renderAdditionsView();
        });
    });

    // 时间过滤按钮（已删除，但保留代码以防恢复）
    document.querySelectorAll('.time-filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            currentTimeFilter = btn.dataset.timeFilter;
            document.querySelectorAll('.time-filter-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            renderAdditionsView();
        });
    });

    // 「书签温故」子视图标签
    initAdditionsSubTabs();

    // 工具按钮

    document.getElementById('themeToggle').addEventListener('click', toggleTheme);
    document.getElementById('langToggle').addEventListener('click', toggleLanguage);
    const helpToggle = document.getElementById('helpToggle');
    const shortcutsModal = document.getElementById('shortcutsModal');
    const closeShortcutsModal = document.getElementById('closeShortcutsModal');
    if (helpToggle && shortcutsModal) {
        helpToggle.addEventListener('click', () => {
            if (typeof updateShortcutsDisplay === 'function') {
                updateShortcutsDisplay();
            }
            shortcutsModal.classList.add('show');
        });
    }
    if (closeShortcutsModal && shortcutsModal) {
        closeShortcutsModal.addEventListener('click', () => {
            shortcutsModal.classList.remove('show');
        });
    }
    // 点击弹窗外部区域关闭（只在点击遮罩本身时触发）
    if (shortcutsModal) {
        shortcutsModal.addEventListener('click', (e) => {
            if (e.target === shortcutsModal) {
                shortcutsModal.classList.remove('show');
            }
        });
    }

    // 撤销全部按钮（当前变化和书签树）
    const revertAllCurrentBtn = document.getElementById('revertAllCurrentBtn');
    if (revertAllCurrentBtn) {
        revertAllCurrentBtn.addEventListener('click', () => handleRevertAll('current'));
    }

    // 初始化历史列表分页
    initHistoryPagination();

    // 初始化恢复模态框
    initRestoreModal();

    // Canvas 相关事件监听在 Canvas 模块中处理

    // 初始化书签树映射预览的交互
    initChangesTreePreview();

    // 搜索
    document.getElementById('searchInput').addEventListener('input', handleSearch);

    // 弹窗关闭
    document.getElementById('modalClose').addEventListener('click', closeModal);
    document.getElementById('detailModal').addEventListener('click', (e) => {
        if (e.target.id === 'detailModal') closeModal();
    });

    // 清空备份历史
    initClearBackupHistoryModal();

    // 注意：不再在这里调用 updateUIForCurrentView()，因为已经在 DOMContentLoaded 早期调用了 applyViewState()

    // 初始化备份历史详情模式切换按钮
    initHistoryDetailModeToggle();
    initDetailModalActions();

    console.log('[initializeUI] UI事件监听器初始化完成，当前视图:', currentView);
}

function clearBackupHistoryRecordsInBackground() {
    return new Promise((resolve) => {
        try {
            browserAPI.runtime.sendMessage({ action: "clearSyncHistory" }, (response) => {
                if (browserAPI.runtime.lastError) {
                    resolve({ success: false, error: browserAPI.runtime.lastError.message });
                    return;
                }
                resolve(response || { success: false, error: 'no response' });
            });
        } catch (error) {
            resolve({ success: false, error: error?.message || String(error) });
        }
    });
}

function initClearBackupHistoryModal() {
    const btn = document.getElementById('clearBackupHistoryBtn');
    const modal = document.getElementById('clearBackupHistoryModal');
    const closeBtn = document.getElementById('clearBackupHistoryModalClose');
    const cancelBtn = document.getElementById('clearBackupHistoryCancelBtn');
    const confirmBtn = document.getElementById('clearBackupHistoryConfirmBtn');

    // 二次确认弹窗
    const secondModal = document.getElementById('clearHistorySecondConfirmModal');
    const secondCloseBtn = document.getElementById('clearHistorySecondConfirmClose');
    const secondCancelBtn = document.getElementById('clearHistorySecondConfirmCancelBtn');
    const exportFirstBtn = document.getElementById('clearHistoryExportFirstBtn');
    const directDeleteBtn = document.getElementById('clearHistoryDirectDeleteBtn');
    const deleteCountDisplay = document.getElementById('clearHistoryDeleteCountDisplay');
    const rangeDisplay = document.getElementById('clearHistoryRangeDisplay');

    // 双滑块范围选择器
    const rangeMinSlider = document.getElementById('clearHistoryRangeMin');
    const rangeMaxSlider = document.getElementById('clearHistoryRangeMax');
    const rangeHighlight = document.getElementById('clearHistoryRangeHighlight');
    const minSeqLabel = document.getElementById('clearHistoryMinSeqLabel');
    const maxSeqLabel = document.getElementById('clearHistoryMaxSeqLabel');
    const selectionRange = document.getElementById('clearHistorySelectionRange');
    const selectionCount = document.getElementById('clearHistorySelectionCount');
    const selectionLabel = document.getElementById('clearHistorySelectionLabel');
    const previewTextEl = document.getElementById('clearHistoryPreviewText');

    if (!btn || !modal || !confirmBtn) return;

    // 存储当前要删除的范围
    let pendingDeleteMinSeq = 1;
    let pendingDeleteMaxSeq = 1;
    let pendingDeleteCount = 0;
    let clearHistoryActiveThumb = 'max'; // 'min' | 'max'

    // 获取记录的序号列表（按时间排序，最旧的在前）
    const getRecordSeqNumbers = () => {
        if (!syncHistory || syncHistory.length === 0) return [];
        return syncHistory.map((record, index) => {
            return record.seqNumber || (index + 1);
        });
    };

    // 获取序号范围
    const getSeqRange = () => {
        const seqNumbers = getRecordSeqNumbers();
        if (seqNumbers.length === 0) return { min: 1, max: 1 };
        return {
            min: Math.min(...seqNumbers),
            max: Math.max(...seqNumbers)
        };
    };

    // 更新滑块范围高亮
    const updateRangeHighlight = () => {
        if (!rangeHighlight || !rangeMinSlider || !rangeMaxSlider) return;

        const min = parseInt(rangeMinSlider.min, 10);
        const max = parseInt(rangeMinSlider.max, 10);
        const range = Math.max(1, max - min);

        const a = parseInt(rangeMinSlider.value, 10);
        const b = parseInt(rangeMaxSlider.value, 10);
        const low = Math.min(a, b);
        const high = Math.max(a, b);

        // Reverse logic: Max is on Left (0%), Min is on Right (100%)
        // Input logic (flipped by CSS scaleX(-1)):
        // Input Min (visual right) -> Input Max (visual left)
        // High Value should be at Left. Low Value should be at Right.
        // CSS transform: scaleX(-1) on inputs flips them so Left is Max.
        // So Highlight Logic:
        // Left Edge = Position of MaxVal. Right Edge = Position of MinVal.

        // Let's rely on standard logic but realizing the container is NOT flipped, only tracks/inputs.
        // Wait, if track is flipped, highlight inside it is also flipped.
        // So standard logic applies relative to the flipped coordinate system!
        // Min (1) -> 0% (Visual Right). Max (50) -> 50% (visual Mid).
        // Highlight: 0% to 50%.
        // So visual bar: Right Edge -> Mid. This covers 1 to 50. CORRECT.

        const leftPercent = ((low - min) / range) * 100;
        const widthPercent = ((high - low) / range) * 100;

        rangeHighlight.style.left = `${leftPercent}%`;
        rangeHighlight.style.width = `${widthPercent}%`;

        updateClearHistoryRangeBubbles();
    };

    const updateClearHistoryRangeBubbles = () => {
        const minBubble = document.getElementById('clearHistoryRangeMinBubble');
        const maxBubble = document.getElementById('clearHistoryRangeMaxBubble');
        const container = document.getElementById('clearHistoryRangeContainer');
        if (!rangeMinSlider || !rangeMaxSlider || !minBubble || !maxBubble || !container) return;

        const min = parseInt(rangeMinSlider.min, 10);
        const max = parseInt(rangeMinSlider.max, 10);
        const range = Math.max(1, max - min);

        const a = parseInt(rangeMinSlider.value, 10);
        const b = parseInt(rangeMaxSlider.value, 10);

        const aPercent = ((a - min) / range) * 100;
        const bPercent = ((b - min) / range) * 100;

        const insetPx = 10;
        const thumbSizePx = 20;
        const thumbHalfPx = thumbSizePx / 2;
        const trackWidthPx = Math.max(1, container.clientWidth - insetPx * 2);
        const effectiveWidthPx = Math.max(0, trackWidthPx - thumbSizePx);

        // Inputs are flipped (scaleX(-1)), so visual position is mirrored.
        const ax = insetPx + thumbHalfPx + (1 - (aPercent / 100)) * effectiveWidthPx;
        const bx = insetPx + thumbHalfPx + (1 - (bPercent / 100)) * effectiveWidthPx;

        minBubble.style.left = `${ax}px`;
        maxBubble.style.left = `${bx}px`;
        minBubble.textContent = String(a);
        maxBubble.textContent = String(b);

        const overlapThresholdPx = 14;
        const overlap = Math.abs(ax - bx) <= overlapThresholdPx;
        if (overlap) {
            if (clearHistoryActiveThumb === 'min') {
                minBubble.style.opacity = '1';
                minBubble.style.zIndex = '7';
                maxBubble.style.opacity = '0';
                maxBubble.style.zIndex = '6';
            } else {
                maxBubble.style.opacity = '1';
                maxBubble.style.zIndex = '7';
                minBubble.style.opacity = '0';
                minBubble.style.zIndex = '6';
            }
        } else {
            minBubble.style.opacity = '1';
            maxBubble.style.opacity = '1';
            minBubble.style.zIndex = '6';
            maxBubble.style.zIndex = '6';
        }
    };

    // 计算要删除的记录数量（根据序号范围）
    const calculateDeleteCount = () => {
        if (!rangeMinSlider || !rangeMaxSlider) return 0;

        const a = parseInt(rangeMinSlider.value, 10);
        const b = parseInt(rangeMaxSlider.value, 10);
        const minSeq = Math.min(a, b);
        const maxSeq = Math.max(a, b);

        // 统计在范围内的记录数
        const seqNumbers = getRecordSeqNumbers();
        let count = 0;
        for (const seq of seqNumbers) {
            if (seq >= minSeq && seq <= maxSeq) {
                count++;
            }
        }
        return count;
    };

    // 获取将要删除的序号范围字符串
    const getDeleteSeqRange = () => {
        if (!rangeMinSlider || !rangeMaxSlider) return '';
        const a = parseInt(rangeMinSlider.value, 10);
        const b = parseInt(rangeMaxSlider.value, 10);
        const minSeq = Math.min(a, b);
        const maxSeq = Math.max(a, b);
        if (minSeq === maxSeq) return String(minSeq);
        return `${minSeq}-${maxSeq}`;
    };

    // 更新显示
    const updateDisplay = () => {
        if (!rangeMinSlider || !rangeMaxSlider) return;

        const a = parseInt(rangeMinSlider.value, 10);
        const b = parseInt(rangeMaxSlider.value, 10);
        const minSeq = Math.min(a, b);
        const maxSeq = Math.max(a, b);
        const deleteCount = calculateDeleteCount();
        const total = syncHistory.length;

        // 隐藏原来的中间显示区域
        if (selectionRange && selectionRange.parentElement && selectionRange.parentElement.parentElement) {
            selectionRange.parentElement.parentElement.style.display = 'none';
        }

        // 更新预览文本 - 替换为用户要求的格式
        if (previewTextEl) {
            const seqRangeStr = minSeq === maxSeq ? String(minSeq) : `${minSeq}-${maxSeq}`;

            if (currentLang === 'en') {
                previewTextEl.textContent = `Will delete No. ${seqRangeStr} (${deleteCount} records)`;
            } else {
                // 用户要求的格式：「即将删除 2 条记录 (序号 4-5)」
                previewTextEl.textContent = `即将删除 ${deleteCount} 条记录 (序号 ${seqRangeStr})`;
            }
        }

        // 更新高亮
        updateRangeHighlight();
    };

    // 滑块事件处理 - 确保最小值不超过最大值
    const handleMinChange = () => {
        if (!rangeMinSlider || !rangeMaxSlider) return;
        clearHistoryActiveThumb = 'min';
        updateDisplay();
    };

    const handleMaxChange = () => {
        if (!rangeMinSlider || !rangeMaxSlider) return;
        clearHistoryActiveThumb = 'max';
        updateDisplay();
    };

    const openClearModal = () => {
        const seqRange = getSeqRange();
        const total = syncHistory.length;

        // 设置滑块范围
        if (rangeMinSlider) {
            rangeMinSlider.min = seqRange.min;
            rangeMinSlider.max = seqRange.max;
            rangeMinSlider.value = seqRange.min; // 起始从最小序号开始
        }
        if (rangeMaxSlider) {
            rangeMaxSlider.min = seqRange.min;
            rangeMaxSlider.max = seqRange.max;
            // 默认选中约50%的最旧记录
            const defaultMaxSeq = seqRange.min + Math.floor((seqRange.max - seqRange.min) / 2);
            rangeMaxSlider.value = Math.max(seqRange.min, defaultMaxSeq);
        }

        // 设置刻度标签 - Largest on Left
        if (minSeqLabel) minSeqLabel.textContent = String(seqRange.max); // Left Label = Max
        if (maxSeqLabel) maxSeqLabel.textContent = String(seqRange.min); // Right Label = Min

        modal.classList.add('show');
        // Must update after the modal is visible; otherwise container width can be 0 and bubbles won't render.
        requestAnimationFrame(() => {
            try {
                updateDisplay();
            } catch (e) {
                // ignore
            }
            requestAnimationFrame(() => {
                try {
                    updateDisplay();
                } catch (e) {
                    // ignore
                }
            });
        });
    };

    const closeClearModal = () => modal.classList.remove('show');

    const openSecondConfirmModal = () => {
        if (!rangeMinSlider || !rangeMaxSlider) return;

        const a = parseInt(rangeMinSlider.value, 10);
        const b = parseInt(rangeMaxSlider.value, 10);
        pendingDeleteMinSeq = Math.min(a, b);
        pendingDeleteMaxSeq = Math.max(a, b);
        pendingDeleteCount = calculateDeleteCount();

        if (deleteCountDisplay) {
            deleteCountDisplay.textContent = pendingDeleteCount;
        }
        if (rangeDisplay) {
            const seqRangeStr = pendingDeleteMinSeq === pendingDeleteMaxSeq
                ? String(pendingDeleteMinSeq)
                : `${pendingDeleteMinSeq}-${pendingDeleteMaxSeq}`;

            rangeDisplay.textContent = currentLang === 'en'
                ? `(No. ${seqRangeStr})`
                : `(序号 ${seqRangeStr})`;
        }
        if (secondModal) {
            secondModal.classList.add('show');
        }
    };

    const closeSecondConfirmModal = () => {
        if (secondModal) {
            secondModal.classList.remove('show');
        }
    };

    // 执行实际删除
    const executeDelete = async () => {
        if (pendingDeleteCount <= 0) {
            closeSecondConfirmModal();
            closeClearModal();
            return;
        }

        if (directDeleteBtn) directDeleteBtn.disabled = true;
        try {
            // 按序号范围删除（支持删除最新/中间/最旧；不重排其它记录的永久序号）
            const timesToDelete = [];
            const fingerprintsToDelete = [];
            for (let i = 0; i < syncHistory.length; i++) {
                const record = syncHistory[i];
                const seq = record.seqNumber || (i + 1);
                if (seq >= pendingDeleteMinSeq && seq <= pendingDeleteMaxSeq) {
                    if (record.fingerprint) fingerprintsToDelete.push(record.fingerprint);
                    else timesToDelete.push(record.time);
                }
            }

            const resp = await deleteBackupHistoryItems({ fingerprintsToDelete, timesToDelete });
            closeSecondConfirmModal();
            closeClearModal();

            if (resp && resp.success) {
                const deletedCount = resp.deleted || pendingDeleteCount;

                // 从 storage 重新获取数据以确保一致性
                try {
                    const data = await new Promise(resolve => {
                        browserAPI.storage.local.get(['syncHistory'], result => {
                            resolve(result);
                        });
                    });
                    syncHistory = data.syncHistory || [];
                } catch (e) {
                    console.warn('[executeDelete] Failed to reload syncHistory');
                    syncHistory = syncHistory.slice(deletedCount);
                }

                try {
                    renderHistoryView();
                } catch (e) {
                    console.warn('[executeDelete] renderHistoryView failed:', e);
                }

                const successTextFunc = i18n.clearBackupHistorySuccess[currentLang];
                const successMsg = typeof successTextFunc === 'function'
                    ? successTextFunc(deletedCount)
                    : `已删除 ${deletedCount} 条历史记录`;
                showToast(successMsg);
            } else {
                console.error('[executeDelete] Delete failed:', resp);
                showToast(i18n.clearBackupHistoryFailed[currentLang]);
            }
        } finally {
            if (directDeleteBtn) directDeleteBtn.disabled = false;
        }
    };

    const deleteBackupHistoryItems = ({ fingerprintsToDelete, timesToDelete }) => {
        const fp = Array.isArray(fingerprintsToDelete) ? fingerprintsToDelete : [];
        const ts = Array.isArray(timesToDelete) ? timesToDelete : [];
        return new Promise((resolve) => {
            try {
                if (fp.length > 0) {
                    browserAPI.runtime.sendMessage({ action: 'deleteSyncHistoryItems', fingerprints: fp }, (response) => {
                        if (browserAPI.runtime.lastError) {
                            resolve({ success: false, error: browserAPI.runtime.lastError.message });
                            return;
                        }
                        resolve(response || { success: true, deleted: fp.length });
                    });
                    return;
                }

                if (ts.length > 0) {
                    browserAPI.runtime.sendMessage({ action: 'deleteSyncHistoryItemsByTime', times: ts }, (response) => {
                        if (browserAPI.runtime.lastError) {
                            resolve({ success: false, error: browserAPI.runtime.lastError.message });
                            return;
                        }
                        resolve(response || { success: true, deleted: ts.length });
                    });
                    return;
                }

                resolve({ success: true, deleted: 0 });
            } catch (e) {
                resolve({ success: false, error: e?.message || String(e) });
            }
        });
    };

    // 事件绑定 - 主弹窗
    if (!btn.hasAttribute('data-listener-attached')) {
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            openClearModal();
        });
        btn.setAttribute('data-listener-attached', 'true');
    }

    if (closeBtn && !closeBtn.hasAttribute('data-listener-attached')) {
        closeBtn.addEventListener('click', closeClearModal);
        closeBtn.setAttribute('data-listener-attached', 'true');
    }

    if (cancelBtn && !cancelBtn.hasAttribute('data-listener-attached')) {
        cancelBtn.addEventListener('click', closeClearModal);
        cancelBtn.setAttribute('data-listener-attached', 'true');
    }

    if (!modal.hasAttribute('data-listener-attached')) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeClearModal();
        });
        modal.setAttribute('data-listener-attached', 'true');
    }

    // 双滑块事件
    if (rangeMinSlider && !rangeMinSlider.hasAttribute('data-listener-attached')) {
        rangeMinSlider.addEventListener('input', handleMinChange);
        rangeMinSlider.addEventListener('pointerdown', () => {
            clearHistoryActiveThumb = 'min';
            rangeMinSlider.style.zIndex = '5';
            rangeMaxSlider.style.zIndex = '4';
        });
        rangeMinSlider.setAttribute('data-listener-attached', 'true');
    }
    if (rangeMaxSlider && !rangeMaxSlider.hasAttribute('data-listener-attached')) {
        rangeMaxSlider.addEventListener('input', handleMaxChange);
        rangeMaxSlider.addEventListener('pointerdown', () => {
            clearHistoryActiveThumb = 'max';
            rangeMaxSlider.style.zIndex = '5';
            rangeMinSlider.style.zIndex = '4';
        });
        rangeMaxSlider.setAttribute('data-listener-attached', 'true');
    }

    // 确认删除按钮 - 打开二次确认弹窗
    if (!confirmBtn.hasAttribute('data-listener-attached')) {
        confirmBtn.addEventListener('click', () => {
            const toDelete = calculateDeleteCount();
            if (toDelete <= 0) {
                closeClearModal();
                return;
            }
            // 打开二次确认弹窗（不需要传参，函数会直接读取滑块值）
            openSecondConfirmModal();
        });
        confirmBtn.setAttribute('data-listener-attached', 'true');
    }

    // 事件绑定 - 二次确认弹窗
    if (secondCloseBtn && !secondCloseBtn.hasAttribute('data-listener-attached')) {
        secondCloseBtn.addEventListener('click', closeSecondConfirmModal);
        secondCloseBtn.setAttribute('data-listener-attached', 'true');
    }

    if (secondCancelBtn && !secondCancelBtn.hasAttribute('data-listener-attached')) {
        secondCancelBtn.addEventListener('click', closeSecondConfirmModal);
        secondCancelBtn.setAttribute('data-listener-attached', 'true');
    }

    if (secondModal && !secondModal.hasAttribute('data-listener-attached')) {
        secondModal.addEventListener('click', (e) => {
            if (e.target === secondModal) closeSecondConfirmModal();
        });
        secondModal.setAttribute('data-listener-attached', 'true');
    }

    // "先备份"按钮 - 跳转到全局导出
    if (exportFirstBtn && !exportFirstBtn.hasAttribute('data-listener-attached')) {
        exportFirstBtn.addEventListener('click', () => {
            closeSecondConfirmModal();
            closeClearModal();

            // 延迟打开全局导出弹窗，并预选要删除的记录（根据序号范围）
            setTimeout(() => {
                showGlobalExportModalWithPreselectionBySeqRange(pendingDeleteMinSeq, pendingDeleteMaxSeq);
            }, 100);
        });
        exportFirstBtn.setAttribute('data-listener-attached', 'true');
    }

    // "直接删除"按钮
    if (directDeleteBtn && !directDeleteBtn.hasAttribute('data-listener-attached')) {
        directDeleteBtn.addEventListener('click', executeDelete);
        directDeleteBtn.setAttribute('data-listener-attached', 'true');
    }
}

// 部分删除备份历史记录
function clearBackupHistoryPartial(deleteCount) {
    return new Promise((resolve) => {
        try {
            console.log('[clearBackupHistoryPartial] Sending request to delete', deleteCount, 'records');

            // 确保 deleteCount 是数字
            const count = parseInt(deleteCount, 10);
            if (isNaN(count) || count <= 0) {
                console.warn('[clearBackupHistoryPartial] Invalid deleteCount:', deleteCount);
                resolve({ success: true, deleted: 0 });
                return;
            }

            browserAPI.runtime.sendMessage({
                action: "clearSyncHistoryPartial",
                deleteCount: count
            }, (response) => {
                if (browserAPI.runtime.lastError) {
                    console.error('[clearBackupHistoryPartial] Runtime error:', browserAPI.runtime.lastError);
                    resolve({ success: false, error: browserAPI.runtime.lastError.message });
                    return;
                }

                console.log('[clearBackupHistoryPartial] Response:', response);

                if (!response) {
                    console.warn('[clearBackupHistoryPartial] No response received');
                    resolve({ success: false, error: 'no response' });
                    return;
                }

                resolve(response);
            });
        } catch (error) {
            console.error('[clearBackupHistoryPartial] Exception:', error);
            resolve({ success: false, error: error?.message || String(error) });
        }
    });
}

// 显示全局导出弹窗并预选指定数量的最旧记录
function showGlobalExportModalWithPreselection(preselectCount = 0) {
    const modal = document.getElementById('globalExportModal');
    const tbody = document.getElementById('globalExportTableBody');

    if (!modal || !tbody) return;

    // 重置分页状态
    globalExportCurrentPage = 1;
    globalExportSelectedState = {};

    if (!syncHistory || syncHistory.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="padding: 30px; text-align: center; color: var(--text-tertiary);">暂无备份记录</td></tr>';
        document.getElementById('globalExportPagination').style.display = 'none';
        modal.classList.add('show');
        return;
    }

    // 预选最旧的 preselectCount 条记录
    syncHistory.forEach((record, index) => {
        // 索引 0 是最旧的记录
        globalExportSelectedState[record.time] = (index < preselectCount);
    });

    globalExportSeqNumberByTime = new Map();
    syncHistory.forEach((record, index) => {
        const seqNumber = record.seqNumber || (index + 1);
        globalExportSeqNumberByTime.set(String(record.time), seqNumber);
    });

    // 显示分页控件
    document.getElementById('globalExportPagination').style.display = 'flex';

    // 渲染当前页
    renderGlobalExportPage();

    updateGlobalExportStatus();

    modal.classList.add('show');
}

// 显示全局导出弹窗并根据序号范围预选记录
function showGlobalExportModalWithPreselectionBySeqRange(minSeq, maxSeq) {
    const modal = document.getElementById('globalExportModal');
    const tbody = document.getElementById('globalExportTableBody');

    if (!modal || !tbody) return;

    // 重置分页状态
    globalExportCurrentPage = 1;
    globalExportSelectedState = {};

    if (!syncHistory || syncHistory.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="padding: 30px; text-align: center; color: var(--text-tertiary);">暂无备份记录</td></tr>';
        document.getElementById('globalExportPagination').style.display = 'none';
        modal.classList.add('show');
        return;
    }

    // 根据序号范围预选记录
    syncHistory.forEach((record, index) => {
        const seqNumber = record.seqNumber || (index + 1);
        globalExportSelectedState[record.time] = (seqNumber >= minSeq && seqNumber <= maxSeq);
    });

    globalExportSeqNumberByTime = new Map();
    syncHistory.forEach((record, index) => {
        const seqNumber = record.seqNumber || (index + 1);
        globalExportSeqNumberByTime.set(String(record.time), seqNumber);
    });

    // 显示分页控件
    document.getElementById('globalExportPagination').style.display = 'flex';

    setupGlobalExportRangeUiForOpen({ source: 'delete', minSeq, maxSeq, autoEnable: true, autoExpand: true });

    // 渲染当前页
    renderGlobalExportPage();

    // 更新选中状态
    updateGlobalExportStatus();

    modal.classList.add('show');
}

// 用于防止Revert结果显示多次的标志
let revertInProgress = false;
let lastRevertMessageHandler = null;
let revertOverlayTimeout = null;

// 确认并触发撤销全部（移除第二次确认）
async function handleRevertAll(source) {
    try {
        // 只保留一次确认
        const confirmed = confirm(`${i18n.revertConfirmTitle[currentLang]}\n\n${i18n.revertConfirmDesc[currentLang]}`);
        if (!confirmed) return;

        // 防止多次触发
        if (revertInProgress) {
            console.warn('[handleRevertAll] Revert已在进行中，忽略本次请求');
            return;
        }
        revertInProgress = true;

        // 显示全屏覆盖层（隐藏下面的所有刷新过程）
        showRevertOverlay();

        // 发送消息到后台
        browserAPI.runtime.sendMessage({
            action: 'revertAllToLastBackup',
            fromHistoryViewer: true
        }, (response) => {
            if (revertInProgress && response) {
                const isSuccess = response && response.success;
                const message = isSuccess
                    ? i18n.revertSuccess[currentLang]
                    : (i18n.revertFailed[currentLang] + (response && response.error ? response.error : 'Unknown error'));

                // 设置超时处理完成
                if (revertOverlayTimeout) clearTimeout(revertOverlayTimeout);
                revertOverlayTimeout = setTimeout(async () => {
                    // 隐藏覆盖层
                    hideRevertOverlay();
                    revertInProgress = false;
                    revertOverlayTimeout = null;

                    // 显示最终结果提示
                    showRevertToast(isSuccess, message);

                    // 如果成功，一次性刷新当前视图
                    if (isSuccess) {
                        console.log('[handleRevertAll] 撤销成功，进行一次性刷新');
                        try {
                            await loadAllData({ skipRender: true });
                            if (currentView === 'current-changes') {
                                await renderCurrentChangesViewWithRetry(1, true);
                            } else if (currentView === 'tree') {
                                await renderTreeView(true);
                            } else if (currentView === 'history') {
                                await renderHistoryView();
                            } else if (currentView === 'additions') {
                                await renderAdditionsView();
                            }
                            // 撤销完成后，清理永久栏目及 Current Changes 预览中的颜色标识
                            try {
                                resetPermanentSectionChangeMarkers();
                            } catch (cleanupError) {
                                console.warn('[handleRevertAll] 清理栏目标识时出错:', cleanupError);
                            }
                        } catch (e) {
                            console.error('[handleRevertAll] 刷新异常:', e);
                        }
                    }
                }, 400); // 极速响应 400ms
            }
        });

        console.log('[handleRevertAll] 已发送revert请求');

    } catch (error) {
        revertInProgress = false;
        hideRevertOverlay();
        showRevertToast(false, error && error.message ? error.message : String(error));
    }
}

// 显示撤销覆盖层
function showRevertOverlay() {
    const overlay = document.getElementById('revertOverlay');
    const mainContainer = document.querySelector('.main-container');

    if (overlay) {
        overlay.style.display = 'flex';
        const text = document.getElementById('revertOverlayText');
        if (text) {
            text.textContent = currentLang === 'zh_CN' ? '正在处理中...' : 'Processing...';
        }
    }

    // 隐藏主内容区域，防止任何闪烁
    if (mainContainer) {
        mainContainer.style.opacity = '0';
        mainContainer.style.pointerEvents = 'none';
    }
}

// 隐藏撤销覆盖层
function hideRevertOverlay() {
    const overlay = document.getElementById('revertOverlay');
    const mainContainer = document.querySelector('.main-container');

    if (overlay) {
        overlay.style.display = 'none';
    }

    // 恢复主内容区域
    if (mainContainer) {
        mainContainer.style.opacity = '1';
        mainContainer.style.pointerEvents = 'auto';
    }
}

// 显示Revert的提示（单一提示，成功绿色，失败红色）
function showRevertToast(isSuccess, message) {
    // 移除之前的提示（只保留一个）
    const existingToast = document.querySelector('.revert-toast');
    if (existingToast) {
        existingToast.remove();
    }

    // 创建新的提示
    const toast = document.createElement('div');
    toast.className = 'revert-toast';
    toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 10000;
        animation: slideUp 0.3s ease;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        max-width: 300px;
        word-break: break-word;
        display: flex;
        align-items: center;
        gap: 8px;
    `;

    if (isSuccess) {
        toast.style.backgroundColor = '#d4edda';
        toast.style.color = '#155724';
        toast.style.border = '1px solid #c3e6cb';
        toast.innerHTML = `<i class="fas fa-check-circle" style="color: #28a745;"></i><span>${message}</span>`;
    } else {
        toast.style.backgroundColor = '#f8d7da';
        toast.style.color = '#721c24';
        toast.style.border = '1px solid #f5c6cb';
        toast.innerHTML = `<i class="fas fa-exclamation-circle" style="color: #dc3545;"></i><span>${message}</span>`;
    }

    document.body.appendChild(toast);

    // 3秒后自动移除
    setTimeout(() => {
        toast.style.animation = 'slideDown 0.3s ease';
        setTimeout(() => {
            if (toast.parentNode) {
                toast.remove();
            }
        }, 300);
    }, 3000);
}

// =============================================================================
// 数据加载
// =============================================================================

async function loadAllData(options = {}) {
    const { skipRender = false } = options;
    console.log('[loadAllData] 开始加载所有数据...');

    try {
        await ensureAdditionsCacheLoaded(skipRender);

        // 并行加载所有数据
        const [storageData, bookmarkTree] = await Promise.all([
            loadStorageData(),
            loadBookmarkTree()
        ]);

        syncHistory = storageData.syncHistory || [];
        syncHistory = await ensureSyncHistorySeqNumbersPersisted(syncHistory);

        // 注意：不再清理 bookmarkTree，保留所有记录的详细数据
        // 用户存储空间无限制
        console.log('[loadAllData] 保留所有历史记录的详细数据');

        // 将 ISO 字符串格式转换为时间戳（毫秒）
        lastBackupTime = storageData.lastSyncTime ? new Date(storageData.lastSyncTime).getTime() : null;
        allBookmarks = flattenBookmarkTree(bookmarkTree);
        rebuildBookmarkUrlSet();
        additionsCacheRestored = true;
        await persistAdditionsCache();
        cachedBookmarkTree = bookmarkTree;

        console.log('[loadAllData] 数据加载完成:', {
            历史记录数: syncHistory.length,
            书签总数: allBookmarks.length
        });

        // 如果当前正在查看 current-changes，重新渲染（使用带重试+去抖的版本）
        if (currentView === 'current-changes' && !skipRender) {
            console.log('[loadAllData] 刷新当前变化视图');
            renderCurrentChangesViewWithRetry(1, false);
        }

    } catch (error) {
        console.error('[loadAllData] 加载数据失败:', error);
        showError('加载数据失败');
    }
}

async function ensureSyncHistorySeqNumbersPersisted(historyRecords) {
    const records = Array.isArray(historyRecords) ? historyRecords.slice() : [];
    if (records.length === 0) return records;

    const hasAnyMissing = records.some(r => !(Number.isFinite(Number(r?.seqNumber)) && Number(r?.seqNumber) > 0));
    if (!hasAnyMissing) return records;

    // One-time migration: assign missing seqNumber in time-ascending order without changing existing ones.
    const sorted = records.slice().sort((a, b) => Number(a?.time || 0) - Number(b?.time || 0));
    const used = new Set();
    for (const r of sorted) {
        const seq = Number(r?.seqNumber);
        if (Number.isFinite(seq) && seq > 0) used.add(seq);
    }

    let next = 1;
    const updatedByTime = new Map();
    for (const r of sorted) {
        const copy = { ...r };
        let seq = Number(copy.seqNumber);
        if (!(Number.isFinite(seq) && seq > 0)) {
            while (used.has(next)) next++;
            seq = next;
            used.add(seq);
            next++;
        }
        copy.seqNumber = seq;
        updatedByTime.set(String(copy.time), copy);
    }

    const updated = records.map(r => updatedByTime.get(String(r.time)) || r);

    try {
        await new Promise((resolve) => {
            browserAPI.storage.local.set({ syncHistory: updated }, resolve);
        });
        console.log('[ensureSyncHistorySeqNumbersPersisted] Migrated seqNumber for syncHistory records');
    } catch (e) {
        console.warn('[ensureSyncHistorySeqNumbersPersisted] Failed to persist seqNumber migration:', e);
    }

    return updated;
}

// 预加载所有视图的数据
async function preloadAllViews() {
    if (isPreloading) return;
    isPreloading = true;

    console.log('[预加载] 开始预加载所有视图...');

    try {
        // 预加载书签树（后台准备）
        if (!cachedBookmarkTree) {
            cachedBookmarkTree = await loadBookmarkTree();
            console.log('[预加载] 书签树已缓存');
        }

        // 预加载当前变化数据（后台准备）
        if (!cachedCurrentChanges) {
            cachedCurrentChanges = await getDetailedChanges();
            console.log('[预加载] 当前变化数据已缓存');
        }

        console.log('[预加载] 所有视图数据预加载完成');
    } catch (error) {
        console.error('[预加载] 预加载失败:', error);
    } finally {
        isPreloading = false;
    }
}

// 预加载常见网站的图标
async function preloadCommonIcons() {
    console.log('[图标预加载] 开始预加载常见图标...');

    try {
        // 获取当前所有书签的 URL，过滤掉无效的
        const urls = allBookmarks
            .map(b => b.url)
            .filter(url => url && url.trim() && (url.startsWith('http://') || url.startsWith('https://')));

        if (urls.length === 0) {
            console.log('[图标预加载] 没有有效的 URL 需要预加载');
            return;
        }

        // 批量预加载（限制并发数）
        const batchSize = 10;
        const maxPreload = Math.min(urls.length, 50);

        for (let i = 0; i < maxPreload; i += batchSize) {
            const batch = urls.slice(i, i + batchSize);
            await Promise.all(batch.map(url => preloadIcon(url)));
        }

        console.log('[图标预加载] 完成，已预加载', maxPreload, '个图标');
    } catch (error) {
        console.error('[图标预加载] 失败:', error);
    }
}

// 预加载单个图标（使用新的缓存系统）
async function preloadIcon(url) {
    try {
        // 基本验证
        if (!url || FaviconCache.isInvalidUrl(url)) {
            return;
        }

        // 使用缓存系统获取favicon（会自动缓存）
        await FaviconCache.fetch(url);
    } catch (error) {
        console.warn('[图标预加载] URL 预加载失败:', url, error.message);
    }
}

// 【关键修复】预热 favicon 内存缓存（从 IndexedDB 批量加载）
// 用于解决切换视图时图标变成五角星的问题
async function warmupFaviconCache(bookmarkUrls) {
    if (!bookmarkUrls || bookmarkUrls.length === 0) return;

    try {
        console.log('[Favicon预热] 开始预热内存缓存，书签数量:', bookmarkUrls.length);

        // 初始化 IndexedDB（如果还没初始化）
        if (!FaviconCache.db) {
            await FaviconCache.init();
        }

        // 批量从 IndexedDB 读取所有域名的 favicon
        const domains = new Set();
        bookmarkUrls.forEach(url => {
            try {
                if (!FaviconCache.isInvalidUrl(url)) {
                    const domain = new URL(url).hostname;
                    domains.add(domain);
                }
            } catch (e) {
                // 忽略无效URL
            }
        });

        if (domains.size === 0) return;

        console.log('[Favicon预热] 需要预热的域名数:', domains.size);

        // 批量读取
        const transaction = FaviconCache.db.transaction([FaviconCache.storeName], 'readonly');
        const store = transaction.objectStore(FaviconCache.storeName);

        let loaded = 0;
        for (const domain of domains) {
            // 跳过已在内存缓存中的
            if (FaviconCache.memoryCache.has(domain)) continue;

            try {
                const request = store.get(domain);
                await new Promise((resolve) => {
                    request.onsuccess = () => {
                        if (request.result && request.result.dataUrl) {
                            FaviconCache.memoryCache.set(domain, request.result.dataUrl);
                            loaded++;
                        }
                        resolve();
                    };
                    request.onerror = () => resolve();
                });
            } catch (e) {
                // 忽略单个域名的错误
            }
        }

        console.log('[Favicon预热] 完成，从IndexedDB加载了', loaded, '个favicon到内存');
    } catch (error) {
        console.warn('[Favicon预热] 失败:', error);
    }
}

function loadStorageData() {
    return new Promise((resolve) => {
        browserAPI.storage.local.get(['syncHistory', 'lastSyncTime'], (data) => {
            resolve(data);
        });
    });
}

function loadBookmarkTree() {
    return new Promise((resolve) => {
        browserAPI.bookmarks.getTree((tree) => {
            resolve(tree[0]);
        });
    });
}

function flattenBookmarkTree(node, parentPath = '') {
    const bookmarks = [];
    const currentPath = parentPath ? `${parentPath}/${node.title}` : node.title;

    if (node.url) {
        bookmarks.push({
            id: node.id,
            title: node.title,
            url: node.url,
            dateAdded: node.dateAdded,
            path: currentPath,
            parentId: node.parentId
        });
    }

    if (node.children) {
        node.children.forEach(child => {
            bookmarks.push(...flattenBookmarkTree(child, currentPath));
        });
    }

    return bookmarks;
}

// =============================================================================
// 差异计算辅助函数（与主 UI 一致）
// =============================================================================

function getFirstValidNumber(...values) {
    for (const value of values) {
        if (typeof value === 'number' && !Number.isNaN(value)) {
            return value;
        }
    }
    return 0;
}

function extractCountsFromStatsSource(statsSource) {
    if (!statsSource) {
        return { bookmarks: 0, folders: 0 };
    }
    return {
        bookmarks: getFirstValidNumber(
            statsSource.bookmarkCount,
            statsSource.currentBookmarkCount,
            statsSource.currentBookmarks
        ),
        folders: getFirstValidNumber(
            statsSource.folderCount,
            statsSource.currentFolderCount,
            statsSource.currentFolders
        )
    };
}

function extractCountsFromHistoryRecord(record) {
    if (!record || !record.bookmarkStats) return null;
    const counts = extractCountsFromStatsSource(record.bookmarkStats);
    if (counts && (counts.bookmarks || counts.folders || counts.bookmarks === 0 || counts.folders === 0)) {
        return counts;
    }
    return null;
}

function findLatestRecordCounts(syncHistory) {
    if (!Array.isArray(syncHistory) || syncHistory.length === 0) {
        return null;
    }
    for (let i = syncHistory.length - 1; i >= 0; i--) {
        const counts = extractCountsFromHistoryRecord(syncHistory[i]);
        if (counts) {
            return counts;
        }
    }
    return null;
}

function calculateBookmarkFolderDiffs(currentStats, syncHistory, cachedRecord) {
    const currentCounts = extractCountsFromStatsSource(currentStats);
    let previousCounts = findLatestRecordCounts(syncHistory);
    let diffSource = 'history';

    if (!previousCounts && cachedRecord) {
        previousCounts = extractCountsFromHistoryRecord(cachedRecord);
        diffSource = 'cachedRecord';
    }

    let bookmarkDiff = 0;
    let folderDiff = 0;
    let canCalculateDiff = false;

    if (previousCounts) {
        bookmarkDiff = currentCounts.bookmarks - previousCounts.bookmarks;
        folderDiff = currentCounts.folders - previousCounts.folders;
        canCalculateDiff = true;
    }

    if (!canCalculateDiff) {
        const fallbackBookmarkDiff = currentStats && typeof currentStats.bookmarkDiff === 'number' ? currentStats.bookmarkDiff : 0;
        const fallbackFolderDiff = currentStats && typeof currentStats.folderDiff === 'number' ? currentStats.folderDiff : 0;
        bookmarkDiff = fallbackBookmarkDiff;
        folderDiff = fallbackFolderDiff;
        diffSource = 'statsFallback';
        canCalculateDiff = typeof fallbackBookmarkDiff === 'number' || typeof fallbackFolderDiff === 'number';
    }

    const hasNumericalChange = canCalculateDiff && (bookmarkDiff !== 0 || folderDiff !== 0);

    return {
        bookmarkDiff,
        folderDiff,
        canCalculateDiff,
        diffSource,
        currentBookmarkCount: currentCounts.bookmarks,
        currentFolderCount: currentCounts.folders,
        hasNumericalChange
    };
}

function buildChangeSummary(diffMeta, stats, lang) {
    const effectiveLang = lang === 'en' ? 'en' : 'zh_CN';
    const summary = {
        hasQuantityChange: false,
        quantityTotalLine: '',
        quantityDiffLine: '',
        hasStructuralChange: false,
        structuralLine: '',
        structuralItems: []
    };

    if (!diffMeta) {
        diffMeta = {
            bookmarkDiff: 0,
            folderDiff: 0,
            hasNumericalChange: false,
            currentBookmarkCount: 0,
            currentFolderCount: 0
        };
    }

    const bookmarkDiff = diffMeta.bookmarkDiff || 0;
    const folderDiff = diffMeta.folderDiff || 0;
    const hasNumericalChange = diffMeta.hasNumericalChange === true;
    const currentBookmarks = diffMeta.currentBookmarkCount ?? 0;
    const currentFolders = diffMeta.currentFolderCount ?? 0;

    // 新口径：若 background 提供了新增/删除分开计数，则优先用它（支持“加减相同数量但内容不同”）
    const bookmarkAdded = typeof stats?.bookmarkAdded === 'number' ? stats.bookmarkAdded : null;
    const bookmarkDeleted = typeof stats?.bookmarkDeleted === 'number' ? stats.bookmarkDeleted : null;
    const folderAdded = typeof stats?.folderAdded === 'number' ? stats.folderAdded : null;
    const folderDeleted = typeof stats?.folderDeleted === 'number' ? stats.folderDeleted : null;
    const hasDetailedQuantity = (bookmarkAdded !== null) || (bookmarkDeleted !== null) || (folderAdded !== null) || (folderDeleted !== null);
    const hasQuantityChange = hasDetailedQuantity
        ? ((bookmarkAdded || 0) > 0 || (bookmarkDeleted || 0) > 0 || (folderAdded || 0) > 0 || (folderDeleted || 0) > 0)
        : hasNumericalChange;

    const i18nBookmarksLabel = window.i18nLabels?.bookmarksLabel || (effectiveLang === 'en' ? 'bookmarks' : '个书签');
    const i18nFoldersLabel = window.i18nLabels?.foldersLabel || (effectiveLang === 'en' ? 'folders' : '个文件夹');
    const totalBookmarkTerm = effectiveLang === 'en' ? 'BKM' : i18nBookmarksLabel;
    const totalFolderTerm = effectiveLang === 'en' ? 'FLD' : i18nFoldersLabel;

    summary.quantityTotalLine = effectiveLang === 'en'
        ? `${currentBookmarks} ${totalBookmarkTerm}, ${currentFolders} ${totalFolderTerm}`
        : `${currentBookmarks}${totalBookmarkTerm}，${currentFolders}${totalFolderTerm}`;

    if (hasQuantityChange) {
        summary.hasQuantityChange = true;
        const parts = [];

        if (hasDetailedQuantity) {
            const joinDelta = (deltaParts) => {
                const sep = '<span style="display:inline-block;width:3px;"></span>/<span style="display:inline-block;width:3px;"></span>';
                return deltaParts.join(sep);
            };

            const buildDual = (added, deleted, label) => {
                const deltaParts = [];
                if (added > 0) deltaParts.push(`<span style="color:var(--positive-color, #4CAF50);font-weight:bold;">+${added}</span>`);
                if (deleted > 0) deltaParts.push(`<span style="color:var(--negative-color, #F44336);font-weight:bold;">-${deleted}</span>`);
                if (deltaParts.length === 0) return '';
                const numbersHTML = joinDelta(deltaParts);
                return effectiveLang === 'en' ? `${numbersHTML} ${label}` : `${numbersHTML}${label}`;
            };

            const bookmarkLabel = effectiveLang === 'en' ? 'BKM' : '书签';
            const folderLabel = effectiveLang === 'en' ? 'FLD' : '文件夹';

            const bPart = buildDual(bookmarkAdded || 0, bookmarkDeleted || 0, bookmarkLabel);
            const fPart = buildDual(folderAdded || 0, folderDeleted || 0, folderLabel);

            if (bPart) parts.push(bPart);
            if (fPart) parts.push(fPart);
        } else {
            if (bookmarkDiff !== 0) {
                const sign = bookmarkDiff > 0 ? '+' : '';
                const color = bookmarkDiff > 0 ? 'var(--positive-color, #4CAF50)' : 'var(--negative-color, #F44336)';
                const label = effectiveLang === 'en' ? 'BKM' : '书签';
                parts.push(`<span style="color:${color};font-weight:bold;">${sign}${bookmarkDiff}</span>${effectiveLang === 'en' ? ` ${label}` : label}`);
            }

            if (folderDiff !== 0) {
                const sign = folderDiff > 0 ? '+' : '';
                const color = folderDiff > 0 ? 'var(--positive-color, #4CAF50)' : 'var(--negative-color, #F44336)';
                const label = effectiveLang === 'en' ? 'FLD' : '文件夹';
                parts.push(`<span style="color:${color};font-weight:bold;">${sign}${folderDiff}</span>${effectiveLang === 'en' ? ` ${label}` : label}`);
            }
        }

        summary.quantityDiffLine = parts.join(effectiveLang === 'en' ? ` <span style="color:var(--text-tertiary);">|</span> ` : '、');
    }

    const bookmarkMoved = Boolean(stats?.bookmarkMoved);
    const folderMoved = Boolean(stats?.folderMoved);
    const bookmarkModified = Boolean(stats?.bookmarkModified);
    const folderModified = Boolean(stats?.folderModified);

    const hasBookmarkStructural = bookmarkMoved || bookmarkModified;
    const hasFolderStructural = folderMoved || folderModified;

    if (hasBookmarkStructural || hasFolderStructural) {
        summary.hasStructuralChange = true;

        // 构建具体的结构变化列表
        const structuralParts = [];
        const movedCount = typeof stats?.movedCount === 'number'
            ? stats.movedCount
            : (typeof stats?.movedBookmarkCount === 'number' ? stats.movedBookmarkCount : 0) + (typeof stats?.movedFolderCount === 'number' ? stats.movedFolderCount : 0);
        const modifiedCount = typeof stats?.modifiedCount === 'number'
            ? stats.modifiedCount
            : (typeof stats?.modifiedBookmarkCount === 'number' ? stats.modifiedBookmarkCount : 0) + (typeof stats?.modifiedFolderCount === 'number' ? stats.modifiedFolderCount : 0);

        if (bookmarkMoved || folderMoved) {
            const movedLabel = effectiveLang === 'en' ? (movedCount > 0 ? `${movedCount} moved` : 'Moved') : (movedCount > 0 ? `${movedCount}个移动` : '移动');
            structuralParts.push(movedLabel);
            summary.structuralItems.push(movedLabel);
        }
        if (bookmarkModified || folderModified) {
            const modifiedLabel = effectiveLang === 'en' ? (modifiedCount > 0 ? `${modifiedCount} modified` : 'Modified') : (modifiedCount > 0 ? `${modifiedCount}个修改` : '修改');
            structuralParts.push(modifiedLabel);
            summary.structuralItems.push(modifiedLabel);
        }


        // 用具体的变化类型替代通用的"变动"标签
        const separator = effectiveLang === 'en' ? ' <span style="color:var(--text-tertiary);">|</span> ' : '、';
        const structuralText = structuralParts.join(separator);
        summary.structuralLine = `<span style="color:var(--accent-secondary, #FF9800);font-weight:bold;">${structuralText}</span>`;
    }

    return summary;
}

// =============================================================================
// 时间捕捉小组件更新
// =============================================================================

let timeTrackingWidgetInterval = null;

async function updateTimeTrackingWidget() {
    const widgetList = document.getElementById('timeTrackingWidgetList');
    const widgetTitle = document.getElementById('timeTrackingWidgetTitle');

    if (!widgetList) return;

    const emptyText = i18n.timeTrackingWidgetEmpty[currentLang];

    // 检查追踪是否开启
    let isTrackingEnabled = true;
    try {
        const enabledResponse = await browserAPI.runtime.sendMessage({ action: 'isTrackingEnabled' });
        if (enabledResponse && enabledResponse.success) {
            isTrackingEnabled = enabledResponse.enabled;
        }
    } catch (e) {
        console.warn('[时间捕捉小组件] 检查追踪状态失败:', e);
    }

    if (isTrackingEnabled) {
        // 追踪开启：显示当前追踪的书签
        if (widgetTitle) widgetTitle.textContent = i18n.timeTrackingWidgetTitle[currentLang];

        try {
            const response = await browserAPI.runtime.sendMessage({
                action: 'getCurrentActiveSessions'
            });

            if (response && response.success && response.sessions && response.sessions.length > 0) {
                const sessions = response.sessions;

                // 按标题分组（与正在追踪的折叠逻辑一致）
                const groupedSessions = new Map();
                for (const session of sessions) {
                    const key = session.title || session.url;
                    if (!groupedSessions.has(key)) {
                        groupedSessions.set(key, []);
                    }
                    groupedSessions.get(key).push(session);
                }

                // 转换为显示数据（每组只显示一行，显示总和）
                const displayItems = [];
                for (const [groupKey, groupSessions] of groupedSessions) {
                    const totalCompositeMs = groupSessions.reduce((sum, s) => sum + (s.compositeMs || s.activeMs || 0), 0);
                    // 确定显示的状态（优先显示最活跃的状态）
                    const stateOrder = ['active', 'visible', 'paused', 'background', 'sleeping'];
                    const bestState = groupSessions.reduce((best, s) => {
                        const bestIdx = stateOrder.indexOf(best);
                        const currIdx = stateOrder.indexOf(s.state);
                        return currIdx < bestIdx ? s.state : best;
                    }, 'sleeping');

                    displayItems.push({
                        title: groupSessions[0].title,
                        url: groupSessions[0].url,
                        state: bestState,
                        compositeMs: totalCompositeMs,
                        count: groupSessions.length
                    });
                }

                const maxShow = 5;
                const showItems = displayItems.slice(0, maxShow);
                const remaining = displayItems.length - maxShow;

                widgetList.innerHTML = '';

                showItems.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'time-tracking-widget-item';

                    const stateIcon = document.createElement('span');
                    stateIcon.className = 'item-state';
                    stateIcon.textContent = item.state === 'active' ? '🟢' :
                        (item.state === 'sleeping' ? '💤' :
                            (item.state === 'background' ? '⚪' :
                                (item.state === 'visible' ? '🔵' : '🟡')));

                    const title = document.createElement('span');
                    title.className = 'item-title';
                    let titleText = item.title || new URL(item.url).hostname;
                    if (item.count > 1) titleText += ` (${item.count})`;
                    title.textContent = titleText;
                    title.title = item.title || item.url;

                    const time = document.createElement('span');
                    time.className = 'item-time';
                    time.textContent = formatActiveTime(item.compositeMs);

                    el.appendChild(stateIcon);
                    el.appendChild(title);
                    el.appendChild(time);
                    widgetList.appendChild(el);
                });

                if (remaining > 0) {
                    const moreEl = document.createElement('div');
                    moreEl.className = 'time-tracking-widget-more';
                    moreEl.textContent = i18n.timeTrackingWidgetMore[currentLang].replace('{count}', remaining);
                    widgetList.appendChild(moreEl);
                }
            } else {
                showEmptyState();
            }
        } catch (error) {
            console.warn('[时间捕捉小组件] 获取数据失败:', error);
            showEmptyState();
        }
    } else {
        // 追踪关闭：显示点击排行前5名（优先今天，没有则本周）
        if (widgetTitle) widgetTitle.textContent = i18n.timeTrackingWidgetRankingTitle ? i18n.timeTrackingWidgetRankingTitle[currentLang] : (currentLang === 'zh_CN' ? '点击排行' : 'Click Ranking');

        try {
            // 使用书签浏览记录的点击排行数据
            const stats = await ensureBrowsingClickRankingStats();

            if (!stats || stats.error || !stats.items || stats.items.length === 0) {
                showEmptyState();
                return;
            }

            // 先尝试获取今天的数据
            let items = getBrowsingRankingItemsForRange('day');
            let isToday = true;
            let countKey = 'dayCount';

            // 如果今天没有数据，获取本周的
            if (!items || items.length === 0) {
                items = getBrowsingRankingItemsForRange('week');
                isToday = false;
                countKey = 'weekCount';
            }

            if (items && items.length > 0) {
                // 取前5
                const top5 = items.slice(0, 5);

                widgetList.innerHTML = '';

                top5.forEach((item, index) => {
                    const el = document.createElement('div');
                    el.className = 'time-tracking-widget-item ranking-item';
                    el.dataset.url = item.url;

                    const rankNum = document.createElement('span');
                    rankNum.className = 'item-rank';
                    rankNum.textContent = `${index + 1}`;

                    const title = document.createElement('span');
                    title.className = 'item-title';
                    try {
                        title.textContent = item.title || new URL(item.url).hostname;
                    } catch {
                        title.textContent = item.title || item.url;
                    }
                    title.title = item.title || item.url;

                    const count = document.createElement('span');
                    count.className = 'item-time';
                    count.textContent = `${item[countKey]}${currentLang === 'zh_CN' ? '次' : 'x'}`;

                    el.appendChild(rankNum);
                    el.appendChild(title);
                    el.appendChild(count);

                    // 点击打开链接
                    el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        browserAPI.tabs.create({ url: item.url });
                    });

                    widgetList.appendChild(el);
                });

                // 显示时间范围提示
                const rangeHint = document.createElement('div');
                rangeHint.className = 'time-tracking-widget-hint';
                rangeHint.textContent = isToday ?
                    (currentLang === 'zh_CN' ? '今日' : 'Today') :
                    (currentLang === 'zh_CN' ? '本周' : 'This Week');
                widgetList.appendChild(rangeHint);
            } else {
                showEmptyState();
            }
        } catch (error) {
            console.warn('[时间捕捉小组件] 获取点击排行数据失败:', error);
            showEmptyState();
        }
    }

    function showEmptyState() {
        widgetList.innerHTML = `<div class="time-tracking-widget-empty"><span>${emptyText}</span></div>`;
    }
}

function formatActiveTime(ms) {
    if (!ms || ms < 1000) return '0s';
    const seconds = Math.floor(ms / 1000);
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m`;
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    return `${hours}h ${remainingMinutes}m`;
}

function startTimeTrackingWidgetRefresh() {
    if (timeTrackingWidgetInterval) {
        clearInterval(timeTrackingWidgetInterval);
    }
    updateTimeTrackingWidget();
    timeTrackingWidgetInterval = setInterval(updateTimeTrackingWidget, 1000);  // 1秒刷新，更实时
}

function stopTimeTrackingWidgetRefresh() {
    if (timeTrackingWidgetInterval) {
        clearInterval(timeTrackingWidgetInterval);
        timeTrackingWidgetInterval = null;
        console.log('[时间捕捉小组件] 已停止刷新（侧边栏收起）');
    }
}

function initTimeTrackingWidget() {
    const widget = document.getElementById('timeTrackingWidget');
    if (!widget) return;

    widget.addEventListener('click', () => {
        switchView('additions');
        setTimeout(() => {
            const trackingTab = document.getElementById('additionsTabTracking');
            if (trackingTab) {
                trackingTab.click();
            }
        }, 100);
    });

    // 检查侧边栏状态，只有展开时才启动刷新
    const sidebar = document.getElementById('sidebar');
    const isCollapsed = sidebar && sidebar.classList.contains('collapsed');
    if (!isCollapsed) {
        startTimeTrackingWidgetRefresh();
    } else {
        console.log('[时间捕捉小组件] 侧边栏收起，跳过刷新启动');
    }
}

// =============================================================================
// 侧边栏收起功能
// =============================================================================

function initSidebarToggle() {
    const sidebar = document.getElementById('sidebar');
    const toggleBtn = document.getElementById('sidebarToggle');

    if (!sidebar || !toggleBtn) {
        console.warn('[侧边栏] 找不到侧边栏或切换按钮');
        return;
    }

    // 根据当前实际 DOM 宽度更新侧边栏宽度 CSS 变量
    function syncSidebarWidth() {
        // 直接读取 sidebar 实际渲染宽度，兼容：
        // - 手动折叠/展开（.collapsed）
        // - 响应式 CSS 自动收缩
        const rect = sidebar.getBoundingClientRect();
        const widthPx = rect && rect.width ? `${rect.width}px` : '260px';
        document.documentElement.style.setProperty('--sidebar-width', widthPx);
    }

    // 从 localStorage 恢复侧边栏状态
    const savedState = localStorage.getItem('sidebarCollapsed');
    if (savedState === 'true') {
        sidebar.classList.add('collapsed');
        console.log('[侧边栏] 恢复收起状态');
    }
    // 恢复完状态后，同步一次真实宽度
    syncSidebarWidth();

    // 点击切换按钮
    toggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        sidebar.classList.toggle('collapsed');

        // 保存状态到 localStorage
        const isCollapsed = sidebar.classList.contains('collapsed');
        localStorage.setItem('sidebarCollapsed', isCollapsed.toString());

        // 更新 CSS 变量（用于弹窗定位）
        syncSidebarWidth();

        // 控制时间捕捉小组件刷新：收起时停止，展开时恢复
        if (isCollapsed) {
            stopTimeTrackingWidgetRefresh();
        } else {
            startTimeTrackingWidgetRefresh();
        }

        console.log('[侧边栏]', isCollapsed ? '已收起' : '已展开');
    });

    // 窗口尺寸变化时，侧边栏可能被 CSS 自动收缩/展开，这里也同步一次宽度
    window.addEventListener('resize', () => {
        syncSidebarWidth();
    });
}

// =============================================================================
// 视图切换
// =============================================================================

function switchView(view) {
    console.log('[switchView] 切换视图到:', view);

    const previousView = currentView;

    // 处理旧的 'tree' 命名
    if (view === 'tree') {
        view = 'canvas';
    }

    // 当从 Canvas 视图切换到其他视图时，尝试更新一次缩略图
    if (previousView === 'canvas' && view !== 'canvas') {
        try {
            if (typeof requestCanvasThumbnailUpdate === 'function') {
                requestCanvasThumbnailUpdate('switch-view');
            } else {
                captureCanvasThumbnail();
            }
        } catch (e) {
            console.warn('[Canvas Thumbnail] switchView 捕获失败:', e);
        }
    }

    // 更新全局变量
    currentView = view;

    // 更新导航标签
    document.querySelectorAll('.nav-tab').forEach(tab => {
        if (tab.dataset.view === view) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // 更新视图容器
    document.querySelectorAll('.view').forEach(v => {
        if (v.id === `${view}View`) {
            v.classList.add('active');
        } else {
            v.classList.remove('active');
        }
    });

    // 保存到 localStorage
    localStorage.setItem('lastActiveView', view);
    console.log('[switchView] 已保存视图到localStorage:', view);

    // 渲染当前视图
    renderCurrentView();
}

// 捕获当前窗口中 Bookmark Canvas 页面的可见区域，并保存为主界面缩略图
// 注意：为了实现「只截画布容器」，这里采用两级方案：
// 1）优先在页面内按 .canvas-main-container 的 rect 进行裁剪；
// 2）若裁剪失败，则退回整页截图（保持兼容性）。
function captureCanvasThumbnail() {
    try {
        // 仅在 Canvas 视图下尝试截屏
        if (currentView !== 'canvas') return;
        if (!browserAPI || !browserAPI.tabs || !browserAPI.tabs.captureVisibleTab) return;

        // 使用 tabs.captureVisibleTab 先拿整页截图，再在内容页内裁剪
        browserAPI.tabs.captureVisibleTab(null, { format: 'png' }, (dataUrl) => {
            try {
                const captureError = browserAPI.runtime && browserAPI.runtime.lastError;
                if (captureError) {
                    console.warn('[Canvas Thumbnail] 截图失败:', captureError.message || captureError);
                    return;
                }

                if (!dataUrl) return;

                // 在当前页面内按书签画布主容器（不含标题栏）的 rect 进行裁剪
                try {
                    const container = document.querySelector('.canvas-main-container');
                    if (!container) {
                        // 找不到容器，直接保存整页截图作为兜底
                        browserAPI.storage.local.set({ bookmarkCanvasThumbnail: dataUrl }, () => { });
                        return;
                    }

                    const rect = container.getBoundingClientRect();
                    const pageWidth = window.innerWidth || document.documentElement.clientWidth;

                    // 固定缩略图输出尺寸，适配主UI的框（约 270x180，宽高比 3:2）
                    // 使用 8x 分辨率确保超清显示
                    const THUMBNAIL_WIDTH = 2160;
                    const THUMBNAIL_HEIGHT = 1440;

                    const img = new Image();
                    img.onload = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            // 使用固定尺寸输出
                            canvas.width = THUMBNAIL_WIDTH;
                            canvas.height = THUMBNAIL_HEIGHT;
                            const ctx = canvas.getContext('2d');
                            if (!ctx) {
                                console.warn('[Canvas Thumbnail] 无法获取 2D 上下文，退回整页截图');
                                browserAPI.storage.local.set({ bookmarkCanvasThumbnail: dataUrl }, () => { });
                                return;
                            }

                            // 计算截图和页面之间的缩放比（captureVisibleTab 生成的图片宽度 / 当前页面宽度）
                            const ratio = img.width / pageWidth;

                            // 先按容器 rect 获取截图中的源区域（像素坐标）
                            let sx = rect.left * ratio;
                            let sy = rect.top * ratio;
                            let sw = rect.width * ratio;
                            let sh = rect.height * ratio;

                            // 安全处理：裁剪到截图可用范围（避免容器部分在可视区外时越界）
                            const ix = Math.max(0, sx);
                            const iy = Math.max(0, sy);
                            const iw = Math.max(0, Math.min(img.width - ix, sw - (ix - sx)));
                            const ih = Math.max(0, Math.min(img.height - iy, sh - (iy - sy)));

                            if (iw <= 1 || ih <= 1) {
                                console.warn('[Canvas Thumbnail] 裁剪区域无效，退回整页截图');
                                browserAPI.storage.local.set({ bookmarkCanvasThumbnail: dataUrl }, () => { });
                                return;
                            }

                            // 关键：保持主 UI 固定输出尺寸，但不要拉伸变形
                            // 这里采用「cover」策略：按目标宽高比在源图中居中裁剪，再缩放到固定尺寸
                            const targetAspect = canvas.width / canvas.height; // 3:2
                            let csx = ix;
                            let csy = iy;
                            let csw = iw;
                            let csh = ih;

                            const sourceAspect = csw / csh;
                            if (sourceAspect > targetAspect) {
                                // 源区域过宽：左右裁剪
                                const newW = csh * targetAspect;
                                csx = csx + (csw - newW) / 2;
                                csw = newW;
                            } else if (sourceAspect < targetAspect) {
                                // 源区域过高：上下裁剪
                                const newH = csw / targetAspect;
                                csy = csy + (csh - newH) / 2;
                                csh = newH;
                            }

                            // 最后再做一次边界收敛（浮点误差导致的越界）
                            csx = Math.max(0, csx);
                            csy = Math.max(0, csy);
                            csw = Math.max(1, Math.min(img.width - csx, csw));
                            csh = Math.max(1, Math.min(img.height - csy, csh));

                            ctx.drawImage(img, csx, csy, csw, csh, 0, 0, canvas.width, canvas.height);

                            const croppedDataUrl = canvas.toDataURL('image/jpeg', 0.98);
                            browserAPI.storage.local.set({ bookmarkCanvasThumbnail: croppedDataUrl }, () => {
                                // 静默保存，不输出日志
                            });
                        } catch (e) {
                            console.warn('[Canvas Thumbnail] 裁剪缩略图时出错，退回整页截图:', e);
                            browserAPI.storage.local.set({ bookmarkCanvasThumbnail: dataUrl }, () => { });
                        }
                    };
                    img.onerror = () => {
                        console.warn('[Canvas Thumbnail] 缩略图图片加载失败，退回整页截图');
                        browserAPI.storage.local.set({ bookmarkCanvasThumbnail: dataUrl }, () => { });
                    };
                    img.src = dataUrl;
                } catch (cropError) {
                    console.warn('[Canvas Thumbnail] 裁剪逻辑异常，退回整页截图:', cropError);
                    browserAPI.storage.local.set({ bookmarkCanvasThumbnail: dataUrl }, () => { });
                }
            } catch (e) {
                console.warn('[Canvas Thumbnail] 保存缩略图时出错:', e);
            }
        });
    } catch (error) {
        console.warn('[Canvas Thumbnail] 截图失败:', error);
    }
}

// 供 Canvas 模块调用的去抖更新入口
let canvasThumbnailUpdateTimer = null;
function requestCanvasThumbnailUpdate(reason) {
    try {
        // 提前检查：只在 Canvas 视图下调度截图
        if (currentView !== 'canvas') return;

        if (canvasThumbnailUpdateTimer) {
            clearTimeout(canvasThumbnailUpdateTimer);
        }
        canvasThumbnailUpdateTimer = setTimeout(() => {
            canvasThumbnailUpdateTimer = null;
            try {
                captureCanvasThumbnail();
            } catch (e) {
                // 静默处理错误
            }
        }, 1500); // 1.5 秒内合并多次修改
    } catch (e) {
        // 忽略去抖调度错误
    }
}

// Canvas 滚动视图相关截图节流
let canvasScrollThumbnailBound = false;
let canvasScrollThumbnailTimer = null;

function renderCurrentView() {
    // 如果离开书签记录视图，停止时间捕捉实时刷新定时器
    if (currentView !== 'additions' && trackingRefreshInterval) {
        stopTrackingRefresh();
    }

    // 控制缩放控制器的显示/隐藏
    const zoomIndicator = document.getElementById('canvasZoomIndicator');
    if (zoomIndicator) {
        if (currentView === 'canvas') {
            zoomIndicator.style.display = 'block';
        } else {
            zoomIndicator.style.display = 'none';
        }
    }

    switch (currentView) {
        case 'current-changes':
            // 使用带重试 + 合并请求的渲染函数，避免多次抖动
            renderCurrentChangesViewWithRetry(1, false);
            break;
        case 'history':
            renderHistoryView();
            break;
        case 'additions':
            renderAdditionsView();
            break;
        case 'canvas':
            // Canvas视图：包含原Bookmark Tree所有功能 + Canvas画布功能
            // 性能优化：使用状态缓存，避免重复初始化
            {
                const canvasContent = document.getElementById('canvasContent');
                let permanentSectionExists = document.getElementById('permanentSection');
                const canvasView = document.getElementById('canvasView');

                // 检查Canvas是否已经初始化过
                const isCanvasInitialized = canvasView && canvasView.dataset.initialized === 'true';

                // 1. 先从template创建永久栏目并添加到canvas-content（如果还不存在）
                if (!permanentSectionExists && canvasContent) {
                    const template = document.getElementById('permanentSectionTemplate');
                    if (template) {
                        const permanentSection = template.content.cloneNode(true);
                        canvasContent.appendChild(permanentSection);
                        console.log('[Canvas] 永久栏目已从template创建到canvas-content');

                        // 立即应用语言设置（使用主UI的applyLanguage函数）
                        setTimeout(() => {
                            applyLanguage();
                            console.log('[Canvas] 永久栏目语言已应用:', currentLang);
                        }, 0);
                    } else {
                        console.error('[Canvas] 找不到permanentSectionTemplate');
                    }
                } else if (!canvasContent) {
                    console.error('[Canvas] 找不到canvasContent');
                } else {
                    console.log('[Canvas] 永久栏目已存在，跳过创建');
                }

                // 2. 渲染书签树
                // 即使是已初始化状态，也需要调用 renderTreeView 检查是否有数据更新（内部有缓存机制，开销很小）
                renderTreeView().catch(e => console.error('[Canvas] 书签树渲染失败:', e));

                // 3. 初始化Canvas功能（缩放、平移、拖拽等）- 仅首次执行
                if (!isCanvasInitialized) {
                    // 首次初始化
                    try {
                        if (window.CanvasModule) {
                            window.CanvasModule.init();
                        }

                        // 标记Canvas已初始化
                        if (canvasView) {
                            canvasView.dataset.initialized = 'true';
                            canvasView.dataset.initTime = Date.now().toString();
                        }
                        console.log('[Canvas] 首次初始化完成');
                    } catch (initError) {
                        console.error('[Canvas] 初始化失败:', initError);
                        // 初始化失败时不标记为已初始化，下次会重试
                    }
                } else {
                    // 已初始化：验证状态
                    console.log('[Canvas] 使用缓存状态，检查完整性');

                    // 验证Canvas状态是否有效
                    const canvasWorkspace = document.getElementById('canvasWorkspace');
                    const canvasContentEl = document.getElementById('canvasContent');
                    // 只要容器存在即可，children.length 检查交由 renderTreeView 保证
                    const hasValidState = canvasWorkspace && canvasContentEl;

                    if (!hasValidState) {
                        // 状态无效，尝试重新初始化模块
                        console.warn('[Canvas] 缓存状态无效，重新初始化模块');
                        if (canvasView) {
                            canvasView.dataset.initialized = 'false';
                        }
                        try {
                            if (window.CanvasModule) {
                                window.CanvasModule.init();
                            }
                            if (canvasView) {
                                canvasView.dataset.initialized = 'true';
                                canvasView.dataset.initTime = Date.now().toString();
                            }
                        } catch (reinitError) {
                            console.error('[Canvas] 重新初始化失败:', reinitError);
                        }
                    } else {
                        // 触发视口休眠管理，唤醒可见栏目
                        if (window.CanvasModule && window.CanvasModule.scheduleDormancyUpdate) {
                            // 延迟执行，确保视图切换完成
                            setTimeout(() => {
                                try {
                                    window.CanvasModule.scheduleDormancyUpdate();
                                } catch (err) {
                                    console.warn('[Canvas] 休眠管理调度失败:', err);
                                }
                            }, 50);
                        }
                    }
                }

                // 4. 首次进入或刷新 Canvas 视图后，延迟截一次图
                setTimeout(() => {
                    try {
                        if (currentView === 'canvas') {
                            captureCanvasThumbnail();
                        }
                    } catch (_) { }
                }, 800);

                // 5. 绑定 Canvas 滚动截图逻辑（只绑定一次）
                const workspace = document.getElementById('canvasWorkspace');
                if (workspace && !canvasScrollThumbnailBound) {
                    canvasScrollThumbnailBound = true;
                    workspace.addEventListener('wheel', () => {
                        try {
                            if (currentView !== 'canvas') return;
                            if (!requestCanvasThumbnailUpdate) return;
                            if (canvasScrollThumbnailTimer) {
                                clearTimeout(canvasScrollThumbnailTimer);
                            }
                            canvasScrollThumbnailTimer = setTimeout(() => {
                                canvasScrollThumbnailTimer = null;
                                requestCanvasThumbnailUpdate('scroll');
                            }, 2500);
                        } catch (_) { }
                    }, { passive: true });
                }
            }
            break;
        case 'recommend':
            renderRecommendView();
            break;
    }
}

// =============================================================================
// 书签推荐视图
// =============================================================================

let recommendViewInitialized = false;

function renderRecommendView() {
    console.log('[书签推荐] 渲染推荐视图');

    // 只初始化一次事件监听器
    if (!recommendViewInitialized) {
        // 初始化可折叠区域
        initCollapsibleSections();

        // 初始化公式输入框事件
        initFormulaInputs();

        // 初始化卡片交互
        initCardInteractions();

        // 初始化追踪开关
        initTrackingToggle();

        // 初始化稍后复习弹窗
        initLaterModal();

        // 初始化添加域名和文件夹弹窗
        initAddDomainModal();
        initSelectFolderModal();
        initBlockManageButtons();

        // 初始化时间追踪屏蔽管理
        initTrackingBlockModal();
        initSelectTrackingBlockFolderModal();
        initAddTrackingBlockDomainModal();

        // 初始化添加到稍后复习弹窗
        initAddToPostponedModal();

        recommendViewInitialized = true;
    }

    // 每次进入视图时加载数据
    loadRecommendData();
}

function initCollapsibleSections() {
    document.querySelectorAll('.collapsible .section-header').forEach(header => {
        header.addEventListener('click', (e) => {
            // 避免点击追踪开关时触发折叠
            if (e.target.closest('.tracking-toggle')) return;
            // 避免点击输入框时触发折叠
            if (e.target.closest('input')) return;
            const section = header.closest('.collapsible');
            section.classList.toggle('collapsed');
        });
    });

    // 初始化拖拽排序
    initSectionDragSort();

    // 恢复保存的顺序
    restoreSectionOrder();
}

// 初始化折叠区域拖拽排序
function initSectionDragSort() {
    const container = document.getElementById('recommendSectionsContainer');
    if (!container) return;

    let draggedElement = null;
    let isDragging = false;
    let startY = 0;

    container.querySelectorAll('.draggable-section').forEach(section => {
        const header = section.querySelector('.section-header');
        if (!header) return;

        header.addEventListener('mousedown', (e) => {
            // 点击按钮或输入框时不触发拖拽
            if (e.target.closest('button') || e.target.closest('input')) return;

            startY = e.clientY;
            draggedElement = section;

            const onMouseMove = (e) => {
                if (!draggedElement) return;

                // 移动超过5px才开始拖拽
                if (!isDragging && Math.abs(e.clientY - startY) > 5) {
                    isDragging = true;
                    section.classList.add('dragging');
                }

                if (!isDragging) return;

                const sections = [...container.querySelectorAll('.draggable-section')];
                const afterElement = getDragAfterElement(container, e.clientY);

                sections.forEach(s => s.classList.remove('drag-over'));

                if (afterElement) {
                    afterElement.classList.add('drag-over');
                }
            };

            const onMouseUp = () => {
                if (isDragging && draggedElement) {
                    const sections = [...container.querySelectorAll('.draggable-section')];
                    const afterElement = sections.find(s => s.classList.contains('drag-over'));

                    sections.forEach(s => s.classList.remove('drag-over'));
                    draggedElement.classList.remove('dragging');

                    if (afterElement && afterElement !== draggedElement) {
                        container.insertBefore(draggedElement, afterElement);
                        saveSectionOrder();
                    }
                }

                draggedElement = null;
                isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    });
}

function getDragAfterElement(container, y) {
    const sections = [...container.querySelectorAll('.draggable-section:not(.dragging)')];

    return sections.reduce((closest, section) => {
        const box = section.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;

        if (offset < 0 && offset > closest.offset) {
            return { offset, element: section };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function saveSectionOrder() {
    const container = document.getElementById('recommendSectionsContainer');
    if (!container) return;

    const order = [...container.querySelectorAll('.draggable-section')]
        .map(s => s.dataset.sectionId);

    browserAPI.storage.local.set({ recommendSectionOrder: order });
    console.log('[书签推荐] 保存栏目顺序:', order);
}

function restoreSectionOrder() {
    browserAPI.storage.local.get(['recommendSectionOrder'], (result) => {
        if (!result.recommendSectionOrder) return;

        const container = document.getElementById('recommendSectionsContainer');
        if (!container) return;

        const order = result.recommendSectionOrder;
        const sections = [...container.querySelectorAll('.draggable-section')];

        order.forEach(id => {
            const section = sections.find(s => s.dataset.sectionId === id);
            if (section) {
                container.appendChild(section);
            }
        });

        console.log('[书签推荐] 恢复栏目顺序:', order);
    });
}

// 根据待复习数量决定是否折叠
function updatePostponedCollapse(count) {
    const section = document.querySelector('.recommend-postponed-section');
    if (!section) return;

    if (count === 0) {
        section.classList.add('collapsed');
    }
}

function initFormulaInputs() {
    // 权重输入框
    const weightInputs = document.querySelectorAll('.formula-weight');
    weightInputs.forEach(input => {
        input.addEventListener('click', () => {
            input.removeAttribute('readonly');
            input.select();
        });
        input.addEventListener('blur', () => {
            input.setAttribute('readonly', 'readonly');
            normalizeWeights();
        });
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                input.blur();
            }
        });
    });

    // 阈值输入框
    const thresholdInputs = document.querySelectorAll('.threshold-value');
    thresholdInputs.forEach(input => {
        input.addEventListener('blur', () => {
            saveFormulaConfig();
        });
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                input.blur();
            }
        });
    });

    // 恢复默认按钮
    const resetBtn = document.getElementById('resetFormulaBtn');
    if (resetBtn) {
        resetBtn.addEventListener('click', resetFormulaToDefault);
    }

    // 加载保存的配置
    loadFormulaConfig();
}

function normalizeWeights() {
    const w1 = parseFloat(document.getElementById('weightFreshness').value) || 0;
    const w2 = parseFloat(document.getElementById('weightColdness').value) || 0;
    const w3 = parseFloat(document.getElementById('weightTimeDegree').value) || 0;
    const w4 = parseFloat(document.getElementById('weightForgetting').value) || 0;
    const w5 = parseFloat(document.getElementById('weightLaterReview').value) || 0;

    const total = w1 + w2 + w3 + w4 + w5;
    if (total > 0 && Math.abs(total - 1) > 0.01) {
        document.getElementById('weightFreshness').value = (w1 / total).toFixed(2);
        document.getElementById('weightColdness').value = (w2 / total).toFixed(2);
        document.getElementById('weightTimeDegree').value = (w3 / total).toFixed(2);
        document.getElementById('weightForgetting').value = (w4 / total).toFixed(2);
        document.getElementById('weightLaterReview').value = (w5 / total).toFixed(2);
    }
    saveFormulaConfig();
}

function resetFormulaToDefault() {
    document.getElementById('weightFreshness').value = '0.15';
    document.getElementById('weightColdness').value = '0.20';
    document.getElementById('weightTimeDegree').value = '0.25';
    document.getElementById('weightForgetting').value = '0.20';
    document.getElementById('weightLaterReview').value = '0.20';

    document.getElementById('thresholdFreshness').value = '30';
    document.getElementById('thresholdColdness').value = '10';
    document.getElementById('thresholdTimeDegree').value = '5';
    document.getElementById('thresholdForgetting').value = '14';

    saveFormulaConfig();
}

async function saveFormulaConfig() {
    const config = {
        weights: {
            freshness: parseFloat(document.getElementById('weightFreshness').value) || 0.15,
            coldness: parseFloat(document.getElementById('weightColdness').value) || 0.20,
            shallowRead: parseFloat(document.getElementById('weightTimeDegree').value) || 0.25,
            forgetting: parseFloat(document.getElementById('weightForgetting').value) || 0.20,
            laterReview: parseFloat(document.getElementById('weightLaterReview').value) || 0.20
        },
        thresholds: {
            freshness: parseInt(document.getElementById('thresholdFreshness').value) || 30,
            coldness: parseInt(document.getElementById('thresholdColdness').value) || 10,
            shallowRead: parseInt(document.getElementById('thresholdTimeDegree').value) || 5,
            forgetting: parseInt(document.getElementById('thresholdForgetting').value) || 14
        }
    };
    await browserAPI.storage.local.set({ recommendFormulaConfig: config });
    // 权重/阈值变化时清除旧缓存，通知background.js重新计算所有书签S值
    if (typeof clearScoresCache === 'function') {
        await clearScoresCache();
    }
    // 发消息给background.js触发全量计算
    browserAPI.runtime.sendMessage({ action: 'computeBookmarkScores' }, (response) => {
        if (browserAPI.runtime.lastError) {
            console.warn('[书签推荐] 请求background计算S值失败:', browserAPI.runtime.lastError.message);
        } else {
            console.log('[书签推荐] background计算S值完成:', response?.success);
        }
    });
    console.log('[书签推荐] 保存公式配置，已请求background重新计算S值:', config);
}

function loadFormulaConfig() {
    browserAPI.storage.local.get(['recommendFormulaConfig'], (result) => {
        if (result.recommendFormulaConfig) {
            const config = result.recommendFormulaConfig;
            document.getElementById('weightFreshness').value = config.weights.freshness;
            document.getElementById('weightColdness').value = config.weights.coldness;
            document.getElementById('weightTimeDegree').value = config.weights.shallowRead;
            document.getElementById('weightForgetting').value = config.weights.forgetting;
            document.getElementById('weightLaterReview').value = config.weights.laterReview ?? 0.20;

            document.getElementById('thresholdFreshness').value = config.thresholds.freshness;
            document.getElementById('thresholdColdness').value = config.thresholds.coldness;
            document.getElementById('thresholdTimeDegree').value = config.thresholds.shallowRead;
            document.getElementById('thresholdForgetting').value = config.thresholds.forgetting;
            console.log('[书签推荐] 加载公式配置:', config);
        }
    });
}

// 当前推荐模式
let currentRecommendMode = 'default'; // 默认模式

// 预设模式配置（时间度权重增大，使用综合时间）
const presetModes = {
    // 默认模式：均衡推荐
    default: {
        weights: {
            freshness: 0.15,      // 新鲜度
            coldness: 0.15,       // 冷门度
            timeDegree: 0.30,     // 时间度（综合时间短=需要深入阅读）
            forgetting: 0.20,     // 遗忘因子
            laterReview: 0.20     // 待复习权重
        },
        thresholds: {
            freshness: 30,        // 30天内算新
            coldness: 10,         // 10次以下算冷门
            timeDegree: 5,        // 5分钟以下算浅读
            forgetting: 14        // 14天未访问算遗忘
        }
    },
    // 考古模式：挖掘尘封已久的书签
    archaeology: {
        weights: {
            freshness: 0.05,      // 新鲜度权重低
            coldness: 0.25,       // 冷门度高权重
            timeDegree: 0.20,     // 时间度
            forgetting: 0.35,     // 遗忘因子最高
            laterReview: 0.15     // 待复习权重
        },
        thresholds: {
            freshness: 90,        // 90天内算新
            coldness: 3,          // 3次以下算冷门
            timeDegree: 3,        // 3分钟以下算浅读
            forgetting: 30        // 30天未访问算遗忘
        }
    },
    // 巩固模式：经常访问但还没深入阅读的书签
    consolidate: {
        weights: {
            freshness: 0.15,      // 新鲜度
            coldness: 0.05,       // 冷门度低（推荐常用的）
            timeDegree: 0.40,     // 时间度高（推荐还没深入阅读的）
            forgetting: 0.20,     // 遗忘度稍高
            laterReview: 0.20     // 待复习权重
        },
        thresholds: {
            freshness: 14,        // 14天内算新
            coldness: 30,         // 30次以下算冷门（提高阈值，让常用书签也能被选中）
            timeDegree: 10,       // 10分钟以下算浅读
            forgetting: 7         // 7天未访问算遗忘
        }
    },
    // 漫游模式：随机探索
    wander: {
        weights: {
            freshness: 0.20,
            coldness: 0.15,
            timeDegree: 0.25,
            forgetting: 0.20,
            laterReview: 0.20
        },
        thresholds: {
            freshness: 21,
            coldness: 10,
            timeDegree: 5,
            forgetting: 14
        }
    },
    // 优先巩固模式：手动添加待复习时自动激活
    priority: {
        weights: {
            freshness: 0.05,
            coldness: 0.05,
            timeDegree: 0.10,
            forgetting: 0.10,
            laterReview: 0.70
        },
        thresholds: {
            freshness: 30,
            coldness: 10,
            timeDegree: 5,
            forgetting: 14
        }
    }
};

// =============================================================================
// 推荐卡片专用：弹窗管理
// =============================================================================

// 预加载 favicon（使用现有的 FaviconCache 系统）
function preloadHighResFavicons(urls) {
    urls.forEach(url => {
        if (url) FaviconCache.fetch(url);
    });
}

// 设置 favicon（使用现有的 FaviconCache 系统）
function setHighResFavicon(imgElement, url) {
    if (!url) {
        imgElement.src = fallbackIcon;
        return;
    }

    // 使用现有的 getFaviconUrl（会触发异步加载）
    imgElement.src = getFaviconUrl(url);

    // 异步获取更高质量版本
    getFaviconUrlAsync(url).then(dataUrl => {
        if (dataUrl && dataUrl !== fallbackIcon) {
            imgElement.src = dataUrl;
        }
    });
}

// 推荐卡片专用窗口 - 使用storage共享窗口ID（与popup同步）
async function getSharedRecommendWindowId() {
    return new Promise((resolve) => {
        browserAPI.storage.local.get(['recommendWindowId'], (result) => {
            resolve(result.recommendWindowId || null);
        });
    });
}

async function saveSharedRecommendWindowId(windowId) {
    await browserAPI.storage.local.set({ recommendWindowId: windowId });
}

// 监听storage变化，实现history和popup页面的实时同步
// 标志：用于防止 history 页面自己保存的变化触发重复刷新
let historyLastSaveTime = 0;
browserAPI.storage.onChanged.addListener((changes, areaName) => {
    if (areaName === 'local' && changes.popupCurrentCards) {
        // 仅在推荐视图时处理
        if (currentView !== 'recommend') return;

        // 检查是否是 history 页面自己刚保存的（500ms内忽略）
        const now = Date.now();
        if (now - historyLastSaveTime < 500) {
            console.log('[卡片同步] 忽略本页面保存触发的变化');
            return;
        }

        const newValue = changes.popupCurrentCards.newValue;
        const oldValue = changes.popupCurrentCards.oldValue;

        if (newValue && newValue.cardIds) {
            // 检查卡片ID是否变化（popup刷新了卡片）
            const oldCardIds = oldValue?.cardIds || [];
            const newCardIds = newValue.cardIds || [];
            const cardIdsChanged = JSON.stringify(oldCardIds.sort()) !== JSON.stringify(newCardIds.sort());

            if (cardIdsChanged) {
                // 卡片ID变化（来自popup的刷新），同步更新HTML页面
                console.log('[卡片同步] popup刷新了卡片，同步更新HTML');
                syncCardsFromStorage(newValue);
                return;
            }

            // 检查是否全部勾选
            if (newValue.flippedIds) {
                const allFlipped = newValue.cardIds.every(id => newValue.flippedIds.includes(id));
                if (allFlipped && newValue.cardIds.length > 0) {
                    // 全部勾选（来自popup的操作），刷新获取新卡片
                    console.log('[卡片同步] popup完成翻牌，刷新卡片');
                    refreshRecommendCards(true);
                }
            }
        }
    }
});

// 从storage同步卡片显示（不重新计算，直接使用popup的数据）
async function syncCardsFromStorage(cardState) {
    try {
        const cardsRow = document.getElementById('cardsRow');
        if (!cardsRow) return;

        const cards = cardsRow.querySelectorAll('.recommend-card');
        if (cards.length === 0 || !cardState.cardData) return;

        const { cardIds, flippedIds, cardData } = cardState;

        // 获取S值缓存用于显示优先级
        const scoresCache = await getScoresCache();

        cards.forEach((card, index) => {
            if (index >= cardData.length) return;

            const data = cardData[index];
            const bookmarkId = cardIds[index];
            const isFlipped = flippedIds?.includes(bookmarkId);

            // 更新卡片内容
            card.dataset.bookmarkId = bookmarkId;

            const titleEl = card.querySelector('.card-title');
            if (titleEl) {
                titleEl.textContent = data.title || data.url || '--';
            }

            // 更新favicon（三层降级：网站自己 → DuckDuckGo → Google S2）
            const favicon = card.querySelector('.card-favicon');
            if (favicon && data.url) {
                try {
                    const urlObj = new URL(data.url);
                    const domain = urlObj.hostname;
                    // 设置初始favicon（网站自己的）
                    favicon.src = data.favicon || `${urlObj.protocol}//${domain}/favicon.ico`;
                    // 失败时降级到DuckDuckGo
                    favicon.onerror = () => {
                        favicon.src = `https://icons.duckduckgo.com/ip3/${domain}.ico`;
                        // 再失败降级到Google S2
                        favicon.onerror = () => {
                            favicon.src = `https://www.google.com/s2/favicons?domain=${domain}&sz=32`;
                            favicon.onerror = () => { favicon.src = fallbackIcon; };
                        };
                    };
                } catch (e) {
                    favicon.src = fallbackIcon;
                }
            }

            // 更新优先级显示
            const priorityEl = card.querySelector('.card-priority');
            if (priorityEl) {
                const cached = scoresCache[bookmarkId];
                const priority = cached ? cached.S : 0;
                priorityEl.textContent = `S = ${priority.toFixed(2)}`;
            }

            // 更新翻阅状态
            if (isFlipped) {
                card.classList.add('flipped');
            } else {
                card.classList.remove('flipped');
            }

            card.classList.remove('empty');
        });

        console.log('[卡片同步] HTML页面已同步popup的卡片');
    } catch (e) {
        console.warn('[卡片同步] 同步失败:', e);
    }
}

// 在推荐窗口中打开链接
async function openInRecommendWindow(url) {
    if (!url) return;

    try {
        // 从storage获取共享的窗口ID
        let windowId = await getSharedRecommendWindowId();

        // 检查窗口是否存在
        if (windowId) {
            try {
                await browserAPI.windows.get(windowId);
                // 窗口存在，在其中打开新标签页
                const tab = await browserAPI.tabs.create({
                    windowId: windowId,
                    url: url,
                    active: true
                });
                try {
                    if (typeof window.reportExtensionBookmarkOpen === 'function' && tab && tab.id != null) {
                        await window.reportExtensionBookmarkOpen({ tabId: tab.id, url, source: 'recommend_window' });
                    }
                } catch (_) { }
                await browserAPI.windows.update(windowId, { focused: true });
                return;
            } catch (e) {
                // 窗口已关闭，清除保存的ID
                await saveSharedRecommendWindowId(null);
            }
        }

        // 创建新窗口
        const width = Math.min(1200, Math.round(screen.availWidth * 0.75));
        const height = Math.min(800, Math.round(screen.availHeight * 0.8));
        const left = Math.round((screen.availWidth - width) / 2);
        const top = Math.round((screen.availHeight - height) / 2);

        const win = await browserAPI.windows.create({
            url: url,
            type: 'normal',
            width, height, left, top,
            focused: true
        });
        try {
            const tabId = win?.tabs?.[0]?.id ?? null;
            if (typeof window.reportExtensionBookmarkOpen === 'function' && tabId != null) {
                await window.reportExtensionBookmarkOpen({ tabId, url, source: 'recommend_window' });
            }
        } catch (_) { }
        // 保存窗口ID到storage，供popup和history共享
        await saveSharedRecommendWindowId(win.id);

    } catch (error) {
        console.error('[推荐卡片] 打开窗口失败:', error);
        browserAPI.tabs.create({ url });
    }
}

function initCardInteractions() {
    // 刷新按钮（直接从缓存读取S值，选择新的Top3卡片）
    document.getElementById('cardRefreshBtn')?.addEventListener('click', async (e) => {
        e.stopPropagation();
        // S值已通过增量更新保持最新，直接从缓存刷新卡片
        await refreshRecommendCards(true);
    });

    // 刷新设置按钮
    document.getElementById('refreshSettingsBtn')?.addEventListener('click', (e) => {
        e.stopPropagation();
        showRefreshSettingsModal();
    });

    // 初始化刷新设置弹窗
    initRefreshSettingsModal();

    // 预设模式按钮
    document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const mode = btn.dataset.mode;
            applyPresetMode(mode);
        });
    });
}

// =============================================================================
// 【重要架构】全局链接点击兜底监听器 - 时间捕捉归因
// =============================================================================
// 本项目有三套独立的链接点击处理系统，互不干扰：
//   1. 书签系统（defaultOpenMode）- 处理 .tree-bookmark-link
//      → history.js:attachTreeEvents + bookmark_canvas_module.js:tempLinkClickHandler
//   2. 超链接系统（hyperlinkDefaultOpenMode）- 处理说明框/Markdown卡片内链接
//      → bookmark_tree_context_menu.js:attachHyperlinkContextMenu
//   3. 时间捕捉兜底（本监听器）- 处理其他所有 target="_blank" 链接
//
// ⚠️ 添加新功能时必须注意：
//   - 如果新增链接区域有自己的处理逻辑，必须在下面添加排除条件！
//   - 否则会导致链接被打开两次（本监听器 + 专用监听器都处理）
//   - 详见：.agent/workflows/link-click-handling.md
// =============================================================================
// 捕捉 extension 页面内的超链接打开（<a target="_blank">），统一走 tabs.create 以便做书签归因兜底
// 排除书签链接（.tree-bookmark-link）和超链接区域，让其走专门的处理逻辑
try {
    document.addEventListener('click', async (e) => {
        const anchor = e.target && typeof e.target.closest === 'function'
            ? e.target.closest('a[target="_blank"]')
            : null;
        if (!anchor) return;

        // 排除书签链接：书签链接有专门的处理逻辑（支持 defaultOpenMode 记忆）
        if (anchor.classList.contains('tree-bookmark-link')) return;

        // 排除超链接区域：说明框、Markdown卡片内的链接有专门的超链接处理逻辑（hyperlinkDefaultOpenMode）
        if (anchor.closest('.permanent-section-tip, .permanent-section-tip-editor, .temp-node-description, .temp-node-description-editor, .md-canvas-text, .md-canvas-editor')) return;

        const href = anchor.getAttribute('href') || '';
        if (!href || (!href.startsWith('http://') && !href.startsWith('https://'))) return;

        // 已被其他逻辑处理则跳过
        if (e.defaultPrevented) return;

        e.preventDefault();
        e.stopPropagation();

        const title = (anchor.textContent || '').trim();
        if (typeof window.openBookmarkNewTab === 'function') {
            await window.openBookmarkNewTab(href, { title, source: 'history_ui_link' });
        } else {
            window.open(href, '_blank');
        }
    }, true);
} catch (_) { }

// 应用预设模式
function applyPresetMode(mode) {
    if (!presetModes[mode]) return;

    // 如果已经是目标模式，不触发全量重算
    if (currentRecommendMode === mode) {
        console.log('[书签推荐] 已是当前模式，跳过重算:', mode);
        return;
    }

    currentRecommendMode = mode;
    const preset = presetModes[mode];

    // 更新按钮状态
    document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
    });

    // 更新权重输入框
    const weightInputs = {
        freshness: document.getElementById('weightFreshness'),
        coldness: document.getElementById('weightColdness'),
        timeDegree: document.getElementById('weightTimeDegree'),
        forgetting: document.getElementById('weightForgetting'),
        laterReview: document.getElementById('weightLaterReview')
    };

    // 设置权重值
    weightInputs.freshness.value = preset.weights.freshness;
    weightInputs.coldness.value = preset.weights.coldness;
    weightInputs.timeDegree.value = preset.weights.timeDegree;
    weightInputs.forgetting.value = preset.weights.forgetting;
    weightInputs.laterReview.value = preset.weights.laterReview;

    // 处理优先模式和用户覆盖
    const priorityModeBtn = document.getElementById('priorityModeBtn');

    if (mode === 'priority') {
        // 优先模式：橙色显示
        for (const input of Object.values(weightInputs)) {
            input.style.color = '#ff6b35';
            input.style.fontWeight = 'bold';
        }
        // 清除用户覆盖标记
        if (priorityModeBtn) {
            delete priorityModeBtn.dataset.userOverride;
        }
    } else {
        // 其他模式：正常显示
        for (const input of Object.values(weightInputs)) {
            input.style.color = '';
            input.style.fontWeight = '';
        }
        // 设置用户覆盖标记（防止自动切换回优先模式）
        if (priorityModeBtn && priorityModeBtn.style.display !== 'none') {
            priorityModeBtn.dataset.userOverride = 'true';
        }
    }

    // 更新阈值输入框
    document.getElementById('thresholdFreshness').value = preset.thresholds.freshness;
    document.getElementById('thresholdColdness').value = preset.thresholds.coldness;
    document.getElementById('thresholdTimeDegree').value = preset.thresholds.timeDegree;
    document.getElementById('thresholdForgetting').value = preset.thresholds.forgetting;

    // 保存配置（saveFormulaConfig 内部会触发全量重算）
    saveFormulaConfig().then(() => {
        // 重算完成后刷新推荐卡片
        refreshRecommendCards();
    });

    const modeNames = { default: '默认', archaeology: '考古', consolidate: '巩固', wander: '漫游', priority: '优先巩固' };
    console.log(`[书签推荐] 切换到${modeNames[mode] || mode}模式`);
}

function initTrackingToggle() {
    const toggleBtn = document.getElementById('trackingToggleBtn');
    if (toggleBtn) {
        toggleBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            toggleBtn.classList.toggle('active');
            const isActive = toggleBtn.classList.contains('active');
            document.getElementById('trackingToggleText').textContent = isActive ?
                i18n.trackingToggleOn[currentLang] :
                i18n.trackingToggleOff[currentLang];

            // 更新公式中的T项（时间度）
            const termT = document.getElementById('termTimeDegree');
            if (termT) {
                if (isActive) {
                    termT.classList.remove('disabled');
                } else {
                    termT.classList.add('disabled');
                }
            }

            // 通知 background.js 更新追踪状态
            try {
                await browserAPI.runtime.sendMessage({
                    action: 'setTrackingEnabled',
                    enabled: isActive
                });
                // 立即刷新左下角小组件
                updateTimeTrackingWidget();
            } catch (error) {
                console.warn('[书签推荐] 设置追踪状态失败:', error);
            }
        });

        // 加载保存的状态
        browserAPI.runtime.sendMessage({ action: 'isTrackingEnabled' }, (response) => {
            if (response && response.success) {
                const isActive = response.enabled;
                if (isActive) {
                    toggleBtn.classList.add('active');
                    document.getElementById('trackingToggleText').textContent =
                        i18n.trackingToggleOn[currentLang];
                } else {
                    toggleBtn.classList.remove('active');
                    document.getElementById('trackingToggleText').textContent =
                        i18n.trackingToggleOff[currentLang];
                    document.getElementById('termTimeDegree')?.classList.add('disabled');
                }
            }
        });
    }

    // 排行类型选择器（综合时间 / 唤醒次数）
    const rankingTypeSelect = document.getElementById('trackingRankingType');
    if (rankingTypeSelect) {
        rankingTypeSelect.addEventListener('change', () => {
            loadActiveTimeRanking();
        });
    }

    // 时间范围选择器
    const rangeSelect = document.getElementById('trackingRankingRange');
    if (rangeSelect) {
        rangeSelect.addEventListener('change', () => {
            loadActiveTimeRanking();
        });
    }

    // 清除记录按钮 - 改为下拉菜单
    const clearBtn = document.getElementById('clearTrackingBtn');
    if (clearBtn) {
        clearBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showTrackingClearMenu(clearBtn);
        });
    }

    // 状态说明弹窗（使用事件委托，支持动态创建的图标）
    const stateModal = document.getElementById('trackingStateModal');
    const closeStateModalBtn = document.getElementById('closeTrackingStateModal');
    const trackingHeaderState = document.getElementById('trackingHeaderState');

    if (trackingHeaderState && stateModal) {
        trackingHeaderState.addEventListener('click', (e) => {
            if (e.target.classList.contains('tracking-state-help')) {
                e.stopPropagation();
                stateModal.classList.add('show');
                updateTrackingStateModalI18n();
            }
        });

        if (closeStateModalBtn) {
            closeStateModalBtn.addEventListener('click', () => {
                stateModal.classList.remove('show');
            });
        }

        // 点击背景关闭
        stateModal.addEventListener('click', (e) => {
            if (e.target === stateModal) {
                stateModal.classList.remove('show');
            }
        });
    }

    // 公式说明弹窗
    const formulaHelpBtn = document.getElementById('formulaHelpBtn');
    const formulaHelpModal = document.getElementById('formulaHelpModal');
    const closeFormulaHelpBtn = document.getElementById('closeFormulaHelpModal');

    if (formulaHelpBtn && formulaHelpModal) {
        formulaHelpBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            formulaHelpModal.classList.add('show');
            updateFormulaHelpModalI18n();
        });

        if (closeFormulaHelpBtn) {
            closeFormulaHelpBtn.addEventListener('click', () => {
                formulaHelpModal.classList.remove('show');
            });
        }

        formulaHelpModal.addEventListener('click', (e) => {
            if (e.target === formulaHelpModal) {
                formulaHelpModal.classList.remove('show');
            }
        });
    }
}

// 更新状态说明弹窗的国际化文本
function updateTrackingStateModalI18n() {
    const isEn = currentLang === 'en';

    // 标题
    const title = document.getElementById('trackingStateModalTitle');
    if (title) title.textContent = isEn ? 'Time Tracking State Guide' : '时间捕捉状态说明';

    // 表头（图标在第一列）
    document.getElementById('stateTableHeaderIcon').textContent = isEn ? 'Icon' : '图标';
    document.getElementById('stateTableHeaderState').textContent = isEn ? 'State' : '状态';
    document.getElementById('stateTableHeaderCondition').textContent = isEn ? 'Condition' : '条件';
    document.getElementById('stateTableHeaderRate').textContent = isEn ? 'Rate' : '计时倍率';
    document.getElementById('stateTableHeaderExample').textContent = isEn ? 'Example' : '例子';

    // 表格内容
    document.getElementById('stateActiveLabel').textContent = isEn ? 'Active' : '活跃';
    document.getElementById('stateActiveCondition').textContent = isEn ? 'Current tab + Window focus + User active' : '当前标签 + 窗口焦点 + 用户活跃';
    document.getElementById('stateActiveExample').textContent = isEn ? 'Reading, scrolling, typing' : '正在阅读、滚动页面、打字';

    document.getElementById('stateIdleLabel').textContent = isEn ? 'Idle Focus' : '前台静止';
    document.getElementById('stateIdleCondition').textContent = isEn ? 'Current tab + Window focus + User idle' : '当前标签 + 窗口焦点 + 用户空闲';
    document.getElementById('stateIdleExample').textContent = isEn ? 'Watching video, thinking' : '静止观看视频、思考内容';

    document.getElementById('stateVisibleLabel').textContent = isEn ? 'Visible Ref' : '可见参考';
    document.getElementById('stateVisibleCondition').textContent = isEn ? 'Current tab + No window focus + User active' : '当前标签 + 窗口无焦点 + 用户活跃';
    document.getElementById('stateVisibleExample').textContent = isEn ? 'Split-screen reference, comparing code' : '分屏参考文档、对照代码';

    document.getElementById('stateBackgroundLabel').textContent = isEn ? 'Background' : '后台';
    document.getElementById('stateBackgroundCondition').textContent = isEn ? 'Not current tab + User active' : '非当前标签 + 用户活跃';
    document.getElementById('stateBackgroundExample').textContent = isEn ? 'Idle tab, background music' : '挂机、后台播放音乐';

    document.getElementById('stateSleepLabel').textContent = isEn ? 'Sleep' : '睡眠';
    document.getElementById('stateSleepCondition').textContent = isEn ? 'User idle (any tab)' : '用户空闲（任何标签）';
    document.getElementById('stateSleepExample').textContent = isEn ? 'Away from computer, screen locked, tab auto-sleep' : '离开电脑、锁屏、页面自动睡眠';

    // 综合时间公式
    const formulaEl = document.getElementById('trackingStateFormula');
    if (formulaEl) {
        formulaEl.textContent = isEn
            ? 'Composite = Active×1.0 + Idle×0.8 + Visible×0.5 + Background×0.1'
            : '综合时间 = 活跃×1.0 + 前台静止×0.8 + 可见参考×0.5 + 后台×0.1';
    }
}

// 更新公式说明弹窗的国际化文本
function updateFormulaHelpModalI18n() {
    const isEn = currentLang === 'en';

    // 标题
    const title = document.getElementById('formulaHelpModalTitle');
    if (title) title.textContent = isEn ? 'Formula Explanation' : '权重公式说明';

    // 通用公式
    const generalTitle = document.getElementById('formulaHelpGeneralTitle');
    if (generalTitle) generalTitle.textContent = isEn ? 'General Formula' : '通用公式';

    const codeEl = document.querySelector('.formula-help-code code');
    if (codeEl) codeEl.textContent = isEn
        ? 'Factor = 1 / (1 + (value / threshold)^0.7)'
        : '因子值 = 1 / (1 + (实际值 / 阈值)^0.7)';

    // 公式特点
    const featuresTitle = document.getElementById('formulaHelpFeaturesTitle');
    if (featuresTitle) featuresTitle.textContent = isEn ? 'Features' : '公式特点';

    document.getElementById('formulaHelpFeature1').innerHTML = isEn
        ? '<strong>At threshold = 0.5</strong>: When value equals threshold, factor is exactly 0.5'
        : '<strong>阈值处 = 0.5</strong>：当实际值等于阈值时，因子值正好是0.5';
    document.getElementById('formulaHelpFeature2').innerHTML = isEn
        ? '<strong>Smooth decay</strong>: Power function (^0.7) makes decay more gradual, avoiding hard cutoff'
        : '<strong>平滑衰减</strong>：使用幂函数(^0.7)使衰减更平缓，避免硬截断';
    document.getElementById('formulaHelpFeature3').innerHTML = isEn
        ? '<strong>Never zero</strong>: Even very large values retain small differentiation'
        : '<strong>永不归零</strong>：即使数值很大，仍保留微小区分度';
    document.getElementById('formulaHelpFeature4').innerHTML = isEn
        ? '<strong>Large value friendly</strong>: 1000 clicks still has 0.02 differentiation'
        : '<strong>大数值友好</strong>：1000次点击仍有0.02的区分度';

    // 效果示例
    const exampleTitle = document.getElementById('formulaHelpExampleTitle');
    if (exampleTitle) exampleTitle.textContent = isEn ? 'Examples' : '效果示例';

    document.getElementById('formulaHelpTableValue').textContent = isEn ? 'Value/Threshold' : '实际值/阈值';
    document.getElementById('formulaHelpTableResult').textContent = isEn ? 'Factor' : '因子值';
    document.getElementById('formulaHelpTableMeaning').textContent = isEn ? 'Meaning' : '含义';

    document.getElementById('formulaHelpThreshold').textContent = isEn ? '1×(threshold)' : '1×(阈值)';
    document.getElementById('formulaHelpMeaning1').textContent = isEn ? 'Highest priority' : '最高优先';
    document.getElementById('formulaHelpMeaning2').textContent = isEn ? 'Higher' : '较高';
    document.getElementById('formulaHelpMeaning3').textContent = isEn ? 'Medium' : '中等';
    document.getElementById('formulaHelpMeaning4').textContent = isEn ? 'Lower' : '较低';
    document.getElementById('formulaHelpMeaning5').textContent = isEn ? 'Very low' : '很低';
    document.getElementById('formulaHelpMeaning6').textContent = isEn ? 'Minimal but distinct' : '极低但仍有区分';

    // 注意事项
    const notesTitle = document.getElementById('formulaHelpNotesTitle');
    if (notesTitle) notesTitle.textContent = isEn ? 'Notes' : '注意事项';

    document.getElementById('formulaHelpNote1').innerHTML = isEn
        ? '<strong>F, C, T</strong> use inverse mode: larger value = smaller factor (e.g., more clicks = lower coldness)'
        : '<strong>F、C、T</strong> 使用 inverse 模式：值越大，因子越小（如点击越多，冷门度越低）';
    document.getElementById('formulaHelpNote2').innerHTML = isEn
        ? '<strong>D</strong> uses direct mode: more unvisited days = higher forgetting'
        : '<strong>D</strong> 使用正向模式：未访问天数越多，遗忘度越高';
    document.getElementById('formulaHelpNote3').innerHTML = isEn
        ? '<strong>L</strong> is boolean: manually added = 1, otherwise = 0'
        : '<strong>L</strong> 是布尔值：手动添加=1，否则=0';
}

// 推荐卡片数据
let recommendCards = [];
let trackingRefreshInterval = null;
let rankingRefreshInterval = null;  // 排行榜刷新定时器
const TRACKING_REFRESH_INTERVAL = 1000; // 1秒刷新一次当前会话，更实时
const RANKING_REFRESH_INTERVAL = 1000; // 1秒刷新一次排行榜，与正在追踪同步

// 跳过和屏蔽数据
let skippedBookmarks = new Set(); // 本次会话跳过的书签（内存，刷新页面后清空）

// 获取当前显示的卡片状态（与popup共享）
async function getHistoryCurrentCards() {
    return new Promise((resolve) => {
        browserAPI.storage.local.get(['popupCurrentCards'], (result) => {
            resolve(result.popupCurrentCards || null);
        });
    });
}

// 保存当前显示的卡片状态（与popup共享）
async function saveHistoryCurrentCards(cardIds, flippedIds, cardData = null) {
    // 标记本次保存时间，防止触发循环刷新
    historyLastSaveTime = Date.now();

    const dataToSave = {
        popupCurrentCards: {
            cardIds: cardIds,
            flippedIds: flippedIds,
            timestamp: Date.now()
        }
    };
    // 如果提供了卡片数据（包含url和favicon），也保存它们
    if (cardData && cardData.length > 0) {
        dataToSave.popupCurrentCards.cardData = cardData;
    }
    await browserAPI.storage.local.set(dataToSave);
}

// 异步获取并保存当前卡片的数据（含priority和favicon，供popup使用）
async function saveCardFaviconsToStorage(bookmarks) {
    if (!bookmarks || bookmarks.length === 0) return;

    try {
        // 获取当前保存的卡片状态
        const currentCards = await getHistoryCurrentCards();
        if (!currentCards || !currentCards.cardIds) return;

        // 为每个卡片获取favicon data URL和priority
        const cardData = await Promise.all(bookmarks.map(async (bookmark) => {
            if (!bookmark || !bookmark.url) {
                return { id: bookmark?.id, url: null, faviconUrl: null, priority: 0 };
            }
            try {
                const faviconUrl = await FaviconCache.fetch(bookmark.url);
                return {
                    id: bookmark.id,
                    url: bookmark.url,
                    faviconUrl: faviconUrl !== fallbackIcon ? faviconUrl : null,
                    priority: bookmark.priority || 0
                };
            } catch (e) {
                return { id: bookmark.id, url: bookmark.url, faviconUrl: null, priority: bookmark.priority || 0 };
            }
        }));

        // 更新storage中的卡片数据
        currentCards.cardData = cardData;
        historyLastSaveTime = Date.now(); // 防止触发循环刷新
        await browserAPI.storage.local.set({ popupCurrentCards: currentCards });
    } catch (error) {
        // 静默处理错误
    }
}

// 标记卡片为已勾选，并检查是否全部勾选
async function markHistoryCardFlipped(bookmarkId) {
    const currentCards = await getHistoryCurrentCards();
    if (!currentCards) return false;

    // 添加到已勾选列表
    if (!currentCards.flippedIds.includes(bookmarkId)) {
        currentCards.flippedIds.push(bookmarkId);
        await saveHistoryCurrentCards(currentCards.cardIds, currentCards.flippedIds);
    }

    // 检查是否全部勾选
    const allFlipped = currentCards.cardIds.every(id => currentCards.flippedIds.includes(id));
    return allFlipped;
}

// 更新单个卡片显示
function updateCardDisplay(card, bookmark, isFlipped = false) {
    card.classList.remove('empty');
    if (isFlipped) {
        card.classList.add('flipped');
    } else {
        card.classList.remove('flipped');
    }
    card.querySelector('.card-title').textContent = bookmark.title || bookmark.url;
    card.querySelector('.card-priority').textContent = `S = ${bookmark.priority.toFixed(2)}`;
    card.dataset.url = bookmark.url;
    card.dataset.bookmarkId = bookmark.id;

    // 设置 favicon
    const favicon = card.querySelector('.card-favicon');
    if (favicon && bookmark.url) {
        setHighResFavicon(favicon, bookmark.url);
    }

    // 点击卡片主体：打开链接 + 标记为已翻过 + 记录复习
    card.onclick = async (e) => {
        if (e.target.closest('.card-actions')) return;

        if (bookmark.url) {
            await markBookmarkFlipped(bookmark.id);
            await recordReview(bookmark.id);
            await openInRecommendWindow(bookmark.url);
            card.classList.add('flipped');

            // 更新本地卡片勾选状态（storage监听器会自动处理刷新）
            await markHistoryCardFlipped(bookmark.id);
        }
    };

    // 按钮事件：稍后复习
    const btnLater = card.querySelector('.card-btn-later');
    if (btnLater) {
        btnLater.onclick = (e) => {
            e.stopPropagation();
            e.preventDefault();
            showLaterModal(bookmark);
        };
    }

    // 按钮事件：跳过本次
    const btnSkip = card.querySelector('.card-btn-skip');
    if (btnSkip) {
        btnSkip.onclick = async (e) => {
            e.stopPropagation();
            e.preventDefault();
            skippedBookmarks.add(bookmark.id);
            await refreshRecommendCards(true);
        };
    }

    // 按钮事件：永久屏蔽
    const btnBlock = card.querySelector('.card-btn-block');
    if (btnBlock) {
        btnBlock.onclick = async (e) => {
            e.stopPropagation();
            e.preventDefault();
            await blockBookmark(bookmark.id);
            await loadBlockedLists();
            await refreshRecommendCards(true);
        };
    }
}

// 设置卡片为空状态
function setCardEmpty(card) {
    card.classList.add('empty');
    card.querySelector('.card-title').textContent = '--';
    card.querySelector('.card-priority').textContent = 'S = --';
    const favicon = card.querySelector('.card-favicon');
    if (favicon) {
        favicon.src = fallbackIcon;
    }
    card.onclick = null;

    const actions = card.querySelector('.card-actions');
    if (actions) {
        actions.querySelectorAll('.card-btn').forEach(btn => {
            btn.onclick = null;
        });
    }
}

// 获取已屏蔽书签
async function getBlockedBookmarks() {
    try {
        const result = await browserAPI.storage.local.get('recommend_blocked');
        return result.recommend_blocked || { bookmarks: [], folders: [], domains: [] };
    } catch (e) {
        console.error('[屏蔽] 获取屏蔽数据失败:', e);
        return { bookmarks: [], folders: [], domains: [] };
    }
}

// 屏蔽书签（按标题匹配，同名书签一起屏蔽）
async function blockBookmark(bookmarkId) {
    try {
        // 获取当前书签信息
        const bookmarks = await new Promise(resolve => {
            browserAPI.bookmarks.get(bookmarkId, resolve);
        });
        if (!bookmarks || bookmarks.length === 0) return false;
        const targetBookmark = bookmarks[0];
        const targetTitle = targetBookmark.title;

        // 获取所有书签
        const allBookmarks = await new Promise(resolve => {
            browserAPI.bookmarks.getTree(tree => {
                const result = [];
                function traverse(nodes) {
                    for (const node of nodes) {
                        if (node.url) result.push(node);
                        if (node.children) traverse(node.children);
                    }
                }
                traverse(tree);
                resolve(result);
            });
        });

        // 找到所有同标题的书签
        const sameTitle = allBookmarks.filter(b => b.title === targetTitle);

        const blocked = await getBlockedBookmarks();
        let blockedCount = 0;

        for (const b of sameTitle) {
            if (!blocked.bookmarks.includes(b.id)) {
                blocked.bookmarks.push(b.id);
                blockedCount++;
            }
        }

        await browserAPI.storage.local.set({ recommend_blocked: blocked });
        console.log('[屏蔽] 已屏蔽书签:', targetTitle, '共', blockedCount, '个');
        return true;
    } catch (e) {
        console.error('[屏蔽] 屏蔽书签失败:', e);
        return false;
    }
}

// 恢复屏蔽的书签
async function unblockBookmark(bookmarkId) {
    try {
        const blocked = await getBlockedBookmarks();
        blocked.bookmarks = blocked.bookmarks.filter(id => id !== bookmarkId);
        await browserAPI.storage.local.set({ recommend_blocked: blocked });
        console.log('[屏蔽] 已恢复书签:', bookmarkId);
        // 恢复后触发S值计算（该书签之前没有缓存）
        browserAPI.runtime.sendMessage({ action: 'updateBookmarkScore', bookmarkId });
        return true;
    } catch (e) {
        console.error('[屏蔽] 恢复书签失败:', e);
        return false;
    }
}

// 获取稍后复习数据
async function getPostponedBookmarks() {
    try {
        const result = await browserAPI.storage.local.get('recommend_postponed');
        return result.recommend_postponed || [];
    } catch (e) {
        console.error('[稍后] 获取稍后复习数据失败:', e);
        return [];
    }
}

// 添加稍后复习
async function postponeBookmark(bookmarkId, delayMs) {
    try {
        const postponed = await getPostponedBookmarks();
        const existing = postponed.find(p => p.bookmarkId === bookmarkId);
        const now = Date.now();

        if (existing) {
            existing.postponeUntil = now + delayMs;
            existing.postponeCount = (existing.postponeCount || 0) + 1;
            existing.updatedAt = now;
        } else {
            postponed.push({
                bookmarkId,
                postponeUntil: now + delayMs,
                postponeCount: 1,
                createdAt: now,
                updatedAt: now
            });
        }

        await browserAPI.storage.local.set({ recommend_postponed: postponed });
        console.log('[稍后] 已推迟书签:', bookmarkId, '延迟:', delayMs / 3600000, '小时');
        return true;
    } catch (e) {
        console.error('[稍后] 推迟书签失败:', e);
        return false;
    }
}

// 取消稍后复习
async function cancelPostpone(bookmarkId) {
    try {
        let postponed = await getPostponedBookmarks();
        const hadManualPostponed = postponed.some(p => p.manuallyAdded);

        postponed = postponed.filter(p => p.bookmarkId !== bookmarkId);
        await browserAPI.storage.local.set({ recommend_postponed: postponed });
        console.log('[稍后] 已取消推迟:', bookmarkId);

        // 检查取消后是否还有手动添加的待复习
        const hasManualPostponed = postponed.some(p => p.manuallyAdded);

        // 如果手动待复习从有变无，后续 loadPostponedList 会触发模式切换和全量重算
        // 此时不需要增量更新，避免重复计算
        if (hadManualPostponed && !hasManualPostponed && currentRecommendMode === 'priority') {
            console.log('[稍后] 待复习将清空，跳过增量更新（后续会全量重算）');
        } else {
            // L因子变化，发消息给background.js更新该书签的S值
            browserAPI.runtime.sendMessage({ action: 'updateBookmarkScore', bookmarkId });
        }

        return true;
    } catch (e) {
        console.error('[稍后] 取消推迟失败:', e);
        return false;
    }
}

// 清理过期的稍后复习记录
async function cleanExpiredPostponed() {
    try {
        let postponed = await getPostponedBookmarks();
        const now = Date.now();
        const before = postponed.length;
        postponed = postponed.filter(p => p.postponeUntil > now);
        if (postponed.length !== before) {
            await browserAPI.storage.local.set({ recommend_postponed: postponed });
            console.log('[稍后] 清理过期记录:', before - postponed.length, '条');
        }
    } catch (e) {
        console.error('[稍后] 清理过期记录失败:', e);
    }
}

// 稍后复习弹窗相关
let currentLaterBookmark = null;
let currentLaterRecommendedDays = 3; // P值推荐的天数

// 根据P值计算推荐间隔天数
function calculateRecommendedDays(priority, factors) {
    // P值高 → 更需要复习 → 间隔短
    // P值低 → 不太需要 → 间隔长
    const maxDays = 14;
    const minDays = 1;

    // 使用二次函数使分布更平滑
    let intervalDays = minDays + (maxDays - minDays) * Math.pow(1 - priority, 1.5);

    // 根据单个因子微调
    if (factors) {
        // D(遗忘度)特别高：很久没看了，缩短间隔
        if (factors.D > 0.8) intervalDays *= 0.7;
        // T(时间度/浅阅读)特别高：几乎没读过，缩短间隔
        if (factors.T > 0.9) intervalDays *= 0.8;
        // C(冷门度)特别高：很少点击，缩短间隔
        if (factors.C > 0.9) intervalDays *= 0.85;
    }

    return Math.max(minDays, Math.round(intervalDays));
}

// 格式化推荐天数显示
function formatRecommendDays(days) {
    const isZh = currentLang !== 'en';
    if (days === 1) {
        return isZh ? '明天' : 'Tomorrow';
    } else if (days <= 7) {
        return isZh ? `${days} 天后` : `${days} days`;
    } else if (days <= 14) {
        const weeks = Math.round(days / 7);
        return isZh ? `${weeks} 周后` : `${weeks} week${weeks > 1 ? 's' : ''}`;
    } else {
        return isZh ? `${days} 天后` : `${days} days`;
    }
}

function showLaterModal(bookmark) {
    currentLaterBookmark = bookmark;
    const modal = document.getElementById('laterModal');
    if (!modal) return;

    // 计算P值推荐的间隔
    if (bookmark.priority !== undefined && bookmark.factors) {
        currentLaterRecommendedDays = calculateRecommendedDays(bookmark.priority, bookmark.factors);
    } else {
        currentLaterRecommendedDays = 3; // 默认3天
    }

    // 更新推荐按钮显示
    const recommendDaysEl = document.getElementById('laterRecommendDays');
    if (recommendDaysEl) {
        recommendDaysEl.textContent = formatRecommendDays(currentLaterRecommendedDays);
    }

    modal.classList.add('show');
    console.log('[稍后] 显示弹窗:', bookmark.id, bookmark.title, '推荐间隔:', currentLaterRecommendedDays, '天');
}

function hideLaterModal() {
    const modal = document.getElementById('laterModal');
    if (modal) {
        modal.classList.remove('show');
    }
    currentLaterBookmark = null;
}

function initLaterModal() {
    const modal = document.getElementById('laterModal');
    if (!modal) return;

    // 关闭按钮
    const closeBtn = document.getElementById('laterModalClose');
    if (closeBtn) {
        closeBtn.onclick = hideLaterModal;
    }

    // 点击背景关闭
    modal.onclick = (e) => {
        if (e.target === modal) {
            hideLaterModal();
        }
    };

    // P值推荐按钮
    const recommendBtn = document.getElementById('laterRecommendBtn');
    if (recommendBtn) {
        recommendBtn.onclick = async () => {
            if (!currentLaterBookmark) return;

            const delayMs = currentLaterRecommendedDays * 24 * 60 * 60 * 1000;
            await postponeBookmark(currentLaterBookmark.id, delayMs);
            hideLaterModal();
            await loadPostponedList();
            await refreshRecommendCards();
        };
    }

    // 自定义选项按钮
    const options = modal.querySelectorAll('.later-option');
    options.forEach(option => {
        option.onclick = async () => {
            if (!currentLaterBookmark) return;

            const delayMs = parseInt(option.dataset.delay);
            await postponeBookmark(currentLaterBookmark.id, delayMs);
            hideLaterModal();
            await loadPostponedList();
            await refreshRecommendCards();
        };
    });
}

// =============================================================================
// 自动刷新设置
// =============================================================================

const DEFAULT_REFRESH_SETTINGS = {
    refreshEveryNOpens: 3,      // 默认每3次打开刷新
    refreshAfterHours: 0,       // 0=禁用
    refreshAfterDays: 0,        // 0=禁用
    lastRefreshTime: 0,
    openCountSinceRefresh: 0
};

async function getRefreshSettings() {
    try {
        const result = await browserAPI.storage.local.get('recommendRefreshSettings');
        return { ...DEFAULT_REFRESH_SETTINGS, ...result.recommendRefreshSettings };
    } catch (e) {
        console.error('[刷新设置] 读取失败:', e);
        return { ...DEFAULT_REFRESH_SETTINGS };
    }
}

async function saveRefreshSettings(settings) {
    try {
        await browserAPI.storage.local.set({ recommendRefreshSettings: settings });
        console.log('[刷新设置] 已保存:', settings);
    } catch (e) {
        console.error('[刷新设置] 保存失败:', e);
    }
}

// checkAutoRefresh 已移除：S值通过增量更新机制保持最新，不再需要定时全量重算
// 保留刷新设置UI用于记录上次刷新时间

function showRefreshSettingsModal() {
    const modal = document.getElementById('refreshSettingsModal');
    if (!modal) return;

    loadRefreshSettingsToUI();
    modal.classList.add('show');
}

function hideRefreshSettingsModal() {
    const modal = document.getElementById('refreshSettingsModal');
    if (modal) {
        modal.classList.remove('show');
    }
}

async function loadRefreshSettingsToUI() {
    const settings = await getRefreshSettings();

    // 每N次打开
    const everyNEnabled = document.getElementById('refreshEveryNOpensEnabled');
    const everyNValue = document.getElementById('refreshEveryNOpensValue');
    if (everyNEnabled) everyNEnabled.checked = settings.refreshEveryNOpens > 0;
    if (everyNValue) everyNValue.value = settings.refreshEveryNOpens || 3;

    // 超过X小时
    const hoursEnabled = document.getElementById('refreshAfterHoursEnabled');
    const hoursValue = document.getElementById('refreshAfterHoursValue');
    if (hoursEnabled) hoursEnabled.checked = settings.refreshAfterHours > 0;
    if (hoursValue) hoursValue.value = settings.refreshAfterHours || 1;

    // 超过X天
    const daysEnabled = document.getElementById('refreshAfterDaysEnabled');
    const daysValue = document.getElementById('refreshAfterDaysValue');
    if (daysEnabled) daysEnabled.checked = settings.refreshAfterDays > 0;
    if (daysValue) daysValue.value = settings.refreshAfterDays || 1;

    // 更新状态显示
    updateRefreshSettingsStatus(settings);
}

async function saveRefreshSettingsFromUI() {
    const settings = await getRefreshSettings();

    // 每N次打开
    const everyNEnabled = document.getElementById('refreshEveryNOpensEnabled');
    const everyNValue = document.getElementById('refreshEveryNOpensValue');
    settings.refreshEveryNOpens = everyNEnabled?.checked ? parseInt(everyNValue?.value) || 3 : 0;

    // 超过X小时
    const hoursEnabled = document.getElementById('refreshAfterHoursEnabled');
    const hoursValue = document.getElementById('refreshAfterHoursValue');
    settings.refreshAfterHours = hoursEnabled?.checked ? parseInt(hoursValue?.value) || 1 : 0;

    // 超过X天
    const daysEnabled = document.getElementById('refreshAfterDaysEnabled');
    const daysValue = document.getElementById('refreshAfterDaysValue');
    settings.refreshAfterDays = daysEnabled?.checked ? parseInt(daysValue?.value) || 1 : 0;

    await saveRefreshSettings(settings);
    hideRefreshSettingsModal();
}

function updateRefreshSettingsStatus(settings) {
    const statusEl = document.getElementById('refreshSettingsStatus');
    if (!statusEl) return;

    const isZh = currentLang !== 'en';
    const parts = [];

    // 上次刷新时间
    if (settings.lastRefreshTime > 0) {
        const elapsed = Date.now() - settings.lastRefreshTime;
        const minutes = Math.floor(elapsed / 60000);
        const hours = Math.floor(elapsed / 3600000);
        const days = Math.floor(elapsed / 86400000);

        let timeStr;
        if (days > 0) {
            timeStr = isZh ? `${days} 天前` : `${days} day${days > 1 ? 's' : ''} ago`;
        } else if (hours > 0) {
            timeStr = isZh ? `${hours} 小时前` : `${hours} hour${hours > 1 ? 's' : ''} ago`;
        } else {
            timeStr = isZh ? `${minutes} 分钟前` : `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        }
        parts.push(isZh ? `上次刷新: ${timeStr}` : `Last refresh: ${timeStr}`);
    } else {
        parts.push(isZh ? '尚未刷新' : 'Not refreshed yet');
    }

    // 打开次数
    if (settings.refreshEveryNOpens > 0) {
        const count = settings.openCountSinceRefresh || 0;
        parts.push(isZh
            ? `已打开 ${count} / ${settings.refreshEveryNOpens} 次`
            : `Opened ${count} / ${settings.refreshEveryNOpens} times`);
    }

    statusEl.textContent = parts.join(' | ');
}

function initRefreshSettingsModal() {
    const modal = document.getElementById('refreshSettingsModal');
    if (!modal) return;

    // 关闭按钮
    const closeBtn = document.getElementById('refreshSettingsClose');
    if (closeBtn) {
        closeBtn.onclick = hideRefreshSettingsModal;
    }

    // 点击背景关闭
    modal.onclick = (e) => {
        if (e.target === modal) {
            hideRefreshSettingsModal();
        }
    };

    // 保存按钮
    const saveBtn = document.getElementById('refreshSettingsSaveBtn');
    if (saveBtn) {
        saveBtn.onclick = saveRefreshSettingsFromUI;
    }
}

let addBlockDomainSelected = new Set();
let addBlockDomainData = [];

// 初始化添加域名弹窗
function initAddDomainModal() {
    const modal = document.getElementById('addDomainModal');
    if (!modal) return;

    const closeBtn = document.getElementById('addDomainModalClose');
    const cancelBtn = document.getElementById('addDomainCancelBtn');
    const confirmBtn = document.getElementById('addDomainConfirmBtn');
    const searchInput = document.getElementById('addBlockDomainSearchInput');

    const hideModal = () => {
        modal.classList.remove('show');
        if (searchInput) searchInput.value = '';
    };

    if (closeBtn) closeBtn.onclick = hideModal;
    if (cancelBtn) cancelBtn.onclick = hideModal;

    modal.onclick = (e) => {
        if (e.target === modal) hideModal();
    };

    // 搜索输入
    let searchTimer = null;
    if (searchInput) {
        searchInput.oninput = () => {
            clearTimeout(searchTimer);
            searchTimer = setTimeout(() => {
                filterBlockDomainList(searchInput.value);
            }, 200);
        };
        // Allow Enter to confirm
        searchInput.onkeypress = (e) => {
            if (e.key === 'Enter') confirmBtn.click();
        };
    }

    if (confirmBtn) {
        confirmBtn.onclick = async () => {
            const selectedDomains = Array.from(addBlockDomainSelected);

            // Allow manual entry if not in list
            const inputVal = searchInput ? searchInput.value.trim() : '';
            if (inputVal && !addBlockDomainSelected.has(inputVal)) {
                if (inputVal.includes('.') || inputVal.includes('localhost')) {
                    selectedDomains.push(inputVal);
                }
            }

            if (selectedDomains.length > 0) {
                for (const domain of selectedDomains) {
                    await blockDomain(domain);
                }
                hideModal();
                await loadBlockedLists();
                await refreshRecommendCards();
            } else {
                const isZh = currentLang === 'zh_CN';
                alert(isZh ? '请选择或输入要屏蔽的域名' : 'Please select or enter a domain to block');
            }
        };
    }
}

// 初始化选择文件夹弹窗
function initSelectFolderModal() {
    const modal = document.getElementById('selectFolderModal');
    if (!modal) return;

    const closeBtn = document.getElementById('selectFolderModalClose');

    const hideModal = () => {
        modal.classList.remove('show');
    };

    if (closeBtn) closeBtn.onclick = hideModal;

    modal.onclick = (e) => {
        if (e.target === modal) hideModal();
    };
}

// 显示添加域名弹窗
async function showAddDomainModal() {
    const modal = document.getElementById('addDomainModal');
    if (modal) {
        addBlockDomainSelected.clear();
        updateBlockDomainCount();
        const searchInput = document.getElementById('addBlockDomainSearchInput');
        if (searchInput) {
            searchInput.value = '';
            searchInput.focus();
        }

        modal.classList.add('show');
        await loadBlockDomainList();
    }
}

// 加载屏蔽域名列表
async function loadBlockDomainList() {
    const listEl = document.getElementById('addBlockDomainList');
    if (!listEl) return;

    const isZh = currentLang === 'zh_CN';
    listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载中...' : 'Loading...'}</div>`;

    try {
        const allBookmarks = await getAllBookmarksFlat();
        const blocked = await getBlockedBookmarks();
        const blockedDomains = new Set(blocked.domains);

        const domainMap = new Map();
        for (const b of allBookmarks) {
            if (!b.url) continue;
            try {
                const url = new URL(b.url);
                const domain = url.hostname;
                if (!domainMap.has(domain)) {
                    domainMap.set(domain, { count: 0 });
                }
                domainMap.get(domain).count++;
            } catch { }
        }

        const validDomains = [];
        for (const [domain, data] of domainMap.entries()) {
            if (!blockedDomains.has(domain)) {
                validDomains.push([domain, data]);
            }
        }

        addBlockDomainData = validDomains.sort((a, b) => b[1].count - a[1].count);
        renderBlockDomainList(addBlockDomainData);

    } catch (e) {
        console.error('Failed to load domains', e);
        const isZh = currentLang === 'zh_CN';
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载失败' : 'Failed to load'}</div>`;
    }
}

// 渲染屏蔽域名列表
function renderBlockDomainList(domains) {
    const listEl = document.getElementById('addBlockDomainList');
    if (!listEl) return;

    const displayDomains = domains.slice(0, 100);
    const isZh = currentLang === 'zh_CN';

    if (displayDomains.length === 0) {
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '没有可屏蔽的新域名' : 'No new domains to block'}</div>`;
        return;
    }

    listEl.innerHTML = displayDomains.map(([domain, data]) => `
        <div class="add-domain-item ${addBlockDomainSelected.has(domain) ? 'selected' : ''}" data-domain="${escapeHtml(domain)}">
            <input type="checkbox" ${addBlockDomainSelected.has(domain) ? 'checked' : ''}>
            <div class="add-domain-info">
                <div class="add-domain-name">${escapeHtml(domain)}</div>
                <div class="add-domain-count">${data.count} ${isZh ? '个书签' : 'bookmarks'}</div>
            </div>
        </div>
    `).join('');

    listEl.querySelectorAll('.add-domain-item').forEach(item => {
        item.addEventListener('click', () => {
            const domain = item.dataset.domain;
            const checkbox = item.querySelector('input[type="checkbox"]');
            if (addBlockDomainSelected.has(domain)) {
                addBlockDomainSelected.delete(domain);
                item.classList.remove('selected');
                checkbox.checked = false;
            } else {
                addBlockDomainSelected.add(domain);
                item.classList.add('selected');
                checkbox.checked = true;
            }
            updateBlockDomainCount();
        });
    });
}

// 过滤屏蔽域名列表
function filterBlockDomainList(keyword) {
    if (!keyword.trim()) {
        renderBlockDomainList(addBlockDomainData);
        return;
    }
    const keywordLower = keyword.toLowerCase();
    const filtered = addBlockDomainData.filter(([domain]) =>
        domain.toLowerCase().includes(keywordLower)
    );
    renderBlockDomainList(filtered);
}

// 更新选中数量
function updateBlockDomainCount() {
    const el = document.getElementById('addBlockDomainSelectedCount');
    if (el) el.textContent = addBlockDomainSelected.size;
}

// 显示选择文件夹弹窗
async function showSelectFolderModal() {
    const modal = document.getElementById('selectFolderModal');
    const container = document.getElementById('folderTreeContainer');
    if (!modal || !container) return;

    // 获取已屏蔽的文件夹
    const blocked = await getBlockedBookmarks();
    const blockedFolderSet = new Set(blocked.folders);

    // 获取所有文件夹
    const tree = await new Promise(resolve => {
        browserAPI.bookmarks.getTree(resolve);
    });

    // 生成文件夹树HTML
    container.innerHTML = '';

    function countBookmarks(node) {
        let count = 0;
        if (node.url) count = 1;
        if (node.children) {
            for (const child of node.children) {
                count += countBookmarks(child);
            }
        }
        return count;
    }

    function renderFolders(nodes, parentEl, depth = 0) {
        const isZh = currentLang === 'zh_CN';
        const unnamedFolder = i18n.unnamedFolderLabel ? i18n.unnamedFolderLabel[currentLang] : '未命名文件夹';
        for (const node of nodes) {
            if (!node.url && node.children) { // 是文件夹
                if (blockedFolderSet.has(node.id)) continue; // 已屏蔽的不显示

                const bookmarkCount = countBookmarks(node);

                // 创建节点包装
                const nodeWrapper = document.createElement('div');
                nodeWrapper.className = 'folder-tree-node';

                const item = document.createElement('div');
                item.className = 'folder-tree-item';
                item.innerHTML = `
                    <i class="fas fa-folder"></i>
                    <span>${escapeHtml(node.title || unnamedFolder)}</span>
                    <span class="folder-count">${bookmarkCount}</span>
                `;
                item.onclick = async () => {
                    await blockFolder(node.id);
                    modal.classList.remove('show');
                    await loadBlockedLists();
                    await refreshRecommendCards();
                };
                nodeWrapper.appendChild(item);

                // 检查是否有子文件夹
                const childFolders = node.children.filter(c => !c.url && c.children && !blockedFolderSet.has(c.id));
                if (childFolders.length > 0) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = 'folder-tree-children';
                    renderFolders(node.children, childrenContainer, depth + 1);
                    nodeWrapper.appendChild(childrenContainer);
                }

                parentEl.appendChild(nodeWrapper);
            }
        }
    }

    renderFolders(tree, container);
    modal.classList.add('show');
}

// 初始化屏蔽管理添加按钮
function initBlockManageButtons() {
    const addFolderBtn = document.getElementById('addBlockFolderBtn');
    const addDomainBtn = document.getElementById('addBlockDomainBtn');

    if (addFolderBtn) {
        addFolderBtn.onclick = () => showSelectFolderModal();
    }

    if (addDomainBtn) {
        addDomainBtn.onclick = () => showAddDomainModal();
    }
}

// =============================================================================
// 时间追踪屏蔽管理
// =============================================================================

let trackingBlockDomainSelected = new Set();
let trackingBlockDomainData = [];

// 获取时间追踪屏蔽列表
async function getTrackingBlocked() {
    try {
        const result = await new Promise(resolve => {
            browserAPI.storage.local.get(['timetracking_blocked'], resolve);
        });
        return result.timetracking_blocked || {
            bookmarks: [],
            folders: [],
            domains: []
        };
    } catch (e) {
        return { bookmarks: [], folders: [], domains: [] };
    }
}

function normalizeTrackingDomain(domain) {
    if (!domain || typeof domain !== 'string') return '';
    return domain.trim().toLowerCase().replace(/^www\./, '');
}

function normalizeTrackingUrl(url) {
    if (!url || typeof url !== 'string') return null;
    try {
        const parsed = new URL(url);
        if (!['http:', 'https:'].includes(parsed.protocol)) return null;
        let normalized = parsed.origin + parsed.pathname;
        if (parsed.search) {
            normalized += parsed.search;
        }
        normalized = normalized.replace(/\/+$/, '');
        return normalized.toLowerCase();
    } catch {
        return null;
    }
}

let trackingBookmarkCache = {
    loadedAt: 0,
    idToParents: new Map(),
    urlToIds: new Map()
};

async function getTrackingBookmarkCache() {
    const now = Date.now();
    if (trackingBookmarkCache.loadedAt && (now - trackingBookmarkCache.loadedAt) < 60 * 1000) {
        return trackingBookmarkCache;
    }

    const idToParents = new Map();
    const urlToIds = new Map();

    try {
        const tree = await browserAPI.bookmarks.getTree();
        const traverse = (nodes, ancestors = []) => {
            for (const node of nodes) {
                if (node.url) {
                    idToParents.set(node.id, ancestors);
                    const normalizedUrl = normalizeTrackingUrl(node.url);
                    if (normalizedUrl) {
                        if (!urlToIds.has(normalizedUrl)) {
                            urlToIds.set(normalizedUrl, new Set());
                        }
                        urlToIds.get(normalizedUrl).add(node.id);
                    }
                }
                if (node.children) {
                    const nextAncestors = node.url ? ancestors : [...ancestors, node.id];
                    traverse(node.children, nextAncestors);
                }
            }
        };
        traverse(tree, []);
    } catch (e) {
        console.warn('[时间追踪屏蔽] 构建书签缓存失败:', e);
    }

    trackingBookmarkCache = {
        loadedAt: now,
        idToParents,
        urlToIds
    };

    return trackingBookmarkCache;
}

async function getTrackingBlockedSets() {
    const blocked = await getTrackingBlocked();
    return {
        bookmarks: new Set(blocked.bookmarks || []),
        folders: new Set(blocked.folders || []),
        domains: new Set((blocked.domains || []).map(normalizeTrackingDomain).filter(Boolean))
    };
}

function isBookmarkIdBlockedByFolders(bookmarkId, blockedFolders, cache) {
    if (!bookmarkId || blockedFolders.size === 0) return false;
    const parentIds = cache.idToParents.get(bookmarkId) || [];
    for (const parentId of parentIds) {
        if (blockedFolders.has(parentId)) return true;
    }
    return false;
}

async function isTrackingItemBlocked(item, blockedSets, cache) {
    if (item.bookmarkId && blockedSets.bookmarks.has(item.bookmarkId)) {
        return true;
    }

    if (item.bookmarkId && isBookmarkIdBlockedByFolders(item.bookmarkId, blockedSets.folders, cache)) {
        return true;
    }

    if (item.url && blockedSets.domains.size > 0) {
        try {
            const domain = normalizeTrackingDomain(new URL(item.url).hostname);
            if (domain && blockedSets.domains.has(domain)) {
                return true;
            }
        } catch { }
    }

    if (!item.bookmarkId && item.url) {
        const normalizedUrl = normalizeTrackingUrl(item.url);
        if (normalizedUrl && cache.urlToIds.has(normalizedUrl)) {
            for (const id of cache.urlToIds.get(normalizedUrl)) {
                if (blockedSets.bookmarks.has(id)) return true;
                if (isBookmarkIdBlockedByFolders(id, blockedSets.folders, cache)) return true;
            }
        }
    }

    return false;
}

// 检查书签是否被时间追踪屏蔽
async function isTrackingBlocked(bookmark) {
    const blocked = await getTrackingBlocked();
    const blockedDomains = new Set((blocked.domains || []).map(normalizeTrackingDomain).filter(Boolean));

    // 检查书签ID
    if (blocked.bookmarks.includes(bookmark.id)) {
        return true;
    }

    // 检查文件夹
    if (bookmark.parentId && blocked.folders.includes(bookmark.parentId)) {
        return true;
    }
    if (bookmark.ancestorFolderIds && bookmark.ancestorFolderIds.length > 0) {
        for (const folderId of bookmark.ancestorFolderIds) {
            if (blocked.folders.includes(folderId)) return true;
        }
    }

    // 检查域名
    if (bookmark.url) {
        try {
            const url = new URL(bookmark.url);
            if (blockedDomains.has(normalizeTrackingDomain(url.hostname))) {
                return true;
            }
        } catch { }
    }

    return false;
}

// 屏蔽/恢复书签（时间追踪）
async function blockTrackingBookmark(bookmarkId) {
    try {
        const blocked = await getTrackingBlocked();
        if (!blocked.bookmarks.includes(bookmarkId)) {
            blocked.bookmarks.push(bookmarkId);
            await browserAPI.storage.local.set({ timetracking_blocked: blocked });
        }
        return true;
    } catch (e) {
        return false;
    }
}

async function unblockTrackingBookmark(bookmarkId) {
    try {
        const blocked = await getTrackingBlocked();
        blocked.bookmarks = blocked.bookmarks.filter(id => id !== bookmarkId);
        await browserAPI.storage.local.set({ timetracking_blocked: blocked });
        return true;
    } catch (e) {
        return false;
    }
}

// 屏蔽/恢复文件夹（时间追踪）
async function blockTrackingFolder(folderId) {
    try {
        const blocked = await getTrackingBlocked();
        if (!blocked.folders.includes(folderId)) {
            blocked.folders.push(folderId);
            await browserAPI.storage.local.set({ timetracking_blocked: blocked });
        }
        return true;
    } catch (e) {
        return false;
    }
}

async function unblockTrackingFolder(folderId) {
    try {
        const blocked = await getTrackingBlocked();
        blocked.folders = blocked.folders.filter(id => id !== folderId);
        await browserAPI.storage.local.set({ timetracking_blocked: blocked });
        return true;
    } catch (e) {
        return false;
    }
}

// 屏蔽/恢复域名（时间追踪）
async function blockTrackingDomain(domain) {
    try {
        const blocked = await getTrackingBlocked();
        const normalized = normalizeTrackingDomain(domain);
        if (!normalized) return false;
        if (!blocked.domains.includes(normalized)) {
            blocked.domains.push(normalized);
            await browserAPI.storage.local.set({ timetracking_blocked: blocked });
        }
        return true;
    } catch (e) {
        return false;
    }
}

async function unblockTrackingDomain(domain) {
    try {
        const blocked = await getTrackingBlocked();
        const normalized = normalizeTrackingDomain(domain);
        blocked.domains = blocked.domains.filter(d => d !== normalized);
        await browserAPI.storage.local.set({ timetracking_blocked: blocked });
        return true;
    } catch (e) {
        return false;
    }
}

// 初始化时间追踪屏蔽管理弹窗
function initTrackingBlockModal() {
    const modal = document.getElementById('trackingBlockModal');
    const blockBtn = document.getElementById('trackingBlockBtn');
    const closeBtn = document.getElementById('trackingBlockModalClose');
    const addFolderBtn = document.getElementById('addTrackingBlockFolderBtn');
    const addDomainBtn = document.getElementById('addTrackingBlockDomainBtn');
    const addBookmarkBtn = document.getElementById('addTrackingBlockBookmarkBtn');

    console.log('[时间追踪屏蔽] 初始化屏蔽管理弹窗, modal:', !!modal, ', blockBtn:', !!blockBtn);

    if (!modal) {
        console.warn('[时间追踪屏蔽] 弹窗元素未找到');
        return;
    }

    // 打开弹窗
    if (blockBtn) {
        blockBtn.onclick = async () => {
            console.log('[时间追踪屏蔽] 点击屏蔽按钮');
            await loadTrackingBlockedLists();
            modal.classList.add('show');
        };
        console.log('[时间追踪屏蔽] 屏蔽按钮事件已绑定');
    } else {
        console.warn('[时间追踪屏蔽] 屏蔽按钮元素未找到');
    }

    // 关闭弹窗
    const hideModal = () => modal.classList.remove('show');
    if (closeBtn) closeBtn.onclick = hideModal;
    modal.onclick = (e) => {
        if (e.target === modal) hideModal();
    };

    // 添加书签按钮
    if (addBookmarkBtn) {
        addBookmarkBtn.onclick = () => showAddTrackingBlockBookmarkModal();
    }

    // 添加文件夹按钮
    if (addFolderBtn) {
        addFolderBtn.onclick = () => showSelectTrackingBlockFolderModal();
    }

    // 添加域名按钮
    if (addDomainBtn) {
        addDomainBtn.onclick = () => showAddTrackingBlockDomainModal();
    }
}

// 加载时间追踪屏蔽列表
async function loadTrackingBlockedLists() {
    const blocked = await getTrackingBlocked();

    // 加载已屏蔽书签
    await loadTrackingBlockedBookmarksList(blocked.bookmarks);

    // 加载已屏蔽文件夹
    await loadTrackingBlockedFoldersList(blocked.folders);

    // 加载已屏蔽域名
    await loadTrackingBlockedDomainsList(blocked.domains);
}

// 加载已屏蔽书签列表（时间追踪）
async function loadTrackingBlockedBookmarksList(bookmarkIds) {
    const listEl = document.getElementById('trackingBlockedBookmarksList');
    const countEl = document.getElementById('trackingBlockedBookmarksCount');
    const emptyEl = document.getElementById('trackingBlockedBookmarksEmpty');
    if (!listEl) return;

    // 更新计数
    if (countEl) countEl.textContent = bookmarkIds.length;

    // 清空列表
    const items = listEl.querySelectorAll('.block-item');
    items.forEach(item => item.remove());

    if (bookmarkIds.length === 0) {
        if (emptyEl) emptyEl.style.display = 'block';
        return;
    }

    if (emptyEl) emptyEl.style.display = 'none';

    const isZh = currentLang === 'zh_CN';

    for (const id of bookmarkIds) {
        try {
            const bookmarks = await new Promise(resolve => {
                browserAPI.bookmarks.get(id, resolve);
            });
            if (!bookmarks || bookmarks.length === 0) continue;
            const bookmark = bookmarks[0];

            const item = document.createElement('div');
            item.className = 'block-item';
            item.innerHTML = `
                <img class="block-item-icon" src="${getFaviconUrl(bookmark.url)}" alt="">
                <div class="block-item-info">
                    <div class="block-item-title">${escapeHtml(bookmark.title || bookmark.url)}</div>
                </div>
                <button class="block-item-btn">${isZh ? '恢复' : 'Restore'}</button>
            `;

            const btn = item.querySelector('.block-item-btn');
            btn.onclick = async () => {
                await unblockTrackingBookmark(id);
                await loadTrackingBlockedLists();
            };

            listEl.appendChild(item);
        } catch (e) { }
    }
}

// 加载已屏蔽文件夹列表（时间追踪）
async function loadTrackingBlockedFoldersList(folderIds) {
    const listEl = document.getElementById('trackingBlockedFoldersList');
    const countEl = document.getElementById('trackingBlockedFoldersCount');
    const emptyEl = document.getElementById('trackingBlockedFoldersEmpty');
    if (!listEl) return;

    if (countEl) countEl.textContent = folderIds.length;

    const items = listEl.querySelectorAll('.block-item');
    items.forEach(item => item.remove());

    if (folderIds.length === 0) {
        if (emptyEl) emptyEl.style.display = 'block';
        return;
    }

    if (emptyEl) emptyEl.style.display = 'none';

    const isZh = currentLang === 'zh_CN';

    for (const id of folderIds) {
        try {
            const folders = await new Promise(resolve => {
                browserAPI.bookmarks.get(id, resolve);
            });
            if (!folders || folders.length === 0) continue;
            const folder = folders[0];

            const item = document.createElement('div');
            item.className = 'block-item';
            item.innerHTML = `
                <i class="fas fa-folder block-item-icon" style="font-size: 18px; color: var(--warning);"></i>
                <div class="block-item-info">
                    <div class="block-item-title">${escapeHtml(folder.title)}</div>
                </div>
                <button class="block-item-btn" data-id="${id}">${isZh ? '恢复' : 'Restore'}</button>
            `;

            const btn = item.querySelector('.block-item-btn');
            btn.onclick = async () => {
                await unblockTrackingFolder(id);
                await loadTrackingBlockedLists();
            };

            listEl.appendChild(item);
        } catch (e) { }
    }
}

// 加载已屏蔽域名列表（时间追踪）
async function loadTrackingBlockedDomainsList(domains) {
    const listEl = document.getElementById('trackingBlockedDomainsList');
    const countEl = document.getElementById('trackingBlockedDomainsCount');
    const emptyEl = document.getElementById('trackingBlockedDomainsEmpty');
    if (!listEl) return;

    if (countEl) countEl.textContent = domains.length;

    const items = listEl.querySelectorAll('.block-item');
    items.forEach(item => item.remove());

    if (domains.length === 0) {
        if (emptyEl) emptyEl.style.display = 'block';
        return;
    }

    if (emptyEl) emptyEl.style.display = 'none';

    const isZh = currentLang === 'zh_CN';

    for (const domain of domains) {
        const item = document.createElement('div');
        item.className = 'block-item';
        item.innerHTML = `
            <i class="fas fa-globe block-item-icon" style="font-size: 18px; color: var(--accent-primary);"></i>
            <div class="block-item-info">
                <div class="block-item-title">${escapeHtml(domain)}</div>
            </div>
            <button class="block-item-btn" data-domain="${domain}">${isZh ? '恢复' : 'Restore'}</button>
        `;

        const btn = item.querySelector('.block-item-btn');
        btn.onclick = async () => {
            await unblockTrackingDomain(domain);
            await loadTrackingBlockedLists();
        };

        listEl.appendChild(item);
    }
}

// 显示选择文件夹弹窗（时间追踪）
async function showSelectTrackingBlockFolderModal() {
    const modal = document.getElementById('selectTrackingBlockFolderModal');
    const container = document.getElementById('trackingBlockFolderTreeContainer');
    if (!modal || !container) return;

    // 获取已屏蔽的文件夹
    const blocked = await getTrackingBlocked();
    const blockedFolderSet = new Set(blocked.folders);

    // 获取所有文件夹
    const tree = await new Promise(resolve => {
        browserAPI.bookmarks.getTree(resolve);
    });

    // 生成文件夹树HTML
    container.innerHTML = '';

    function countBookmarks(node) {
        let count = 0;
        if (node.url) count = 1;
        if (node.children) {
            for (const child of node.children) {
                count += countBookmarks(child);
            }
        }
        return count;
    }

    function renderFolders(nodes, parentEl, depth = 0) {
        const isZh = currentLang === 'zh_CN';
        const unnamedFolder = i18n.unnamedFolderLabel ? i18n.unnamedFolderLabel[currentLang] : '未命名文件夹';
        for (const node of nodes) {
            if (!node.url && node.children) {
                if (blockedFolderSet.has(node.id)) continue;

                const bookmarkCount = countBookmarks(node);

                const nodeWrapper = document.createElement('div');
                nodeWrapper.className = 'folder-tree-node';

                const item = document.createElement('div');
                item.className = 'folder-tree-item';
                item.innerHTML = `
                    <i class="fas fa-folder"></i>
                    <span>${escapeHtml(node.title || unnamedFolder)}</span>
                    <span class="folder-count">${bookmarkCount}</span>
                `;
                item.onclick = async () => {
                    await blockTrackingFolder(node.id);
                    modal.classList.remove('show');
                    await loadTrackingBlockedLists();
                };
                nodeWrapper.appendChild(item);

                const childFolders = node.children.filter(c => !c.url && c.children && !blockedFolderSet.has(c.id));
                if (childFolders.length > 0) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = 'folder-tree-children';
                    renderFolders(node.children, childrenContainer, depth + 1);
                    nodeWrapper.appendChild(childrenContainer);
                }

                parentEl.appendChild(nodeWrapper);
            }
        }
    }

    renderFolders(tree, container);
    modal.classList.add('show');
}

// 初始化选择文件夹弹窗（时间追踪）
function initSelectTrackingBlockFolderModal() {
    const modal = document.getElementById('selectTrackingBlockFolderModal');
    if (!modal) return;

    const closeBtn = document.getElementById('selectTrackingBlockFolderModalClose');

    const hideModal = () => modal.classList.remove('show');

    if (closeBtn) closeBtn.onclick = hideModal;

    modal.onclick = (e) => {
        if (e.target === modal) hideModal();
    };
}

// 显示添加域名弹窗（时间追踪）
async function showAddTrackingBlockDomainModal() {
    const modal = document.getElementById('addTrackingBlockDomainModal');
    if (modal) {
        trackingBlockDomainSelected.clear();
        updateTrackingBlockDomainCount();
        const searchInput = document.getElementById('addTrackingBlockDomainSearchInput');
        if (searchInput) {
            searchInput.value = '';
            searchInput.focus();
        }

        modal.classList.add('show');
        await loadTrackingBlockDomainList();
    }
}

// 加载屏蔽域名列表（时间追踪）
async function loadTrackingBlockDomainList() {
    const listEl = document.getElementById('addTrackingBlockDomainList');
    if (!listEl) return;

    const isZh = currentLang === 'zh_CN';
    listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载中...' : 'Loading...'}</div>`;

    try {
        const allBookmarks = await getAllBookmarksFlat();
        const blocked = await getTrackingBlocked();
        const blockedDomains = new Set((blocked.domains || []).map(normalizeTrackingDomain).filter(Boolean));

        const domainMap = new Map();
        for (const b of allBookmarks) {
            if (!b.url) continue;
            try {
                const url = new URL(b.url);
                const domain = normalizeTrackingDomain(url.hostname);
                if (!domain) continue;
                if (!domainMap.has(domain)) {
                    domainMap.set(domain, { count: 0 });
                }
                domainMap.get(domain).count++;
            } catch { }
        }

        const validDomains = [];
        for (const [domain, data] of domainMap.entries()) {
            if (!blockedDomains.has(domain)) {
                validDomains.push([domain, data]);
            }
        }

        trackingBlockDomainData = validDomains.sort((a, b) => b[1].count - a[1].count);
        renderTrackingBlockDomainList(trackingBlockDomainData);

    } catch (e) {
        console.error('Failed to load domains', e);
        const isZh = currentLang === 'zh_CN';
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载失败' : 'Failed to load'}</div>`;
    }
}

// 渲染屏蔽域名列表（时间追踪）
function renderTrackingBlockDomainList(domains) {
    const listEl = document.getElementById('addTrackingBlockDomainList');
    if (!listEl) return;

    const displayDomains = domains.slice(0, 100);
    const isZh = currentLang === 'zh_CN';

    if (displayDomains.length === 0) {
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '没有可屏蔽的新域名' : 'No new domains to block'}</div>`;
        return;
    }

    listEl.innerHTML = displayDomains.map(([domain, data]) => `
        <div class="add-domain-item ${trackingBlockDomainSelected.has(domain) ? 'selected' : ''}" data-domain="${escapeHtml(domain)}">
            <input type="checkbox" ${trackingBlockDomainSelected.has(domain) ? 'checked' : ''}>
            <div class="add-domain-info">
                <div class="add-domain-name">${escapeHtml(domain)}</div>
                <div class="add-domain-count">${data.count} ${isZh ? '个书签' : 'bookmarks'}</div>
            </div>
        </div>
    `).join('');

    listEl.querySelectorAll('.add-domain-item').forEach(item => {
        item.addEventListener('click', () => {
            const domain = item.dataset.domain;
            const checkbox = item.querySelector('input[type="checkbox"]');
            if (trackingBlockDomainSelected.has(domain)) {
                trackingBlockDomainSelected.delete(domain);
                item.classList.remove('selected');
                checkbox.checked = false;
            } else {
                trackingBlockDomainSelected.add(domain);
                item.classList.add('selected');
                checkbox.checked = true;
            }
            updateTrackingBlockDomainCount();
        });
    });
}

// 过滤屏蔽域名列表（时间追踪）
function filterTrackingBlockDomainList(keyword) {
    if (!keyword.trim()) {
        renderTrackingBlockDomainList(trackingBlockDomainData);
        return;
    }
    const keywordLower = keyword.toLowerCase();
    const filtered = trackingBlockDomainData.filter(([domain]) =>
        domain.toLowerCase().includes(keywordLower)
    );
    renderTrackingBlockDomainList(filtered);
}

// 更新选中数量（时间追踪）
function updateTrackingBlockDomainCount() {
    const el = document.getElementById('addTrackingBlockDomainSelectedCount');
    if (el) el.textContent = trackingBlockDomainSelected.size;
}

// 初始化添加域名弹窗（时间追踪）
function initAddTrackingBlockDomainModal() {
    const modal = document.getElementById('addTrackingBlockDomainModal');
    if (!modal) return;

    const closeBtn = document.getElementById('addTrackingBlockDomainModalClose');
    const cancelBtn = document.getElementById('addTrackingBlockDomainCancelBtn');
    const confirmBtn = document.getElementById('addTrackingBlockDomainConfirmBtn');
    const searchInput = document.getElementById('addTrackingBlockDomainSearchInput');

    const hideModal = () => {
        modal.classList.remove('show');
        if (searchInput) searchInput.value = '';
    };

    if (closeBtn) closeBtn.onclick = hideModal;
    if (cancelBtn) cancelBtn.onclick = hideModal;

    modal.onclick = (e) => {
        if (e.target === modal) hideModal();
    };

    // 搜索输入
    let searchTimer = null;
    if (searchInput) {
        searchInput.oninput = () => {
            clearTimeout(searchTimer);
            searchTimer = setTimeout(() => {
                filterTrackingBlockDomainList(searchInput.value);
            }, 200);
        };
        searchInput.onkeypress = (e) => {
            if (e.key === 'Enter') confirmBtn.click();
        };
    }

    if (confirmBtn) {
        confirmBtn.onclick = async () => {
            const selectedDomains = Array.from(trackingBlockDomainSelected);

            // Allow manual entry if not in list
            const inputVal = searchInput ? searchInput.value.trim() : '';
            if (inputVal && !trackingBlockDomainSelected.has(inputVal)) {
                if (inputVal.includes('.') || inputVal.includes('localhost')) {
                    selectedDomains.push(inputVal);
                }
            }

            if (selectedDomains.length > 0) {
                for (const domain of selectedDomains) {
                    await blockTrackingDomain(domain);
                }
                hideModal();
                await loadTrackingBlockedLists();
            } else {
                const isZh = currentLang === 'zh_CN';
                alert(isZh ? '请选择或输入要屏蔽的域名' : 'Please select or enter a domain to block');
            }
        };
    }
}

// =============================================================================
// 时间追踪添加屏蔽书签弹窗
// =============================================================================

let trackingBlockBookmarkSelected = new Set();

// 显示添加屏蔽书签弹窗（时间追踪）
async function showAddTrackingBlockBookmarkModal() {
    const modal = document.getElementById('addTrackingBlockBookmarkModal');
    if (!modal) return;

    trackingBlockBookmarkSelected.clear();
    updateTrackingBlockBookmarkCount();

    // 重置标签页
    const tabs = modal.querySelectorAll('.add-postponed-tab');
    const panels = modal.querySelectorAll('.add-postponed-panel');
    tabs.forEach(t => t.classList.remove('active'));
    panels.forEach(p => p.classList.remove('active'));
    tabs[0]?.classList.add('active');
    panels[0]?.classList.add('active');

    modal.classList.add('show');

    // 加载正在追踪的书签
    await loadTrackingBlockBookmarkTrackingList();
}

// 加载正在追踪的书签列表
async function loadTrackingBlockBookmarkTrackingList() {
    const listEl = document.getElementById('addTrackingBlockBookmarkTrackingList');
    if (!listEl) return;

    const isZh = currentLang === 'zh_CN';
    listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载中...' : 'Loading...'}</div>`;

    try {
        const response = await browserAPI.runtime.sendMessage({
            action: 'getCurrentActiveSessions'
        });

        if (!response?.success || !response.sessions?.length) {
            listEl.innerHTML = `<div class="add-results-empty">${isZh ? '暂无正在追踪的书签' : 'No active tracking sessions'}</div>`;
            return;
        }

        const blockedSets = await getTrackingBlockedSets();
        const cache = await getTrackingBookmarkCache();

        // 按标题分组去重
        const uniqueBookmarks = new Map();
        for (const session of response.sessions) {
            const key = session.title || session.url;
            if (!uniqueBookmarks.has(key)) {
                uniqueBookmarks.set(key, {
                    id: session.bookmarkId,
                    url: session.url,
                    title: session.title || session.url
                });
            }
        }

        const items = Array.from(uniqueBookmarks.values());
        const blockedFlags = await Promise.all(
            items.map(item => isTrackingItemBlocked(item, blockedSets, cache))
        );
        const filteredItems = items.filter((_, index) => !blockedFlags[index]);

        if (filteredItems.length === 0) {
            listEl.innerHTML = `<div class="add-results-empty">${isZh ? '所有正在追踪的书签都已被屏蔽' : 'All tracking sessions are already blocked'}</div>`;
            return;
        }

        renderTrackingBlockBookmarkList(listEl, filteredItems);

    } catch (e) {
        console.error('[时间追踪屏蔽] 加载正在追踪书签失败:', e);
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载失败' : 'Failed to load'}</div>`;
    }
}

// 加载综合排行书签列表
async function loadTrackingBlockBookmarkRankingList() {
    const listEl = document.getElementById('addTrackingBlockBookmarkRankingList');
    if (!listEl) return;

    const isZh = currentLang === 'zh_CN';
    listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载中...' : 'Loading...'}</div>`;

    try {
        const statsResponse = await browserAPI.runtime.sendMessage({ action: 'getTrackingStats' });

        if (!statsResponse?.success || !statsResponse.stats) {
            listEl.innerHTML = `<div class="add-results-empty">${isZh ? '暂无排行数据' : 'No ranking data'}</div>`;
            return;
        }

        const blockedSets = await getTrackingBlockedSets();
        const cache = await getTrackingBookmarkCache();

        // 转换为数组
        const items = Object.values(statsResponse.stats).map(stat => ({
            id: stat.bookmarkId || null,
            url: stat.url,
            title: stat.title || stat.url
        }));
        const blockedFlags = await Promise.all(
            items.map(item => isTrackingItemBlocked(item, blockedSets, cache))
        );
        const filteredItems = items.filter((_, index) => !blockedFlags[index]);

        if (filteredItems.length === 0) {
            listEl.innerHTML = `<div class="add-results-empty">${isZh ? '没有可屏蔽的书签' : 'No bookmarks to block'}</div>`;
            return;
        }

        renderTrackingBlockBookmarkList(listEl, filteredItems.slice(0, 50));

    } catch (e) {
        console.error('[时间追踪屏蔽] 加载综合排行失败:', e);
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载失败' : 'Failed to load'}</div>`;
    }
}

// 搜索书签树
async function searchTrackingBlockBookmarks(keyword) {
    const listEl = document.getElementById('addTrackingBlockBookmarkTreeList');
    if (!listEl) return;

    const isZh = currentLang === 'zh_CN';

    if (!keyword.trim()) {
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '输入关键词搜索书签' : 'Enter keyword to search bookmarks'}</div>`;
        return;
    }

    listEl.innerHTML = `<div class="add-results-empty">${isZh ? '搜索中...' : 'Searching...'}</div>`;

    try {
        const allBookmarks = await getAllBookmarksFlat();
        const keywordLower = keyword.toLowerCase();

        const blockedSets = await getTrackingBlockedSets();
        const cache = await getTrackingBookmarkCache();

        const matchedBookmarks = [];
        for (const b of allBookmarks) {
            if (!b.url) continue; // 跳过文件夹
            const matches = (b.title && b.title.toLowerCase().includes(keywordLower)) ||
                (b.url && b.url.toLowerCase().includes(keywordLower));
            if (!matches) continue;
            const blocked = await isTrackingItemBlocked({ bookmarkId: b.id, url: b.url }, blockedSets, cache);
            if (blocked) continue;
            matchedBookmarks.push(b);
        }

        if (matchedBookmarks.length === 0) {
            listEl.innerHTML = `<div class="add-results-empty">${isZh ? '未找到匹配的书签' : 'No matching bookmarks found'}</div>`;
            return;
        }

        const items = matchedBookmarks.slice(0, 50).map(b => ({
            id: b.id,
            url: b.url,
            title: b.title || b.url
        }));

        renderTrackingBlockBookmarkList(listEl, items);

    } catch (e) {
        console.error('[时间追踪屏蔽] 搜索书签失败:', e);
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '搜索失败' : 'Search failed'}</div>`;
    }
}

// 渲染书签列表
function renderTrackingBlockBookmarkList(listEl, items) {
    const isZh = currentLang === 'zh_CN';

    listEl.innerHTML = items.map(item => {
        const faviconUrl = getFaviconUrl(item.url);
        const displayTitle = item.title.length > 50 ? item.title.substring(0, 50) + '...' : item.title;
        const itemKey = item.id || item.url; // 用ID或URL作为唯一标识
        const isSelected = trackingBlockBookmarkSelected.has(itemKey);

        return `
            <div class="add-bookmark-item ${isSelected ? 'selected' : ''}" data-key="${escapeHtml(itemKey)}" data-id="${item.id || ''}" data-url="${escapeHtml(item.url || '')}">
                <input type="checkbox" ${isSelected ? 'checked' : ''}>
                <img class="add-bookmark-favicon" src="${faviconUrl}" alt="">
                <div class="add-bookmark-info">
                    <div class="add-bookmark-title">${escapeHtml(displayTitle)}</div>
                </div>
            </div>
        `;
    }).join('');

    // 绑定点击事件
    listEl.querySelectorAll('.add-bookmark-item').forEach(itemEl => {
        itemEl.addEventListener('click', () => {
            const key = itemEl.dataset.key;
            const checkbox = itemEl.querySelector('input[type="checkbox"]');
            if (trackingBlockBookmarkSelected.has(key)) {
                trackingBlockBookmarkSelected.delete(key);
                itemEl.classList.remove('selected');
                checkbox.checked = false;
            } else {
                trackingBlockBookmarkSelected.add(key);
                itemEl.classList.add('selected');
                checkbox.checked = true;
            }
            updateTrackingBlockBookmarkCount();
        });
    });
}

// 更新选中数量
function updateTrackingBlockBookmarkCount() {
    const el = document.getElementById('addTrackingBlockBookmarkSelectedCount');
    if (el) el.textContent = trackingBlockBookmarkSelected.size;
}

// 初始化添加屏蔽书签弹窗（时间追踪）
function initAddTrackingBlockBookmarkModal() {
    const modal = document.getElementById('addTrackingBlockBookmarkModal');
    if (!modal) return;

    const closeBtn = document.getElementById('addTrackingBlockBookmarkModalClose');
    const cancelBtn = document.getElementById('addTrackingBlockBookmarkCancelBtn');
    const confirmBtn = document.getElementById('addTrackingBlockBookmarkConfirmBtn');
    const searchInput = document.getElementById('addTrackingBlockBookmarkSearchInput');
    const tabs = modal.querySelectorAll('.add-postponed-tab');
    const panels = modal.querySelectorAll('.add-postponed-panel');

    const hideModal = () => {
        modal.classList.remove('show');
        trackingBlockBookmarkSelected.clear();
        if (searchInput) searchInput.value = '';
    };

    if (closeBtn) closeBtn.onclick = hideModal;
    if (cancelBtn) cancelBtn.onclick = hideModal;


    modal.onclick = (e) => {
        if (e.target === modal) hideModal();
    };

    // 标签页切换
    tabs.forEach(tab => {
        tab.addEventListener('click', async () => {
            const tabName = tab.dataset.tab;
            tabs.forEach(t => t.classList.remove('active'));
            panels.forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            modal.querySelector(`.add-postponed-panel[data-panel="${tabName}"]`)?.classList.add('active');

            // 加载对应的数据
            if (tabName === 'tracking') {
                await loadTrackingBlockBookmarkTrackingList();
            } else if (tabName === 'ranking') {
                await loadTrackingBlockBookmarkRankingList();
            }
            // tree 面板通过搜索框触发
        });
    });

    // 搜索输入
    let searchTimer = null;
    if (searchInput) {
        searchInput.oninput = () => {
            clearTimeout(searchTimer);
            searchTimer = setTimeout(() => {
                searchTrackingBlockBookmarks(searchInput.value);
            }, 300);
        };
    }

    // 确认按钮
    if (confirmBtn) {
        confirmBtn.onclick = async () => {
            if (trackingBlockBookmarkSelected.size === 0) {
                const isZh = currentLang === 'zh_CN';
                alert(isZh ? '请选择要屏蔽的书签' : 'Please select bookmarks to block');
                return;
            }

            // 遍历选中项，根据ID或URL来屏蔽
            for (const key of trackingBlockBookmarkSelected) {
                // 如果key是书签ID格式（数字字符串），则按ID屏蔽
                // 否则按URL生成的域名屏蔽（简化处理：直接屏蔽书签ID）
                if (key) {
                    await blockTrackingBookmark(key);
                }
            }

            hideModal();
            await loadTrackingBlockedLists();
        };
    }
}

// 在屏蔽管理弹窗中绑定添加书签按钮
function bindAddTrackingBlockBookmarkBtn() {
    const addBookmarkBtn = document.getElementById('addTrackingBlockBookmarkBtn');
    if (addBookmarkBtn) {
        addBookmarkBtn.onclick = () => showAddTrackingBlockBookmarkModal();
    }
}

// =============================================================================
// 添加到稍后复习弹窗
// =============================================================================

let addPostponedSelectedFolder = null;
let addPostponedSearchSelected = new Set();
let addPostponedDomainSelected = new Set();
let addPostponedDomainData = []; // 保存完整的域名数据用于过滤

function initAddToPostponedModal() {
    const modal = document.getElementById('addToPostponedModal');
    const addBtn = document.getElementById('postponedAddBtn');
    const closeBtn = document.getElementById('addPostponedModalClose');
    const cancelBtn = document.getElementById('addPostponedCancelBtn');
    const confirmBtn = document.getElementById('addPostponedConfirmBtn');
    const tabs = modal?.querySelectorAll('.add-postponed-tab');
    const panels = modal?.querySelectorAll('.add-postponed-panel');

    if (!modal || !addBtn) return;

    // 打开弹窗
    addBtn.onclick = (e) => {
        e.stopPropagation();
        resetAddPostponedModal();
        modal.classList.add('show');
    };

    // 关闭弹窗
    const hideModal = () => modal.classList.remove('show');
    closeBtn?.addEventListener('click', hideModal);
    cancelBtn?.addEventListener('click', hideModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) hideModal();
    });

    // 标签切换
    tabs?.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.dataset.tab;
            tabs.forEach(t => t.classList.remove('active'));
            panels?.forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            modal.querySelector(`.add-postponed-panel[data-panel="${tabName}"]`)?.classList.add('active');
        });
    });

    // 文件夹选择按钮
    const folderSelectBtn = document.getElementById('addFolderSelectBtn');
    folderSelectBtn?.addEventListener('click', () => {
        showAddFolderPicker();
    });

    // "全部"复选框逻辑
    const selectAllCheckbox = document.getElementById('addFolderSelectAll');
    const countInput = document.getElementById('addFolderCount');
    const modeRow = document.getElementById('addModeRow');
    selectAllCheckbox?.addEventListener('change', () => {
        if (selectAllCheckbox.checked) {
            countInput.disabled = true;
            modeRow.style.display = 'none';
            // 自动设置为顺序模式
            const sequentialRadio = document.querySelector('input[name="addFolderMode"][value="sequential"]');
            if (sequentialRadio) sequentialRadio.checked = true;
        } else {
            countInput.disabled = false;
            modeRow.style.display = 'flex';
        }
    });

    // 搜索书签输入框
    const searchInput = document.getElementById('addSearchInput');
    let searchTimer = null;
    searchInput?.addEventListener('input', () => {
        clearTimeout(searchTimer);
        searchTimer = setTimeout(() => {
            searchBookmarksForAdd(searchInput.value);
        }, 300);
    });

    // 标签切换时加载域名列表
    tabs?.forEach(tab => {
        tab.addEventListener('click', async () => {
            if (tab.dataset.tab === 'domain') {
                await loadDomainList();
            }
        });
    });

    // 域名搜索输入框
    const domainSearchInput = document.getElementById('addDomainSearchInput');
    let domainSearchTimer = null;
    domainSearchInput?.addEventListener('input', () => {
        clearTimeout(domainSearchTimer);
        domainSearchTimer = setTimeout(() => {
            filterDomainList(domainSearchInput.value);
        }, 200);
    });

    // 确认添加
    confirmBtn?.addEventListener('click', async () => {
        await confirmAddToPostponed();
        hideModal();
    });
}

function resetAddPostponedModal() {
    addPostponedSelectedFolder = null;
    addPostponedSearchSelected.clear();
    addPostponedDomainSelected.clear();

    const isZh = currentLang === 'zh_CN';

    // 重置文件夹选择
    const folderName = document.getElementById('addFolderSelectedName');
    if (folderName) folderName.textContent = isZh ? '点击选择文件夹' : 'Click to select folder';

    // 重置"全部"复选框
    const selectAllCheckbox = document.getElementById('addFolderSelectAll');
    const countInput = document.getElementById('addFolderCount');
    const modeRow = document.getElementById('addModeRow');
    if (selectAllCheckbox) selectAllCheckbox.checked = false;
    if (countInput) countInput.disabled = false;
    if (modeRow) modeRow.style.display = 'flex';

    // 重置搜索
    const searchInput = document.getElementById('addSearchInput');
    const searchResults = document.getElementById('addSearchResults');
    const searchCount = document.getElementById('addSearchSelectedCount');
    if (searchInput) searchInput.value = '';
    if (searchResults) searchResults.innerHTML = `<div class="add-results-empty">${isZh ? '输入关键词搜索书签' : 'Enter keyword to search bookmarks'}</div>`;
    if (searchCount) searchCount.textContent = '0';

    // 重置域名
    const domainSearchInput = document.getElementById('addDomainSearchInput');
    const domainList = document.getElementById('addDomainList');
    const domainCount = document.getElementById('addDomainSelectedCount');
    if (domainSearchInput) domainSearchInput.value = '';
    if (domainList) domainList.innerHTML = `<div class="add-results-empty">${isZh ? '切换到此标签加载域名' : 'Switch to this tab to load domains'}</div>`;
    if (domainCount) domainCount.textContent = '0';
    addPostponedDomainData = [];

    // 重置到第一个标签
    const modal = document.getElementById('addToPostponedModal');
    const tabs = modal?.querySelectorAll('.add-postponed-tab');
    const panels = modal?.querySelectorAll('.add-postponed-panel');
    tabs?.forEach((t, i) => t.classList.toggle('active', i === 0));
    panels?.forEach((p, i) => p.classList.toggle('active', i === 0));
}

// 显示文件夹选择器
function showAddFolderPicker() {
    const panel = document.querySelector('.add-postponed-panel[data-panel="folder"]');
    if (!panel) return;

    // 检查是否已存在选择器
    let treeContainer = panel.querySelector('.add-folder-tree');
    if (treeContainer) {
        treeContainer.remove();
        return;
    }

    // 创建树形选择器
    treeContainer = document.createElement('div');
    treeContainer.className = 'add-folder-tree';

    // 获取书签树
    browserAPI.bookmarks.getTree().then(tree => {
        const rootNodes = tree[0]?.children || [];
        treeContainer.innerHTML = renderFolderTree(rootNodes);

        // 绑定点击事件
        treeContainer.querySelectorAll('.add-folder-tree-item').forEach(item => {
            item.addEventListener('click', () => {
                treeContainer.querySelectorAll('.add-folder-tree-item').forEach(i => i.classList.remove('selected'));
                item.classList.add('selected');
                addPostponedSelectedFolder = {
                    id: item.dataset.id,
                    title: item.dataset.title
                };
                const folderName = document.getElementById('addFolderSelectedName');
                if (folderName) folderName.textContent = item.dataset.title;
            });
        });
    });

    // 插入到第一行后面
    const firstRow = panel.querySelector('.add-panel-row');
    firstRow?.insertAdjacentElement('afterend', treeContainer);
}

function renderFolderTree(nodes, level = 0) {
    const isZh = currentLang === 'zh_CN';

    function countBookmarks(node) {
        let count = 0;
        if (node.url) count = 1;
        if (node.children) {
            for (const child of node.children) {
                count += countBookmarks(child);
            }
        }
        return count;
    }

    let html = '';
    for (const node of nodes) {
        if (!node.url) { // 只显示文件夹
            const hasChildren = node.children?.some(c => !c.url);
            const bookmarkCount = countBookmarks(node);
            html += `<div class="folder-tree-node">`;
            html += `<div class="add-folder-tree-item" data-id="${node.id}" data-title="${escapeHtml(node.title || '未命名')}">
                <i class="fas fa-folder"></i>
                <span>${escapeHtml(node.title || (isZh ? '未命名' : 'Untitled'))}</span>
                <span class="folder-count">${bookmarkCount}</span>
            </div>`;
            if (hasChildren) {
                html += `<div class="folder-tree-children">${renderFolderTree(node.children, level + 1)}</div>`;
            }
            html += `</div>`;
        }
    }
    return html;
}

// 搜索书签
async function searchBookmarksForAdd(keyword) {
    const resultsEl = document.getElementById('addSearchResults');
    const countEl = document.getElementById('addSearchSelectedCount');
    if (!resultsEl) return;

    if (!keyword.trim()) {
        resultsEl.innerHTML = `<div class="add-results-empty">${currentLang === 'zh_CN' ? '输入关键词搜索书签' : 'Enter keyword to search bookmarks'}</div>`;
        return;
    }

    try {
        const results = await browserAPI.bookmarks.search(keyword);
        const bookmarks = results.filter(b => b.url).slice(0, 50);

        if (bookmarks.length === 0) {
            resultsEl.innerHTML = `<div class="add-results-empty">${currentLang === 'zh_CN' ? '未找到匹配的书签' : 'No bookmarks found'}</div>`;
            return;
        }

        resultsEl.innerHTML = bookmarks.map(b => `
            <div class="add-result-item ${addPostponedSearchSelected.has(b.id) ? 'selected' : ''}" data-id="${b.id}">
                <input type="checkbox" class="add-result-checkbox" ${addPostponedSearchSelected.has(b.id) ? 'checked' : ''}>
                <img class="add-result-favicon" src="${getFaviconUrl(b.url)}">
                <div class="add-result-info">
                    <div class="add-result-title">${escapeHtml(b.title || b.url)}</div>
                    <div class="add-result-url">${escapeHtml(b.url)}</div>
                </div>
            </div>
        `).join('');

        // 绑定点击事件
        resultsEl.querySelectorAll('.add-result-item').forEach(item => {
            item.addEventListener('click', () => {
                const id = item.dataset.id;
                const checkbox = item.querySelector('.add-result-checkbox');
                if (addPostponedSearchSelected.has(id)) {
                    addPostponedSearchSelected.delete(id);
                    item.classList.remove('selected');
                    checkbox.checked = false;
                } else {
                    addPostponedSearchSelected.add(id);
                    item.classList.add('selected');
                    checkbox.checked = true;
                }
                countEl.textContent = addPostponedSearchSelected.size;
            });
        });
    } catch (e) {
        console.error('[添加到稍后] 搜索失败:', e);
    }
}

// 加载域名列表
async function loadDomainList() {
    const listEl = document.getElementById('addDomainList');
    const countEl = document.getElementById('addDomainSelectedCount');
    const searchInput = document.getElementById('addDomainSearchInput');
    if (!listEl) return;

    const isZh = currentLang === 'zh_CN';
    listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载中...' : 'Loading...'}</div>`;
    if (searchInput) searchInput.value = '';

    try {
        const allBookmarks = await getAllBookmarksFlat();

        // 统计每个域名的书签数量
        const domainMap = new Map(); // domain -> { count, bookmarkIds }
        for (const b of allBookmarks) {
            if (!b.url) continue;
            try {
                const url = new URL(b.url);
                const domain = url.hostname;
                if (!domainMap.has(domain)) {
                    domainMap.set(domain, { count: 0, bookmarkIds: [] });
                }
                domainMap.get(domain).count++;
                domainMap.get(domain).bookmarkIds.push(b.id);
            } catch {
                // 忽略无效URL
            }
        }

        // 按数量排序并保存
        addPostponedDomainData = Array.from(domainMap.entries())
            .sort((a, b) => b[1].count - a[1].count);

        renderDomainList(addPostponedDomainData);
    } catch (e) {
        console.error('[添加到待复习] 加载域名列表失败:', e);
        const isZh = currentLang === 'zh_CN';
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '加载失败' : 'Failed to load'}</div>`;
    }
}

// 过滤域名列表
function filterDomainList(keyword) {
    if (!keyword.trim()) {
        renderDomainList(addPostponedDomainData);
        return;
    }

    const keywordLower = keyword.toLowerCase();
    const filtered = addPostponedDomainData.filter(([domain]) =>
        domain.toLowerCase().includes(keywordLower)
    );
    renderDomainList(filtered);
}

// 渲染域名列表
function renderDomainList(domains) {
    const listEl = document.getElementById('addDomainList');
    const countEl = document.getElementById('addDomainSelectedCount');
    if (!listEl) return;

    const isZh = currentLang === 'zh_CN';

    if (domains.length === 0) {
        listEl.innerHTML = `<div class="add-results-empty">${isZh ? '没有找到匹配的域名' : 'No matching domains'}</div>`;
        return;
    }

    // 最多显示100个
    const displayDomains = domains.slice(0, 100);

    listEl.innerHTML = displayDomains.map(([domain, data]) => `
        <div class="add-domain-item ${addPostponedDomainSelected.has(domain) ? 'selected' : ''}" data-domain="${escapeHtml(domain)}">
            <input type="checkbox" ${addPostponedDomainSelected.has(domain) ? 'checked' : ''}>
            <div class="add-domain-info">
                <div class="add-domain-name">${escapeHtml(domain)}</div>
                <div class="add-domain-count">${data.count} ${isZh ? '个书签' : 'bookmarks'}</div>
            </div>
        </div>
    `).join('');

    // 绑定点击事件
    listEl.querySelectorAll('.add-domain-item').forEach(item => {
        item.addEventListener('click', () => {
            const domain = item.dataset.domain;
            const checkbox = item.querySelector('input[type="checkbox"]');
            if (addPostponedDomainSelected.has(domain)) {
                addPostponedDomainSelected.delete(domain);
                item.classList.remove('selected');
                checkbox.checked = false;
            } else {
                addPostponedDomainSelected.add(domain);
                item.classList.add('selected');
                checkbox.checked = true;
            }
            countEl.textContent = addPostponedDomainSelected.size;
        });
    });
}

// 获取所有书签（扁平化）
async function getAllBookmarksFlat() {
    const tree = await browserAPI.bookmarks.getTree();
    const bookmarks = [];

    function traverse(nodes) {
        for (const node of nodes) {
            if (node.url) {
                bookmarks.push(node);
            }
            if (node.children) {
                traverse(node.children);
            }
        }
    }

    traverse(tree);
    return bookmarks;
}

// 确认添加到待复习
async function confirmAddToPostponed() {
    const activePanel = document.querySelector('.add-postponed-panel.active');
    if (!activePanel) return;

    const panelType = activePanel.dataset.panel;
    let bookmarkIds = [];
    const isZh = currentLang === 'zh_CN';

    if (panelType === 'folder') {
        // 从文件夹抽取
        if (!addPostponedSelectedFolder) {
            alert(isZh ? '请先选择一个文件夹' : 'Please select a folder first');
            return;
        }

        const selectAll = document.getElementById('addFolderSelectAll')?.checked;
        const count = selectAll ? Infinity : (parseInt(document.getElementById('addFolderCount')?.value) || 5);
        const mode = selectAll ? 'sequential' : (document.querySelector('input[name="addFolderMode"]:checked')?.value || 'random');
        const includeSubfolders = document.getElementById('addFolderIncludeSubfolders')?.checked ?? true;

        // 获取文件夹内的书签
        const folderBookmarks = await getBookmarksFromFolder(addPostponedSelectedFolder.id, includeSubfolders);

        if (folderBookmarks.length === 0) {
            alert(isZh ? '该文件夹中没有书签' : 'No bookmarks in this folder');
            return;
        }

        // 根据模式抽取
        if (mode === 'random') {
            // 随机打乱
            const shuffled = [...folderBookmarks].sort(() => Math.random() - 0.5);
            bookmarkIds = shuffled.slice(0, count).map(b => b.id);
        } else {
            // 顺序抽取（全部或指定数量）
            bookmarkIds = folderBookmarks.slice(0, count).map(b => b.id);
        }

    } else if (panelType === 'search') {
        bookmarkIds = Array.from(addPostponedSearchSelected);
        if (bookmarkIds.length === 0) {
            alert(isZh ? '请先搜索并选择书签' : 'Please search and select bookmarks first');
            return;
        }
    } else if (panelType === 'domain') {
        const selectedDomains = Array.from(addPostponedDomainSelected);
        if (selectedDomains.length === 0) {
            alert(isZh ? '请先选择域名' : 'Please select domains first');
            return;
        }
        // 获取所有选中域名的书签
        const allBookmarks = await getAllBookmarksFlat();
        for (const b of allBookmarks) {
            if (!b.url) continue;
            try {
                const url = new URL(b.url);
                if (selectedDomains.includes(url.hostname)) {
                    bookmarkIds.push(b.id);
                }
            } catch {
                // 忽略
            }
        }
        if (bookmarkIds.length === 0) {
            alert(isZh ? '所选域名没有书签' : 'No bookmarks for selected domains');
            return;
        }
    }

    if (bookmarkIds.length === 0) {
        return;
    }

    // 添加到待复习队列（手动添加的书签会获得优先级提升）
    const postponed = await getPostponedBookmarks();
    const now = Date.now();
    let addedCount = 0;

    // 处理"全部"选项
    const selectAllCheckbox = document.getElementById('addFolderSelectAll');
    const isSelectAll = selectAllCheckbox?.checked;

    // 生成分组信息
    let groupInfo = null;
    if (panelType === 'folder' && addPostponedSelectedFolder) {
        groupInfo = {
            type: 'folder',
            id: `folder_${addPostponedSelectedFolder.id}_${now}`,
            name: addPostponedSelectedFolder.title,
            folderId: addPostponedSelectedFolder.id
        };
    } else if (panelType === 'domain') {
        const selectedDomains = Array.from(addPostponedDomainSelected);
        const domainName = selectedDomains.length === 1 ? selectedDomains[0] : `${selectedDomains.length} ${isZh ? '个域名' : 'domains'}`;
        groupInfo = {
            type: 'domain',
            id: `domain_${now}`,
            name: domainName
        };
    }

    for (const id of bookmarkIds) {
        // 检查是否已存在
        const existing = postponed.find(p => p.bookmarkId === id);
        if (!existing) {
            postponed.push({
                bookmarkId: id,
                addedAt: now,
                postponeUntil: now, // 立即可用，不设置延迟
                manuallyAdded: true, // 标记为手动添加，用于优先级提升
                groupId: groupInfo?.id || null,
                groupType: groupInfo?.type || 'single',
                groupName: groupInfo?.name || null
            });
            addedCount++;
        } else if (!existing.manuallyAdded) {
            // 如果已存在但不是手动添加的，更新为手动添加
            existing.manuallyAdded = true;
            existing.postponeUntil = now;
            existing.groupId = groupInfo?.id || null;
            existing.groupType = groupInfo?.type || 'single';
            existing.groupName = groupInfo?.name || null;
        }
    }

    await browserAPI.storage.local.set({ recommend_postponed: postponed });
    console.log(`[添加到待复习] 已添加 ${addedCount} 个书签（手动添加，优先级提升）`);

    // 刷新列表（可能触发模式切换和全量重算）
    // 注意：loadPostponedList 会检测是否需要切换到优先模式，如果切换则会全量重算
    // 所以这里不需要额外调用 updateMultipleBookmarkScores，避免重复计算
    await loadPostponedList();
    await refreshRecommendCards(true); // 强制刷新推荐卡片

    // 显示成功提示
    const msg = isZh
        ? `已添加 ${bookmarkIds.length} 个书签到待复习`
        : `Added ${bookmarkIds.length} bookmark(s) to review`;

    // 使用临时提示而不是 alert
    showToast(msg);
}

// 显示临时提示
function showToast(message, duration = 2000) {
    // 移除已存在的toast
    const existing = document.querySelector('.toast-message');
    if (existing) existing.remove();

    const toast = document.createElement('div');
    toast.className = 'toast-message';
    toast.textContent = message;
    toast.style.cssText = `
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 99999;
        animation: fadeInUp 0.3s ease;
    `;
    document.body.appendChild(toast);

    setTimeout(() => {
        toast.style.animation = 'fadeOutDown 0.3s ease';
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

// 从文件夹获取书签
async function getBookmarksFromFolder(folderId, includeSubfolders = true) {
    const bookmarks = [];

    async function traverse(nodeId) {
        const children = await browserAPI.bookmarks.getChildren(nodeId);
        for (const child of children) {
            if (child.url) {
                bookmarks.push(child);
            } else if (includeSubfolders && child.children !== undefined) {
                await traverse(child.id);
            }
        }
    }

    await traverse(folderId);
    return bookmarks;
}

async function loadRecommendData() {
    console.log('[书签推荐] 加载推荐数据');

    // 检查是否需要自动刷新（基于打开次数或时间）
    const shouldAutoRefresh = await checkAndIncrementOpenCount();

    // 根据检查结果决定是否强制刷新
    await refreshRecommendCards(shouldAutoRefresh);

    // 加载稍后复习队列
    await loadPostponedList();

    // 加载热力图
    await loadHeatmapData();

    // 加载屏蔽列表
    await loadBlockedLists();
}

// 检查并增加打开次数，返回是否需要自动刷新
async function checkAndIncrementOpenCount() {
    try {
        const settings = await getRefreshSettings();
        const now = Date.now();
        let shouldRefresh = false;

        // 增加打开次数
        settings.openCountSinceRefresh = (settings.openCountSinceRefresh || 0) + 1;
        console.log('[自动刷新] 打开次数:', settings.openCountSinceRefresh);

        // 检查是否达到刷新条件
        // 1. 每N次打开刷新
        if (settings.refreshEveryNOpens > 0 && settings.openCountSinceRefresh >= settings.refreshEveryNOpens) {
            console.log('[自动刷新] 达到打开次数阈值，触发刷新');
            shouldRefresh = true;
        }

        // 2. 超过X小时刷新
        if (!shouldRefresh && settings.refreshAfterHours > 0 && settings.lastRefreshTime > 0) {
            const hoursSinceRefresh = (now - settings.lastRefreshTime) / (1000 * 60 * 60);
            if (hoursSinceRefresh >= settings.refreshAfterHours) {
                console.log('[自动刷新] 超过小时阈值，触发刷新');
                shouldRefresh = true;
            }
        }

        // 3. 超过X天刷新
        if (!shouldRefresh && settings.refreshAfterDays > 0 && settings.lastRefreshTime > 0) {
            const daysSinceRefresh = (now - settings.lastRefreshTime) / (1000 * 60 * 60 * 24);
            if (daysSinceRefresh >= settings.refreshAfterDays) {
                console.log('[自动刷新] 超过天数阈值，触发刷新');
                shouldRefresh = true;
            }
        }

        // 保存更新后的设置
        await saveRefreshSettings(settings);

        // 更新状态显示
        updateRefreshSettingsStatus(settings);

        return shouldRefresh;
    } catch (e) {
        console.error('[自动刷新] 检查失败:', e);
        return false;
    }
}

// 加载待复习队列
async function loadPostponedList() {
    const listEl = document.getElementById('postponedList');
    const countEl = document.getElementById('postponedCount');
    const emptyEl = document.getElementById('postponedEmpty');
    if (!listEl) return;

    try {
        const postponed = await getPostponedBookmarks();
        const now = Date.now();

        // 过滤：手动添加的 或 未到期的
        const activePostponed = postponed.filter(p => p.manuallyAdded || p.postponeUntil > now);

        // 更新计数
        if (countEl) countEl.textContent = activePostponed.length;

        // 更新优先模式按钮和权重显示
        const priorityBadge = document.getElementById('postponedPriorityBadge');
        const priorityModeBtn = document.getElementById('priorityModeBtn');
        const hasManualPostponed = activePostponed.some(p => p.manuallyAdded);

        if (priorityBadge) {
            priorityBadge.style.display = hasManualPostponed ? 'inline-flex' : 'none';
        }

        // 优先模式按钮显示/隐藏
        if (priorityModeBtn) {
            if (hasManualPostponed) {
                priorityModeBtn.style.display = 'inline-flex';
                // 如果当前不是用户主动选择的其他模式，自动切换到优先模式
                if (!priorityModeBtn.dataset.userOverride) {
                    applyPresetMode('priority');
                }
            } else {
                priorityModeBtn.style.display = 'none';
                // 待复习清空后，如果当前是优先模式，切换回默认
                if (currentRecommendMode === 'priority') {
                    applyPresetMode('default');
                }
                delete priorityModeBtn.dataset.userOverride;
            }
        }

        // 根据数量决定是否折叠
        updatePostponedCollapse(activePostponed.length);

        // 清空列表（保留空状态元素）
        const items = listEl.querySelectorAll('.postponed-item, .postponed-group');
        items.forEach(item => item.remove());

        if (activePostponed.length === 0) {
            if (emptyEl) emptyEl.style.display = 'block';
            return;
        }

        if (emptyEl) emptyEl.style.display = 'none';

        // 按分组整理书签
        const groups = new Map(); // groupId -> items[]
        const singles = []; // 没有分组的单个书签
        const delayedItems = []; // 通过卡片⏰按钮添加的延迟书签

        for (const p of activePostponed) {
            if (p.groupId && p.manuallyAdded) {
                if (!groups.has(p.groupId)) {
                    groups.set(p.groupId, {
                        type: p.groupType,
                        name: p.groupName,
                        items: []
                    });
                }
                groups.get(p.groupId).items.push(p);
            } else if (p.manuallyAdded && !p.groupId) {
                singles.push(p);
            } else {
                delayedItems.push(p);
            }
        }

        // 渲染分组
        for (const [groupId, group] of groups) {
            await renderPostponedGroup(listEl, groupId, group);
        }

        // 渲染单个书签
        for (const p of singles) {
            await renderPostponedItem(listEl, p);
        }

        // 渲染延迟书签
        for (const p of delayedItems) {
            await renderPostponedItem(listEl, p);
        }

    } catch (e) {
        console.error('[待复习] 加载待复习列表失败:', e);
    }
}

// 渲染分组
async function renderPostponedGroup(container, groupId, group) {
    const isZh = currentLang === 'zh_CN';
    const icon = group.type === 'folder' ? 'fa-folder' : 'fa-globe';
    const typeLabel = group.type === 'folder'
        ? (isZh ? '文件夹' : 'Folder')
        : (isZh ? '域名' : 'Domain');

    const groupEl = document.createElement('div');
    groupEl.className = 'postponed-group';
    groupEl.dataset.groupId = groupId;

    groupEl.innerHTML = `
        <div class="postponed-group-header">
            <div class="postponed-group-info">
                <i class="fas ${icon} postponed-group-icon"></i>
                <span class="postponed-group-name">${escapeHtml(group.name)}</span>
                <span class="postponed-group-count">${group.items.length}</span>
                <span class="postponed-group-type">${typeLabel}</span>
            </div>
            <div class="postponed-group-actions">
                <button class="postponed-group-btn expand" title="${isZh ? '展开' : 'Expand'}">
                    <i class="fas fa-chevron-down"></i>
                </button>
                <button class="postponed-group-btn cancel" title="${isZh ? '取消全部' : 'Cancel All'}">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>
        <div class="postponed-group-items" style="display: none;"></div>
    `;

    const header = groupEl.querySelector('.postponed-group-header');
    const itemsContainer = groupEl.querySelector('.postponed-group-items');
    const expandBtn = groupEl.querySelector('.postponed-group-btn.expand');
    const cancelBtn = groupEl.querySelector('.postponed-group-btn.cancel');

    // 展开/折叠
    header.onclick = async (e) => {
        if (e.target.closest('.postponed-group-btn')) return;
        toggleGroupExpand();
    };

    expandBtn.onclick = (e) => {
        e.stopPropagation();
        toggleGroupExpand();
    };

    async function toggleGroupExpand() {
        const isExpanded = itemsContainer.style.display !== 'none';
        if (isExpanded) {
            itemsContainer.style.display = 'none';
            expandBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
            expandBtn.title = isZh ? '展开' : 'Expand';
        } else {
            // 首次展开时渲染子项
            if (itemsContainer.children.length === 0) {
                for (const p of group.items) {
                    await renderPostponedItem(itemsContainer, p, true);
                }
            }
            itemsContainer.style.display = 'block';
            expandBtn.innerHTML = '<i class="fas fa-chevron-up"></i>';
            expandBtn.title = isZh ? '收起' : 'Collapse';
        }
    }

    // 取消全部
    cancelBtn.onclick = async (e) => {
        e.stopPropagation();
        for (const p of group.items) {
            await cancelPostpone(p.bookmarkId);
        }
        await loadPostponedList();
        await refreshRecommendCards();
    };

    container.appendChild(groupEl);
}

// 渲染单个待复习项
async function renderPostponedItem(container, p, isGroupChild = false) {
    try {
        const bookmarks = await new Promise(resolve => {
            browserAPI.bookmarks.get(p.bookmarkId, resolve);
        });
        if (!bookmarks || bookmarks.length === 0) return;
        const bookmark = bookmarks[0];

        const item = document.createElement('div');
        item.className = 'postponed-item' + (isGroupChild ? ' group-child' : '');
        item.style.cursor = 'pointer';

        const isZh = currentLang === 'zh_CN';
        const isManuallyAdded = p.manuallyAdded;
        const manualBadge = (isManuallyAdded && !isGroupChild)
            ? `<span class="postponed-item-badge manual">${isZh ? '优先' : 'Priority'}</span>`
            : '';
        const timeOrManual = isManuallyAdded
            ? (isZh ? '手动添加，优先推荐' : 'Manually added, priority boost')
            : formatPostponeTime(p.postponeUntil);

        item.innerHTML = `
            <img class="postponed-item-icon" src="${getFaviconUrl(bookmark.url)}" alt="">
            <div class="postponed-item-info">
                <div class="postponed-item-title">${manualBadge}${escapeHtml(bookmark.title || bookmark.url)}</div>
                <div class="postponed-item-meta">
                    <span class="postponed-item-time">${timeOrManual}</span>
                    ${!isManuallyAdded && p.postponeCount > 1 ? `<span class="postponed-item-count">(${isZh ? '已推迟' + p.postponeCount + '次' : 'postponed ' + p.postponeCount + ' times'})</span>` : ''}
                </div>
            </div>
            <button class="postponed-item-btn" data-id="${p.bookmarkId}">${isZh ? '取消' : 'Cancel'}</button>
        `;

        // 点击整个item = 提前复习
        item.onclick = async (e) => {
            if (e.target.closest('.postponed-item-btn')) return;
            console.log('[提前复习]', bookmark.id, bookmark.title);
            await cancelPostpone(p.bookmarkId);
            await recordReview(p.bookmarkId);
            await openInRecommendWindow(bookmark.url);
            await loadPostponedList();
        };

        // 取消按钮事件
        const btn = item.querySelector('.postponed-item-btn');
        btn.onclick = async (e) => {
            e.stopPropagation();
            await cancelPostpone(p.bookmarkId);
            await loadPostponedList();
            await refreshRecommendCards();
        };

        container.appendChild(item);
    } catch (e) {
        console.error('[待复习] 获取书签信息失败:', e);
    }
}

// 格式化推迟时间
function formatPostponeTime(timestamp) {
    const now = Date.now();
    const diff = timestamp - now;
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(hours / 24);

    if (days > 0) {
        return currentLang === 'en' ? `${days} day${days > 1 ? 's' : ''} later` : `${days}天后`;
    } else if (hours > 0) {
        return currentLang === 'en' ? `${hours} hour${hours > 1 ? 's' : ''} later` : `${hours}小时后`;
    } else {
        const mins = Math.max(1, Math.floor(diff / 60000));
        return currentLang === 'en' ? `${mins} minute${mins > 1 ? 's' : ''} later` : `${mins}分钟后`;
    }
}

// 加载屏蔽列表
async function loadBlockedLists() {
    const blocked = await getBlockedBookmarks();

    // 加载已屏蔽书签
    await loadBlockedBookmarksList(blocked.bookmarks);

    // 加载已屏蔽文件夹
    await loadBlockedFoldersList(blocked.folders);

    // 加载已屏蔽域名
    await loadBlockedDomainsList(blocked.domains);
}

// 加载已屏蔽书签列表（相同标题合并显示）
async function loadBlockedBookmarksList(bookmarkIds) {
    const listEl = document.getElementById('blockedBookmarksList');
    const countEl = document.getElementById('blockedBookmarksCount');
    const emptyEl = document.getElementById('blockedBookmarksEmpty');
    if (!listEl) return;

    // 更新计数
    if (countEl) countEl.textContent = bookmarkIds.length;

    // 清空列表
    const items = listEl.querySelectorAll('.block-item, .block-group');
    items.forEach(item => item.remove());

    if (bookmarkIds.length === 0) {
        if (emptyEl) emptyEl.style.display = 'block';
        return;
    }

    if (emptyEl) emptyEl.style.display = 'none';

    // 获取所有书签信息并按标题分组
    const titleGroups = new Map(); // title -> [{id, bookmark}]

    for (const id of bookmarkIds) {
        try {
            const bookmarks = await new Promise(resolve => {
                browserAPI.bookmarks.get(id, resolve);
            });
            if (!bookmarks || bookmarks.length === 0) continue;
            const bookmark = bookmarks[0];
            const title = bookmark.title || bookmark.url;

            if (!titleGroups.has(title)) {
                titleGroups.set(title, []);
            }
            titleGroups.get(title).push({ id, bookmark });
        } catch (e) {
            // 书签可能已被删除
        }
    }

    const isZh = currentLang === 'zh_CN';

    // 渲染分组
    for (const [title, group] of titleGroups) {
        const firstBookmark = group[0].bookmark;
        const count = group.length;
        const allIds = group.map(g => g.id);

        const item = document.createElement('div');
        item.className = 'block-item';

        const countBadge = count > 1
            ? `<span class="block-item-count">${count}</span>`
            : '';

        item.innerHTML = `
            <img class="block-item-icon" src="${getFaviconUrl(firstBookmark.url)}" alt="">
            <div class="block-item-info">
                <div class="block-item-title">${escapeHtml(title)}</div>
            </div>
            ${countBadge}
            <button class="block-item-btn">${isZh ? '恢复' : 'Restore'}</button>
        `;

        const btn = item.querySelector('.block-item-btn');
        btn.onclick = async () => {
            // 恢复所有同标题的书签
            for (const id of allIds) {
                await unblockBookmark(id);
            }
            await loadBlockedLists();
            await refreshRecommendCards();
        };

        listEl.appendChild(item);
    }
}

// 加载已屏蔽文件夹列表
async function loadBlockedFoldersList(folderIds) {
    const listEl = document.getElementById('blockedFoldersList');
    const countEl = document.getElementById('blockedFoldersCount');
    const emptyEl = document.getElementById('blockedFoldersEmpty');
    if (!listEl) return;

    if (countEl) countEl.textContent = folderIds.length;

    const items = listEl.querySelectorAll('.block-item');
    items.forEach(item => item.remove());

    if (folderIds.length === 0) {
        if (emptyEl) emptyEl.style.display = 'block';
        return;
    }

    if (emptyEl) emptyEl.style.display = 'none';

    for (const id of folderIds) {
        try {
            const folders = await new Promise(resolve => {
                browserAPI.bookmarks.get(id, resolve);
            });
            if (!folders || folders.length === 0) continue;
            const folder = folders[0];

            const item = document.createElement('div');
            item.className = 'block-item';
            item.innerHTML = `
                <i class="fas fa-folder block-item-icon" style="font-size: 18px; color: var(--warning);"></i>
                <div class="block-item-info">
                    <div class="block-item-title">${escapeHtml(folder.title)}</div>
                </div>
                <button class="block-item-btn" data-id="${id}">${currentLang === 'en' ? 'Restore' : '恢复'}</button>
            `;

            const btn = item.querySelector('.block-item-btn');
            btn.onclick = async () => {
                await unblockFolder(id);
                await loadBlockedLists();
                await refreshRecommendCards();
            };

            listEl.appendChild(item);
        } catch (e) { }
    }
}

// 加载已屏蔽域名列表
async function loadBlockedDomainsList(domains) {
    const listEl = document.getElementById('blockedDomainsList');
    const countEl = document.getElementById('blockedDomainsCount');
    const emptyEl = document.getElementById('blockedDomainsEmpty');
    if (!listEl) return;

    if (countEl) countEl.textContent = domains.length;

    const items = listEl.querySelectorAll('.block-item');
    items.forEach(item => item.remove());

    if (domains.length === 0) {
        if (emptyEl) emptyEl.style.display = 'block';
        return;
    }

    if (emptyEl) emptyEl.style.display = 'none';

    for (const domain of domains) {
        const item = document.createElement('div');
        item.className = 'block-item';
        item.innerHTML = `
            <i class="fas fa-globe block-item-icon" style="font-size: 18px; color: var(--accent-primary);"></i>
            <div class="block-item-info">
                <div class="block-item-title">${escapeHtml(domain)}</div>
            </div>
            <button class="block-item-btn" data-domain="${domain}">${currentLang === 'en' ? 'Restore' : '恢复'}</button>
        `;

        const btn = item.querySelector('.block-item-btn');
        btn.onclick = async () => {
            await unblockDomain(domain);
            await loadBlockedLists();
            await refreshRecommendCards();
        };

        listEl.appendChild(item);
    }
}

// 屏蔽/恢复文件夹
async function blockFolder(folderId) {
    try {
        const blocked = await getBlockedBookmarks();
        if (!blocked.folders.includes(folderId)) {
            blocked.folders.push(folderId);
            await browserAPI.storage.local.set({ recommend_blocked: blocked });
        }
        return true;
    } catch (e) {
        return false;
    }
}

async function unblockFolder(folderId) {
    try {
        const blocked = await getBlockedBookmarks();
        blocked.folders = blocked.folders.filter(id => id !== folderId);
        await browserAPI.storage.local.set({ recommend_blocked: blocked });
        return true;
    } catch (e) {
        return false;
    }
}

// 屏蔽/恢复域名
async function blockDomain(domain) {
    try {
        const blocked = await getBlockedBookmarks();
        if (!blocked.domains.includes(domain)) {
            blocked.domains.push(domain);
            await browserAPI.storage.local.set({ recommend_blocked: blocked });
        }
        return true;
    } catch (e) {
        return false;
    }
}

async function unblockDomain(domain) {
    try {
        const blocked = await getBlockedBookmarks();
        blocked.domains = blocked.domains.filter(d => d !== domain);
        await browserAPI.storage.local.set({ recommend_blocked: blocked });
        return true;
    } catch (e) {
        return false;
    }
}

// =============================================================================
// Phase 4: 权重公式计算 S = (w1×F + w2×C + w3×T + w4×D + w5×L) × R
// S = Score（推荐分数），值越高越优先推荐
// R = Recall（记忆度），基于遗忘曲线，复习后锐减，逐渐恢复
// =============================================================================

// ===== 书签推荐缓存机制（仅 storage.local） =====
// 所有S值计算已迁移到 background.js
// 这里只保留缓存读写函数

// 从 storage.local 获取所有缓存的S值
async function getScoresCache() {
    try {
        const result = await new Promise(resolve => {
            browserAPI.storage.local.get(['recommend_scores_cache'], resolve);
        });
        return result.recommend_scores_cache || {};
    } catch (e) {
        console.warn('[缓存] 读取S值缓存失败:', e);
        return {};
    }
}

// 保存所有S值到 storage.local
async function saveScoresCache(cache) {
    try {
        await browserAPI.storage.local.set({
            recommend_scores_cache: cache,
            recommend_scores_time: Date.now()
        });
        console.log('[缓存] S值缓存已保存:', Object.keys(cache).length, '个书签');
    } catch (e) {
        // 检测是否是配额问题
        if (e.message && (e.message.includes('QUOTA') || e.message.includes('quota'))) {
            console.warn('[缓存] 存储配额已满，尝试清理旧数据...');
            await cleanupStorageQuota();
            // 重试一次
            try {
                await browserAPI.storage.local.set({
                    recommend_scores_cache: cache,
                    recommend_scores_time: Date.now()
                });
                console.log('[缓存] 清理后保存成功');
            } catch (e2) {
                console.error('[缓存] 清理后仍然失败，请手动清理浏览器数据');
                showStorageFullWarning();
            }
        } else {
            console.warn('[缓存] 保存S值缓存失败:', e);
        }
    }
}

// 清理存储配额（当存储满时调用）
async function cleanupStorageQuota() {
    try {
        // 1. 清理超过1000条的已翻阅记录
        const result = await new Promise(resolve => {
            browserAPI.storage.local.get(['flippedBookmarks'], resolve);
        });
        if (result.flippedBookmarks && result.flippedBookmarks.length > 1000) {
            const trimmed = result.flippedBookmarks.slice(-1000);
            await browserAPI.storage.local.set({ flippedBookmarks: trimmed });
            console.log('[清理] 已翻阅记录从', result.flippedBookmarks.length, '条缩减到', trimmed.length, '条');
        }

        // 2. 清理过期的稍后复习记录（7天前）
        const postponed = await getPostponedBookmarks();
        const now = Date.now();
        const validPostponed = postponed.filter(p => p.manuallyAdded || p.postponeUntil > now - 7 * 24 * 60 * 60 * 1000);
        if (validPostponed.length < postponed.length) {
            await browserAPI.storage.local.set({ recommend_postponed: validPostponed });
            console.log('[清理] 过期稍后复习记录已清理:', postponed.length - validPostponed.length, '条');
        }

        // 3. 清理Canvas缩略图（最大的单项）
        await browserAPI.storage.local.remove(['bookmarkCanvasThumbnail']);
        console.log('[清理] Canvas缩略图已清理');

    } catch (e) {
        console.error('[清理] 清理存储失败:', e);
    }
}

// 显示存储满警告
function showStorageFullWarning() {
    const isZh = currentLang === 'zh_CN';
    const msg = isZh
        ? '存储空间已满，部分数据可能无法保存。请在浏览器设置中清理扩展数据。'
        : 'Storage is full. Some data may not be saved. Please clear extension data in browser settings.';

    if (typeof showToast === 'function') {
        showToast(msg, 5000);
    } else {
        console.error('[存储] ' + msg);
    }
}

// 获取单个书签的缓存S值
async function getCachedScore(bookmarkId) {
    const cache = await getScoresCache();
    return cache[bookmarkId] || null;
}

// 清除缓存
async function clearScoresCache() {
    await browserAPI.storage.local.remove(['recommend_scores_cache', 'recommend_scores_time']);
    console.log('[缓存] 已清除S值缓存');
}

// ===== P1: 缓存机制 =====
// 综合时间排行静态缓存（"全部"范围，按标题和URL双索引）
let trackingRankingCache = {
    byTitle: new Map(),   // 标题 -> { compositeMs, url }
    byUrl: new Map(),     // URL -> { compositeMs, title }
    loaded: false
};
let historyDataCache = null;
let historyCacheTime = 0;
const STATS_CACHE_TTL = 60000; // 1分钟缓存

// ===== P0: 加载综合时间排行缓存（"全部"范围）=====
async function loadTrackingRankingCache() {
    if (trackingRankingCache.loaded) {
        return trackingRankingCache;
    }

    try {
        const response = await browserAPI.runtime.sendMessage({
            action: 'getActiveSessions',
            startTime: 0,  // 全部范围
            endTime: Date.now()
        });

        if (response && response.success && response.sessions) {
            // 按标题聚合综合时间（与排行榜逻辑一致）
            const titleStats = new Map();
            for (const session of response.sessions) {
                const key = session.title || session.url;
                if (!titleStats.has(key)) {
                    titleStats.set(key, {
                        url: session.url,
                        title: session.title || session.url,
                        compositeMs: 0
                    });
                }
                const stat = titleStats.get(key);
                const sessionComposite = session.compositeMs ||
                    ((session.activeMs || 0) +
                        (session.idleFocusMs || session.pauseTotalMs || 0) * 0.8 +
                        (session.visibleMs || 0) * 0.5 +
                        (session.backgroundMs || 0) * 0.1);
                stat.compositeMs += sessionComposite;
            }

            // 构建双索引
            trackingRankingCache.byTitle.clear();
            trackingRankingCache.byUrl.clear();
            for (const [key, stat] of titleStats) {
                trackingRankingCache.byTitle.set(stat.title, stat);
                if (stat.url) {
                    trackingRankingCache.byUrl.set(stat.url, stat);
                }
            }
            trackingRankingCache.loaded = true;
            console.log('[T值缓存] 已加载综合时间排行:', titleStats.size, '条记录');
        }
    } catch (e) {
        console.warn('[T值缓存] 加载失败:', e);
    }
    return trackingRankingCache;
}

// 清除T值缓存（在数据变化时调用）
function clearTrackingRankingCache() {
    trackingRankingCache.byTitle.clear();
    trackingRankingCache.byUrl.clear();
    trackingRankingCache.loaded = false;
}

// ===== P0: 从静态缓存获取书签的综合时间（标题或URL匹配）=====
async function getTrackingDataFromDB() {
    // 确保缓存已加载
    await loadTrackingRankingCache();

    // 返回兼容旧格式的对象（供 batchGetBookmarkStats 使用）
    const result = {};
    for (const [url, stat] of trackingRankingCache.byUrl) {
        result[url] = {
            compositeMs: stat.compositeMs,
            title: stat.title
        };
    }
    return result;
}

// 根据书签获取综合时间（标题或URL匹配，并集）
async function getBookmarkCompositeTime(bookmark) {
    await loadTrackingRankingCache();

    // 优先URL匹配
    if (bookmark.url && trackingRankingCache.byUrl.has(bookmark.url)) {
        return trackingRankingCache.byUrl.get(bookmark.url).compositeMs;
    }

    // 其次标题匹配
    if (bookmark.title && trackingRankingCache.byTitle.has(bookmark.title)) {
        return trackingRankingCache.byTitle.get(bookmark.title).compositeMs;
    }

    return 0;
}

// ===== P2: 批量获取历史记录（URL+标题并集匹配，与点击记录一致）=====
let historyDataLoadingPromise = null; // 防止并发加载

async function getBatchHistoryData() {
    const now = Date.now();
    // 检查缓存
    if (historyDataCache && (now - historyCacheTime) < STATS_CACHE_TTL) {
        return historyDataCache;
    }

    // 如果正在加载，等待加载完成
    if (historyDataLoadingPromise) {
        return historyDataLoadingPromise;
    }

    // 开始加载，设置Promise锁
    historyDataLoadingPromise = (async () => {
        try {
            if (!browserAPI?.history?.search) {
                return { original: new Map(), title: new Map() };
            }

            const historyItems = await new Promise((resolve) => {
                browserAPI.history.search({
                    text: '',
                    startTime: 0,
                    maxResults: 50000
                }, (results) => {
                    if (browserAPI.runtime?.lastError) {
                        resolve([]);
                    } else {
                        resolve(results || []);
                    }
                });
            });

            const originalMap = new Map();  // URL映射
            const titleMap = new Map();    // 标题映射（与点击记录一致的并集匹配）

            for (const item of historyItems) {
                if (item.url) {
                    const data = {
                        visitCount: item.visitCount || 0,
                        lastVisitTime: item.lastVisitTime || 0
                    };
                    // URL映射
                    originalMap.set(item.url, data);

                    // 标题映射
                    const title = item.title && item.title.trim();
                    if (title) {
                        if (!titleMap.has(title)) {
                            titleMap.set(title, data);
                        } else {
                            const existing = titleMap.get(title);
                            titleMap.set(title, {
                                visitCount: existing.visitCount + data.visitCount,
                                lastVisitTime: Math.max(existing.lastVisitTime, data.lastVisitTime)
                            });
                        }
                    }
                }
            }

            // 更新缓存（URL + 标题，与点击记录一致）
            historyDataCache = { original: originalMap, title: titleMap };
            historyCacheTime = Date.now();
            console.log('[权重计算] 历史数据已加载:', originalMap.size, '条URL,', titleMap.size, '条标题');
            return historyDataCache;
        } catch (e) {
            console.warn('[权重计算] 批量获取历史数据失败:', e);
            return { original: new Map(), title: new Map() };
        } finally {
            historyDataLoadingPromise = null; // 清除锁
        }
    })();

    return historyDataLoadingPromise;
}

// 获取书签的访问统计数据（保留用于单个查询场景）
async function getBookmarkVisitStats(url) {
    try {
        if (!browserAPI?.history?.getVisits) {
            return { visitCount: 0, lastVisitTime: 0 };
        }

        const visits = await new Promise((resolve) => {
            browserAPI.history.getVisits({ url }, (results) => {
                if (browserAPI.runtime?.lastError) {
                    resolve([]);
                } else {
                    resolve(results || []);
                }
            });
        });

        return {
            visitCount: visits.length,
            lastVisitTime: visits.length > 0 ? Math.max(...visits.map(v => v.visitTime)) : 0
        };
    } catch (e) {
        return { visitCount: 0, lastVisitTime: 0 };
    }
}

// =============================================================================
// Phase 4.1: 复习曲线（简化版SM-2）
// =============================================================================

// 获取复习数据
async function getReviewData() {
    try {
        const result = await browserAPI.storage.local.get('recommend_reviews');
        return result.recommend_reviews || {};
    } catch (e) {
        console.error('[复习] 获取复习数据失败:', e);
        return {};
    }
}

// 记录一次复习
async function recordReview(bookmarkId) {
    try {
        const reviews = await getReviewData();
        const existing = reviews[bookmarkId];
        const now = Date.now();

        // 如果是手动添加的书签，复习后清除标记
        const postponed = await getPostponedBookmarks();
        const postponeInfo = postponed.find(p => p.bookmarkId === bookmarkId);
        if (postponeInfo && postponeInfo.manuallyAdded) {
            postponeInfo.manuallyAdded = false;
            await browserAPI.storage.local.set({ recommend_postponed: postponed });
            console.log('[复习] 已清除手动添加标记:', bookmarkId);
        }

        if (existing) {
            // 简化版SM-2：每次复习间隔翻倍，最大30天
            const newInterval = Math.min(existing.interval * 2, 30);
            reviews[bookmarkId] = {
                lastReview: now,
                interval: newInterval,
                reviewCount: existing.reviewCount + 1,
                nextReview: now + newInterval * 24 * 60 * 60 * 1000
            };
        } else {
            // 首次复习，间隔1天
            reviews[bookmarkId] = {
                lastReview: now,
                interval: 1,
                reviewCount: 1,
                nextReview: now + 1 * 24 * 60 * 60 * 1000
            };
        }

        await browserAPI.storage.local.set({ recommend_reviews: reviews });
        console.log('[复习] 已记录复习:', bookmarkId, '下次间隔:', reviews[bookmarkId].interval, '天');

        // R因子变化，发消息给background.js更新S值
        browserAPI.runtime.sendMessage({ action: 'updateBookmarkScore', bookmarkId });

        return reviews[bookmarkId];
    } catch (e) {
        console.error('[复习] 记录复习失败:', e);
        return null;
    }
}

// 获取书签的复习状态
function getReviewStatus(bookmarkId, reviewData) {
    const review = reviewData[bookmarkId];
    if (!review) return { status: 'new', label: '新书签' };

    const now = Date.now();
    const daysSinceReview = (now - review.lastReview) / (1000 * 60 * 60 * 24);

    if (now >= review.nextReview) {
        return { status: 'due', label: '待复习', priority: 1.2 };
    } else if (daysSinceReview >= review.interval * 0.7) {
        return { status: 'soon', label: '即将到期', priority: 1.1 };
    } else {
        return { status: 'reviewed', label: '已复习', priority: 0.8 };
    }
}

// 计算带复习状态的优先级（用于保存的卡片恢复）
function calculatePriorityWithReview(basePriority, bookmarkId, reviewData, postponeData) {
    let priority = basePriority;

    // 复习状态加成
    const reviewStatus = getReviewStatus(bookmarkId, reviewData);
    priority *= reviewStatus.priority || 1.0;

    // 惩罚因子：被多次推迟的书签降低优先级（不影响手动添加的）
    if (postponeData) {
        const postponeInfo = postponeData.find(p => p.bookmarkId === bookmarkId);
        if (postponeInfo && !postponeInfo.manuallyAdded && postponeInfo.postponeCount > 0) {
            const penaltyFactor = Math.pow(0.9, postponeInfo.postponeCount);
            priority *= penaltyFactor;
        }
    }

    return Math.min(priority, 1.5); // 最高1.5
}

// 启动时间捕捉实时刷新（当前会话1秒刷新，排行榜10秒刷新）
function startTrackingRefresh() {
    // 清除已有定时器
    if (trackingRefreshInterval) {
        clearInterval(trackingRefreshInterval);
    }
    if (rankingRefreshInterval) {
        clearInterval(rankingRefreshInterval);
    }

    // 当前会话状态实时刷新（1秒）
    trackingRefreshInterval = setInterval(() => {
        if (currentView === 'additions') {
            const trackingPanel = document.getElementById('additionsTrackingPanel');
            if (trackingPanel && trackingPanel.classList.contains('active')) {
                // 只刷新当前会话（实时显示计时）
                loadCurrentTrackingSessions();
            }
        }
    }, TRACKING_REFRESH_INTERVAL);

    // 排行榜定时刷新（10秒）
    rankingRefreshInterval = setInterval(() => {
        if (currentView === 'additions') {
            const trackingPanel = document.getElementById('additionsTrackingPanel');
            if (trackingPanel && trackingPanel.classList.contains('active')) {
                // 刷新排行榜
                loadActiveTimeRanking();
            }
        }
    }, RANKING_REFRESH_INTERVAL);
}

// 停止实时刷新
function stopTrackingRefresh() {
    if (trackingRefreshInterval) {
        clearInterval(trackingRefreshInterval);
        trackingRefreshInterval = null;
    }
    if (rankingRefreshInterval) {
        clearInterval(rankingRefreshInterval);
        rankingRefreshInterval = null;
    }
}

// 刷新推荐卡片（三卡并排）
// 获取已翻过的书签ID列表
async function getFlippedBookmarks() {
    return new Promise((resolve) => {
        browserAPI.storage.local.get(['flippedBookmarks'], (result) => {
            resolve(result.flippedBookmarks || []);
        });
    });
}

// 标记书签为已翻过，并记录翻牌时间
async function markBookmarkFlipped(bookmarkId) {
    console.log('[翻牌] 标记书签:', bookmarkId);

    const flipped = await getFlippedBookmarks();
    if (!flipped.includes(bookmarkId)) {
        flipped.push(bookmarkId);
        await browserAPI.storage.local.set({ flippedBookmarks: flipped });
        console.log('[翻牌] flippedBookmarks 已更新:', flipped.length, '个');
    }

    // 记录翻牌时间（用于热力图）
    const result = await new Promise(resolve => {
        browserAPI.storage.local.get(['flipHistory'], resolve);
    });
    const flipHistory = result.flipHistory || [];
    flipHistory.push({
        bookmarkId,
        timestamp: Date.now()
    });
    await browserAPI.storage.local.set({ flipHistory });
    console.log('[翻牌] flipHistory 已更新:', flipHistory.length, '条记录');

    // 立即刷新热力图
    if (currentView === 'recommend') {
        await loadHeatmapData();
    }
}

async function refreshRecommendCards(force = false) {
    const cardsRow = document.getElementById('cardsRow');
    if (!cardsRow) return;

    const cards = cardsRow.querySelectorAll('.recommend-card');

    // 清除所有卡片的 flipped 状态
    cards.forEach(card => card.classList.remove('flipped'));

    try {
        // 获取所有书签（用于后续查找）
        const bookmarks = await new Promise((resolve) => {
            browserAPI.bookmarks.getTree((tree) => {
                const allBookmarks = [];
                function traverse(nodes) {
                    for (const node of nodes) {
                        if (node.url) {
                            allBookmarks.push(node);
                        }
                        if (node.children) {
                            traverse(node.children);
                        }
                    }
                }
                traverse(tree);
                resolve(allBookmarks);
            });
        });
        const bookmarkMap = new Map(bookmarks.map(b => [b.id, b]));

        // 一次性获取所有缓存的S值
        let scoresCache = await getScoresCache();

        // 如果S值缓存为空，请求background.js全量计算
        if (Object.keys(scoresCache).length === 0 && bookmarks.length > 0) {
            console.log('[书签推荐] S值缓存为空，请求background计算...');
            await new Promise(resolve => {
                browserAPI.runtime.sendMessage({ action: 'computeBookmarkScores' }, resolve);
            });
            scoresCache = await getScoresCache();
        }

        // 检查是否有已保存的卡片状态（与popup共享）
        const currentCards = await getHistoryCurrentCards();
        const postponed = await getPostponedBookmarks();
        const reviewData = await getReviewData();

        // 如果有保存的卡片且不是全部勾选且不是强制刷新，则显示保存的卡片
        if (currentCards && currentCards.cardIds && currentCards.cardIds.length > 0 && !force) {
            const allFlipped = currentCards.cardIds.every(id => currentCards.flippedIds.includes(id));

            if (!allFlipped) {
                // 恢复保存的卡片，直接使用缓存
                const savedBookmarks = currentCards.cardIds.map(id => bookmarkMap.get(id)).filter(Boolean);

                recommendCards = savedBookmarks.map(bookmark => {
                    const cached = scoresCache[bookmark.id];
                    const reviewStatus = getReviewStatus(bookmark.id, reviewData);
                    if (cached) {
                        return { ...bookmark, priority: cached.S, factors: cached, reviewStatus };
                    }
                    // 缓存不存在时返回默认值
                    return { ...bookmark, priority: 0.5, factors: {}, reviewStatus };
                });

                // 更新卡片显示
                cards.forEach((card, index) => {
                    if (index < recommendCards.length) {
                        const bookmark = recommendCards[index];
                        updateCardDisplay(card, bookmark, currentCards.flippedIds.includes(bookmark.id));
                    } else {
                        setCardEmpty(card);
                    }
                });
                return;
            }
        }

        // 获取已翻过的书签
        const flippedBookmarks = await getFlippedBookmarks();
        const flippedSet = new Set(flippedBookmarks);

        // 获取已屏蔽的书签、文件夹、域名
        const blocked = await getBlockedBookmarks();
        const blockedBookmarkSet = new Set(blocked.bookmarks);
        const blockedFolderSet = new Set(blocked.folders);
        const blockedDomainSet = new Set(blocked.domains);

        // 获取稍后复习的书签（未到期的，但手动添加的不排除）
        const now = Date.now();
        const postponedSet = new Set(
            postponed.filter(p => p.postponeUntil > now && !p.manuallyAdded).map(p => p.bookmarkId)
        );

        // 检查书签是否在屏蔽的文件夹中
        const isInBlockedFolder = (bookmark) => {
            if (blockedFolderSet.size === 0) return false;
            let parentId = bookmark.parentId;
            while (parentId) {
                if (blockedFolderSet.has(parentId)) return true;
                break;
            }
            return false;
        };

        // 检查书签是否在屏蔽的域名中
        const isBlockedDomain = (bookmark) => {
            if (blockedDomainSet.size === 0 || !bookmark.url) return false;
            try {
                const url = new URL(bookmark.url);
                return blockedDomainSet.has(url.hostname);
            } catch {
                return false;
            }
        };

        // 基础过滤：已翻过、已跳过、已屏蔽、稀后复习
        const baseFilter = (b) =>
            !flippedSet.has(b.id) &&
            !skippedBookmarks.has(b.id) &&
            !blockedBookmarkSet.has(b.id) &&
            !isInBlockedFolder(b) &&
            !isBlockedDomain(b) &&
            !postponedSet.has(b.id);

        // 刷新时跳过当前显示的卡片（force=true时）
        const currentCardIds = new Set(
            force && currentCards?.cardIds ? currentCards.cardIds : []
        );

        // 先尝试排除当前卡片
        let availableBookmarks = bookmarks.filter(b =>
            baseFilter(b) && !currentCardIds.has(b.id)
        );

        // 如果排除后不足3个，则不排除当前卡片
        if (availableBookmarks.length < 3 && currentCardIds.size > 0) {
            availableBookmarks = bookmarks.filter(baseFilter);
        }

        if (availableBookmarks.length === 0) {
            await saveHistoryCurrentCards([], []);
            cards.forEach((card) => {
                card.classList.add('empty');
                card.querySelector('.card-title').textContent =
                    currentLang === 'en' ? 'All bookmarks reviewed!' : '所有书签都已翻阅！';
                card.querySelector('.card-priority').textContent = '';
                card.onclick = null;
            });
            return;
        }

        // 从缓存读取所有可用书签的S值，直接排序取top3
        // S值通过增量更新机制保持最新，或在手动刷新时全量重算
        const bookmarksWithPriority = availableBookmarks.map(b => {
            const cached = scoresCache[b.id];
            const reviewStatus = getReviewStatus(b.id, reviewData);
            if (cached) {
                return { ...b, priority: cached.S, factors: cached, reviewStatus };
            }
            // 缓存不存在时返回默认值（新书签或首次使用）
            return { ...b, priority: 0.5, factors: {}, reviewStatus };
        });

        // 按优先级排序（高优先级在前），S值相同时添加随机因子
        bookmarksWithPriority.sort((a, b) => {
            const diff = b.priority - a.priority;
            // S值差异小于0.01时，添加随机因子
            if (Math.abs(diff) < 0.01) {
                return Math.random() - 0.5;
            }
            return diff;
        });
        recommendCards = bookmarksWithPriority.slice(0, 3);

        // 保存新的卡片状态
        const newCardIds = recommendCards.map(b => b.id);
        await saveHistoryCurrentCards(newCardIds, []);

        // 预加载当前3个 + 下一批6个的 favicon（并行）
        const urlsToPreload = bookmarksWithPriority.slice(0, 9).map(b => b.url).filter(Boolean);
        preloadHighResFavicons(urlsToPreload);

        // 异步保存favicon URLs到storage（供popup使用，不阻塞UI）
        saveCardFaviconsToStorage(recommendCards);

        // 更新卡片显示
        cards.forEach((card, index) => {
            if (index < recommendCards.length) {
                const bookmark = recommendCards[index];
                updateCardDisplay(card, bookmark, false);
            } else {
                setCardEmpty(card);
            }
        });

        // 更新刷新时间（手动刷新时）
        if (force) {
            const settings = await getRefreshSettings();
            settings.lastRefreshTime = Date.now();
            settings.openCountSinceRefresh = 0;
            await saveRefreshSettings(settings);
            console.log('[刷新] 已更新刷新时间');
        }

    } catch (error) {
        console.error('[书签推荐] 刷新卡片失败:', error);
        cards.forEach(card => {
            card.classList.add('empty');
            card.querySelector('.card-title').textContent =
                currentLang === 'en' ? 'Load failed' : '加载失败';
        });
    }
}

// 缓存当前追踪列表的会话 ID，用于判断是否需要完整刷新
let lastTrackingSessionIds = [];
// 记录展开状态的分组
let expandedTrackingGroups = new Set();

async function loadCurrentTrackingSessions() {
    const trackingCurrentList = document.getElementById('trackingCurrentList');
    const trackingCurrentCount = document.getElementById('trackingCurrentCount');
    if (!trackingCurrentList) return;

    try {
        const response = await browserAPI.runtime.sendMessage({
            action: 'getCurrentActiveSessions'
        });

        if (response && response.success && response.sessions) {
            let sessions = response.sessions;

            // 过滤掉被时间追踪屏蔽的会话
            const blockedSets = await getTrackingBlockedSets();
            const cache = await getTrackingBookmarkCache();
            const blockedFlags = await Promise.all(
                sessions.map(session => isTrackingItemBlocked(session, blockedSets, cache))
            );
            sessions = sessions.filter((_, index) => !blockedFlags[index]);

            // 更新计数
            if (trackingCurrentCount) {
                trackingCurrentCount.textContent = sessions.length;
            }

            if (sessions.length === 0) {
                lastTrackingSessionIds = [];
                trackingCurrentList.innerHTML = `
                    <tr class="tracking-empty-row">
                        <td colspan="5">${i18n.trackingNoActive[currentLang]}</td>
                    </tr>
                `;
                return;
            }

            // 按标题分组（标题相同视为同一书签）
            const groupedSessions = new Map();
            for (const session of sessions) {
                const key = session.title || session.url;
                if (!groupedSessions.has(key)) {
                    groupedSessions.set(key, []);
                }
                groupedSessions.get(key).push(session);
            }

            // 检查会话列表是否有变化（新增/删除会话）
            const currentIds = sessions.map(s => s.tabId).sort().join(',');
            const lastIds = lastTrackingSessionIds.sort().join(',');
            const needsFullRender = currentIds !== lastIds;

            // 截断标题函数
            const truncateTitle = (title, maxLen = 45) => {
                if (!title) return '';
                return title.length > maxLen ? title.substring(0, maxLen) + '...' : title;
            };

            if (needsFullRender) {
                // 会话列表有变化，需要完整渲染
                lastTrackingSessionIds = sessions.map(s => s.tabId);

                let html = '';
                for (const [groupKey, groupSessions] of groupedSessions) {
                    const isMultiple = groupSessions.length > 1;
                    const isExpanded = expandedTrackingGroups.has(groupKey);

                    // 使用第一个会话作为代表
                    const primarySession = groupSessions[0];

                    // 计算分组的汇总数据
                    const totalCompositeMs = groupSessions.reduce((sum, s) => sum + (s.compositeMs || s.activeMs || 0), 0);
                    const totalWakeCount = groupSessions.reduce((sum, s) => sum + (s.wakeCount || 0), 0);
                    const avgActiveRatio = groupSessions.reduce((sum, s) => sum + (s.activeRatio || 0), 0) / groupSessions.length;

                    // 确定显示的状态（优先显示最活跃的状态）
                    const stateOrder = ['active', 'visible', 'paused', 'background', 'sleeping'];
                    const bestState = groupSessions.reduce((best, s) => {
                        const bestIdx = stateOrder.indexOf(best);
                        const currIdx = stateOrder.indexOf(s.state);
                        return currIdx < bestIdx ? s.state : best;
                    }, 'sleeping');

                    const stateIcon = bestState === 'active' ? '🟢' :
                        (bestState === 'sleeping' ? '💤' :
                            (bestState === 'background' ? '⚪' :
                                (bestState === 'visible' ? '🔵' : '🟡')));

                    const compositeTime = formatActiveTime(totalCompositeMs);
                    const activeRatio = Math.round(avgActiveRatio * 100);
                    const displayTitle = truncateTitle(primarySession.title || primarySession.url);
                    const faviconUrl = getFaviconUrl(primarySession.url);

                    // 判断是否有任一会话处于挂机状态
                    const hasIdle = groupSessions.some(s => s.isIdle);
                    // 活跃率颜色：挂机=橙色，否则按梯度绿色
                    const ratioColorClass = hasIdle ? 'ratio-idle' : `ratio-level-${Math.min(Math.floor(activeRatio / 20), 5)}`;
                    // 唤醒次数高亮（≥15次用橙色）
                    const wakesHighlight = totalWakeCount >= 15 ? 'wakes-highlight' : '';
                    // 综合时间梯度蓝色
                    const timeGradientClass = `time-level-${getTimeGradientLevel(totalCompositeMs)}`;

                    // 主行（分组头）
                    const groupBadge = isMultiple ?
                        `<span class="tracking-group-badge" data-group-key="${escapeHtml(groupKey)}">${groupSessions.length}</span>` : '';
                    const expandIcon = isMultiple ?
                        `<span class="tracking-expand-icon ${isExpanded ? 'expanded' : ''}" data-group-key="${escapeHtml(groupKey)}">▶</span>` : '';

                    html += `
                        <tr class="tracking-group-header ${isMultiple ? 'has-children' : ''}" 
                            data-tab-id="${primarySession.tabId}" 
                            data-bookmark-url="${escapeHtml(primarySession.url)}"
                            data-group-key="${escapeHtml(groupKey)}">
                            <td><span class="tracking-state">${stateIcon}</span></td>
                            <td>
                                <div class="tracking-title-cell">
                                    ${expandIcon}
                                    <img class="tracking-favicon" src="${faviconUrl}" alt="">
                                    <span class="tracking-title" title="${escapeHtml(primarySession.title || primarySession.url)}">${escapeHtml(displayTitle)}</span>
                                    ${groupBadge}
                                </div>
                            </td>
                            <td><span class="tracking-time ${timeGradientClass}">${compositeTime}</span></td>
                            <td><span class="tracking-wakes ${wakesHighlight}">${totalWakeCount}${currentLang === 'en' ? 'x' : '次'}</span></td>
                            <td>
                                <div class="tracking-ratio-cell">
                                    <span class="tracking-ratio ${ratioColorClass}">${activeRatio}%</span>
                                </div>
                            </td>
                        </tr>
                    `;

                    // 展开的子行（仅当有多个且展开时显示）
                    if (isMultiple && isExpanded) {
                        for (const session of groupSessions) {
                            const subStateIcon = session.state === 'active' ? '🟢' :
                                (session.state === 'sleeping' ? '💤' :
                                    (session.state === 'background' ? '⚪' :
                                        (session.state === 'visible' ? '🔵' : '🟡')));
                            const subCompositeTime = formatActiveTime(session.compositeMs || session.activeMs);
                            const subActiveRatio = Math.round(session.activeRatio * 100);
                            // 活跃率颜色：挂机=橙色，否则按梯度绿色
                            const subRatioColorClass = session.isIdle ? 'ratio-idle' : `ratio-level-${Math.min(Math.floor(subActiveRatio / 20), 5)}`;
                            // 唤醒次数高亮（≥15次用橙色）
                            const subWakesHighlight = (session.wakeCount || 0) >= 15 ? 'wakes-highlight' : '';
                            // 综合时间梯度蓝色
                            const subTimeGradientClass = `time-level-${getTimeGradientLevel(session.compositeMs || session.activeMs)}`;

                            // 计算会话开始时间
                            const startTimestamp = Date.now() - (session.totalMs || 0);
                            const startDate = new Date(startTimestamp);
                            const month = startDate.getMonth() + 1;
                            const day = startDate.getDate();
                            const timeStr = startDate.toLocaleTimeString(currentLang === 'en' ? 'en-US' : 'zh-CN', {
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                            const dateTimeStr = currentLang === 'en'
                                ? `${month}/${day} ${timeStr}`
                                : `${month}月${day}日 ${timeStr}`;
                            const startLabel = currentLang === 'en' ? `Started ${dateTimeStr}` : `开始于 ${dateTimeStr}`;

                            html += `
                                <tr class="tracking-group-child" 
                                    data-tab-id="${session.tabId}" 
                                    data-bookmark-url="${escapeHtml(session.url)}"
                                    data-group-key="${escapeHtml(groupKey)}">
                                    <td><span class="tracking-state">${subStateIcon}</span></td>
                                    <td>
                                        <div class="tracking-title-cell tracking-child-title">
                                            <span class="tracking-window-label">${startLabel}</span>
                                        </div>
                                    </td>
                                    <td><span class="tracking-time ${subTimeGradientClass}">${subCompositeTime}</span></td>
                                    <td><span class="tracking-wakes ${subWakesHighlight}">${session.wakeCount || 0}${currentLang === 'en' ? 'x' : '次'}</span></td>
                                    <td>
                                        <div class="tracking-ratio-cell">
                                            <span class="tracking-ratio ${subRatioColorClass}">${subActiveRatio}%</span>
                                        </div>
                                    </td>
                                </tr>
                            `;
                        }
                    }
                }

                trackingCurrentList.innerHTML = html;

                // 点击展开/折叠分组
                trackingCurrentList.querySelectorAll('.tracking-group-header.has-children').forEach(row => {
                    row.addEventListener('click', (e) => {
                        const groupKey = row.dataset.groupKey;
                        // 如果点击的是展开图标或徽章，切换展开状态
                        if (e.target.classList.contains('tracking-expand-icon') ||
                            e.target.classList.contains('tracking-group-badge') ||
                            e.target.classList.contains('tracking-title-cell')) {
                            if (expandedTrackingGroups.has(groupKey)) {
                                expandedTrackingGroups.delete(groupKey);
                            } else {
                                expandedTrackingGroups.add(groupKey);
                            }
                            // 重新渲染
                            lastTrackingSessionIds = []; // 强制完整刷新
                            loadCurrentTrackingSessions();
                        } else {
                            // 点击其他区域，切换到对应标签页
                            const tabId = parseInt(row.dataset.tabId);
                            if (tabId) {
                                browserAPI.tabs.update(tabId, { active: true });
                            }
                        }
                    });
                });

                // 点击子行切换到对应标签页
                trackingCurrentList.querySelectorAll('.tracking-group-child').forEach(row => {
                    row.addEventListener('click', () => {
                        const tabId = parseInt(row.dataset.tabId);
                        if (tabId) {
                            browserAPI.tabs.update(tabId, { active: true });
                        }
                    });
                });

                // 单个会话的行也可以点击切换
                trackingCurrentList.querySelectorAll('.tracking-group-header:not(.has-children)').forEach(row => {
                    row.addEventListener('click', () => {
                        const tabId = parseInt(row.dataset.tabId);
                        if (tabId) {
                            browserAPI.tabs.update(tabId, { active: true });
                        }
                    });
                });
            } else {
                // 会话列表没变，只更新时间、状态等动态数据
                for (const [groupKey, groupSessions] of groupedSessions) {
                    const row = trackingCurrentList.querySelector(`tr.tracking-group-header[data-group-key="${CSS.escape(groupKey)}"]`);
                    if (row) {
                        const isMultiple = groupSessions.length > 1;

                        // 计算分组的汇总数据
                        const totalCompositeMs = groupSessions.reduce((sum, s) => sum + (s.compositeMs || s.activeMs || 0), 0);
                        const totalWakeCount = groupSessions.reduce((sum, s) => sum + (s.wakeCount || 0), 0);
                        const avgActiveRatio = groupSessions.reduce((sum, s) => sum + (s.activeRatio || 0), 0) / groupSessions.length;

                        // 确定显示的状态
                        const stateOrder = ['active', 'visible', 'paused', 'background', 'sleeping'];
                        const bestState = groupSessions.reduce((best, s) => {
                            const bestIdx = stateOrder.indexOf(best);
                            const currIdx = stateOrder.indexOf(s.state);
                            return currIdx < bestIdx ? s.state : best;
                        }, 'sleeping');

                        const stateIcon = bestState === 'active' ? '🟢' :
                            (bestState === 'sleeping' ? '💤' :
                                (bestState === 'background' ? '⚪' :
                                    (bestState === 'visible' ? '🔵' : '🟡')));

                        const compositeTime = formatActiveTime(totalCompositeMs);
                        const activeRatio = Math.round(avgActiveRatio * 100);

                        // 更新主行
                        const stateEl = row.querySelector('.tracking-state');
                        if (stateEl) stateEl.textContent = stateIcon;

                        const timeEl = row.querySelector('.tracking-time');
                        if (timeEl) timeEl.textContent = compositeTime;

                        const wakesEl = row.querySelector('.tracking-wakes');
                        if (wakesEl) wakesEl.textContent = `${totalWakeCount}${currentLang === 'en' ? 'x' : '次'}`;

                        const ratioEl = row.querySelector('.tracking-ratio');
                        if (ratioEl) ratioEl.textContent = `${activeRatio}%`;
                    }

                    // 更新子行
                    if (expandedTrackingGroups.has(groupKey)) {
                        for (const session of groupSessions) {
                            const childRow = trackingCurrentList.querySelector(`tr.tracking-group-child[data-tab-id="${session.tabId}"]`);
                            if (childRow) {
                                const subStateIcon = session.state === 'active' ? '🟢' :
                                    (session.state === 'sleeping' ? '💤' :
                                        (session.state === 'background' ? '⚪' :
                                            (session.state === 'visible' ? '🔵' : '🟡')));
                                const subCompositeTime = formatActiveTime(session.compositeMs || session.activeMs);
                                const subActiveRatio = Math.round(session.activeRatio * 100);

                                const stateEl = childRow.querySelector('.tracking-state');
                                if (stateEl) stateEl.textContent = subStateIcon;

                                const timeEl = childRow.querySelector('.tracking-time');
                                if (timeEl) timeEl.textContent = subCompositeTime;

                                const wakesEl = childRow.querySelector('.tracking-wakes');
                                if (wakesEl) wakesEl.textContent = `${session.wakeCount || 0}${currentLang === 'en' ? 'x' : '次'}`;

                                const ratioEl = childRow.querySelector('.tracking-ratio');
                                if (ratioEl) ratioEl.textContent = `${subActiveRatio}%`;
                            }
                        }
                    }
                }
            }
        }
    } catch (error) {
        console.warn('[书签推荐] 加载追踪会话失败:', error);
    }
}

// HTML 转义函数
function escapeHtml(str) {
    if (!str) return '';
    return str.replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

// 快速 Tooltip 初始化（用于当前变化视图的按钮）
// 使用全局tooltip元素，附加到body，避免层级问题
let globalTooltipElement = null;
let tooltipHideTimer = null;

function initFastTooltips() {
    // 创建全局tooltip元素（如果不存在）
    if (!globalTooltipElement) {
        globalTooltipElement = document.createElement('div');
        globalTooltipElement.className = 'global-tooltip';
        document.body.appendChild(globalTooltipElement);
    }

    // 为当前变化视图的按钮绑定tooltip
    const buttons = document.querySelectorAll('.diff-header .diff-edit-btn.icon-only[title]');

    buttons.forEach(btn => {
        // 保存原始title并移除（防止浏览器原生tooltip）
        const tooltipText = btn.getAttribute('title');
        btn.dataset.tooltipText = tooltipText;
        btn.removeAttribute('title');

        btn.addEventListener('mouseenter', (e) => {
            if (tooltipHideTimer) {
                clearTimeout(tooltipHideTimer);
                tooltipHideTimer = null;
            }

            const text = btn.dataset.tooltipText;
            if (!text) return;

            globalTooltipElement.textContent = text;

            // 计算位置（按钮上方居中）
            const rect = btn.getBoundingClientRect();
            const tooltipRect = globalTooltipElement.getBoundingClientRect();

            let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
            let top = rect.top - 8 - globalTooltipElement.offsetHeight;

            // 确保不超出视口
            if (left < 8) left = 8;
            if (left + tooltipRect.width > window.innerWidth - 8) {
                left = window.innerWidth - tooltipRect.width - 8;
            }
            if (top < 8) {
                // 如果上方空间不足，显示在下方
                top = rect.bottom + 8;
            }

            globalTooltipElement.style.left = left + 'px';
            globalTooltipElement.style.top = top + 'px';
            globalTooltipElement.classList.add('visible');
        });

        btn.addEventListener('mouseleave', () => {
            tooltipHideTimer = setTimeout(() => {
                globalTooltipElement.classList.remove('visible');
            }, 100);
        });

        // 当按钮title动态更新时，同步更新dataset
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'attributes' && mutation.attributeName === 'title') {
                    const newTitle = btn.getAttribute('title');
                    if (newTitle) {
                        btn.dataset.tooltipText = newTitle;
                        btn.removeAttribute('title');
                    }
                }
            });
        });
        observer.observe(btn, { attributes: true });
    });
}

// =============================================================================
// 复习热力图 (GitHub 风格，当前月份在左)
// =============================================================================

async function loadHeatmapData() {
    const container = document.getElementById('heatmapContainer');
    if (!container) return;

    try {
        // 从 storage 获取翻牌历史记录
        const result = await new Promise(resolve => {
            browserAPI.storage.local.get(['flipHistory'], resolve);
        });
        const flipHistory = result.flipHistory || [];

        // 按日期统计翻牌次数
        const dailyCounts = new Map();
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // 辅助函数：获取本地日期字符串 (YYYY-MM-DD)
        const getLocalDateKey = (d) => {
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };

        // 初始化最近 52 周 + 本周的天数
        const daysToShow = 52 * 7 + today.getDay();
        for (let i = daysToShow - 1; i >= 0; i--) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const key = getLocalDateKey(date);
            dailyCounts.set(key, 0);
        }

        // 统计每天的翻牌次数
        for (const flip of flipHistory) {
            if (!flip.timestamp) continue;
            const date = new Date(flip.timestamp);
            const key = getLocalDateKey(date);
            if (dailyCounts.has(key)) {
                dailyCounts.set(key, (dailyCounts.get(key) || 0) + 1);
            }
        }

        // 渲染热力图（反转顺序，当前月份在左）
        renderHeatmap(container, dailyCounts);

    } catch (error) {
        console.error('[热力图] 加载失败:', error);
        container.innerHTML = `<div class="empty-state"><div class="empty-state-title">${currentLang === 'en' ? 'Failed to load heatmap' : '热力图加载失败'
            }</div></div>`;
    }
}

function renderHeatmap(container, dailyCounts) {
    const isEn = currentLang === 'en';
    const dayNames = isEn ? ['', 'Mon', '', 'Wed', '', 'Fri', ''] :
        ['', '一', '', '三', '', '五', ''];
    const monthNames = isEn ?
        ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] :
        ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];

    // 找出最大值用于计算颜色深度
    const counts = Array.from(dailyCounts.values());
    const maxCount = Math.max(...counts, 1);
    const totalReviews = counts.reduce((a, b) => a + b, 0);

    // 计算今天的复习次数
    const todayKey = `${new Date().getFullYear()}-${String(new Date().getMonth() + 1).padStart(2, '0')}-${String(new Date().getDate()).padStart(2, '0')}`;
    const todayReviews = dailyCounts.get(todayKey) || 0;

    // 按月分组数据
    const monthsData = new Map(); // year-month -> { year, month, days: [], totalCount }
    const entries = Array.from(dailyCounts.entries()).sort();

    for (const [dateStr, count] of entries) {
        const [year, month, day] = dateStr.split('-').map(Number);
        const date = new Date(year, month - 1, day);
        const dayOfWeek = date.getDay();
        const monthKey = `${year}-${month}`;

        if (!monthsData.has(monthKey)) {
            monthsData.set(monthKey, { year, month, days: [], totalCount: 0 });
        }

        monthsData.get(monthKey).days.push({ date: dateStr, count, dayOfWeek, day });
        monthsData.get(monthKey).totalCount += count;
    }

    // 构建显示顺序：当前月 + 今年12个月(1-12正序)
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1;

    const monthsArray = [];

    // 第一个：当前月份
    const currentMonthKey = `${currentYear}-${currentMonth}`;
    const currentMonthData = monthsData.get(currentMonthKey) || { year: currentYear, month: currentMonth, days: [], totalCount: 0 };
    monthsArray.push(currentMonthData);

    // 后面12个：今年1月、2月、3月...12月（正序）
    for (let m = 1; m <= 12; m++) {
        const key = `${currentYear}-${m}`;
        const data = monthsData.get(key) || { year: currentYear, month: m, days: [], totalCount: 0 };
        monthsArray.push(data);
    }

    console.log('[热力图] 月份顺序:', monthsArray.map(m => m.month).join(', '));

    // 生成 HTML
    let html = `<div class="heatmap-year-view">`;
    html += `<div class="heatmap-scroll-container">`;
    html += `<div class="heatmap-months-row">`;

    for (let idx = 0; idx < monthsArray.length; idx++) {
        const monthData = monthsArray[idx];
        const { year, month, days, totalCount } = monthData;
        const monthLabel = monthNames[month - 1];

        // idx=1 时在当前月份后添加分隔线，后面每3个月添加分隔线
        if (idx === 1) {
            // 当前月份与12个月之间的分隔线
            html += `<div class="heatmap-quarter-divider current-divider"></div>`;
        } else if (idx > 1 && (idx - 1) % 3 === 0) {
            // 12个月内部的季度分隔线（4月、7月、10月前）
            html += `<div class="heatmap-quarter-divider"></div>`;
        }

        // 获取一周开始日(中文:周一=1, 英文:周日=0)，与书签添加记录日历保持一致
        const weekStartDay = (typeof currentLang !== 'undefined' && currentLang === 'zh_CN') ? 1 : 0;

        // 获取这个月第一天是星期几
        const firstDay = new Date(year, month - 1, 1);
        const firstDayOfWeek = firstDay.getDay();

        // 获取这个月的天数
        const daysInMonth = new Date(year, month, 0).getDate();
        const dayCountMap = new Map(days.map(d => [d.day, d]));

        // 构建日历网格（横向7列）
        const calendarDays = [];

        // 填充第一行前面的空白（根据周开始日调整）
        const blankCells = (firstDayOfWeek - weekStartDay + 7) % 7;
        for (let i = 0; i < blankCells; i++) {
            calendarDays.push({ empty: true });
        }

        // 填充每一天
        for (let d = 1; d <= daysInMonth; d++) {
            const dayData = dayCountMap.get(d);
            if (dayData) {
                calendarDays.push(dayData);
            } else {
                calendarDays.push({ date: `${year}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`, count: 0, day: d });
            }
        }

        // 填充最后一行的空白
        while (calendarDays.length % 7 !== 0) {
            calendarDays.push({ empty: true });
        }

        // 判断是否是当前月份
        const isCurrentMonth = year === currentYear && month === currentMonth;
        const currentClass = isCurrentMonth ? ' current-month' : '';

        html += `<div class="heatmap-month-block${currentClass}" data-year="${year}" data-month="${month}">`;
        html += `<div class="heatmap-month-header">${monthLabel}</div>`;
        html += `<div class="heatmap-calendar">`;

        // 当天日期字符串，用于判断是否高亮
        const todayStr = `${currentYear}-${String(currentMonth).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

        // 按行输出（每行7个）
        for (let i = 0; i < calendarDays.length; i += 7) {
            html += '<div class="heatmap-row">';
            for (let j = 0; j < 7; j++) {
                const day = calendarDays[i + j];
                if (!day || day.empty) {
                    html += '<div class="heatmap-cell empty"></div>';
                } else {
                    // 固定阈值：0 / 1-15 / 16-50 / 51-150 / 151+
                    const level = day.count === 0 ? 0 :
                        day.count <= 15 ? 1 :
                            day.count <= 50 ? 2 :
                                day.count <= 150 ? 3 : 4;
                    // 判断是否是当天
                    const isToday = day.date === todayStr;
                    const todayClass = isToday ? ' today' : '';
                    if (day.count > 0) {
                        const [y, m, dd] = day.date.split('-').map(Number);
                        const tooltip = isEn ?
                            `${day.count} review${day.count !== 1 ? 's' : ''}, ${m}-${dd}` :
                            `${day.count}次, ${m}-${dd}`;
                        html += `<div class="heatmap-cell level-${level}${todayClass}" data-date="${day.date}" data-tooltip="${tooltip}"></div>`;
                    } else {
                        html += `<div class="heatmap-cell level-0${todayClass}" data-date="${day.date}"></div>`;
                    }
                }
            }
            html += '</div>';
        }

        html += `</div>`;
        html += `<div class="heatmap-month-count">${totalCount}</div>`;
        html += `</div>`;
    }

    html += `</div></div>`;

    // 底部统计和图例
    html += `
        <div class="heatmap-footer">
            <span class="heatmap-stats">${isEn ? 'Today' : '今天'} ${todayReviews} ${isEn ? 'reviews' : '次'}</span>
            <div class="heatmap-footer-right">
                <div class="heatmap-legend">
                    <span>${isEn ? 'Less' : '少'}</span>
                    <div class="heatmap-cell level-0"></div>
                    <div class="heatmap-cell level-1"></div>
                    <div class="heatmap-cell level-2"></div>
                    <div class="heatmap-cell level-3"></div>
                    <div class="heatmap-cell level-4"></div>
                    <span>${isEn ? 'More' : '多'}</span>
                </div>
                <button class="heatmap-help-btn" id="heatmapHelpBtn" title="${isEn ? 'Level description' : '等级说明'}">
                    <i class="fas fa-question-circle"></i>
                </button>
            </div>
        </div>
    </div>`;

    container.innerHTML = html;

    // 确保滚动条在最左边，显示当前月份
    const scrollContainer = container.querySelector('.heatmap-scroll-container');
    if (scrollContainer) {
        scrollContainer.scrollLeft = 0;
    }

    // 创建或获取全局tooltip元素
    let globalTooltip = document.getElementById('heatmapGlobalTooltip');
    if (!globalTooltip) {
        globalTooltip = document.createElement('div');
        globalTooltip.id = 'heatmapGlobalTooltip';
        globalTooltip.className = 'heatmap-global-tooltip';
        document.body.appendChild(globalTooltip);
    }

    // 绑定日期格子点击事件和tooltip事件
    container.querySelectorAll('.heatmap-cell[data-date]').forEach(cell => {
        cell.style.cursor = 'pointer';
        cell.addEventListener('click', (e) => {
            e.stopPropagation();
            // 点击时隐藏tooltip
            globalTooltip.classList.remove('visible');
            const date = cell.dataset.date;
            showHeatmapDateDetail(date);
        });

        // 鼠标进入时显示tooltip
        cell.addEventListener('mouseenter', (e) => {
            const tooltipText = cell.dataset.tooltip;
            if (!tooltipText) return;

            // 先设置内容并临时显示以获取正确尺寸
            globalTooltip.textContent = tooltipText;
            globalTooltip.style.visibility = 'hidden';
            globalTooltip.style.display = 'block';

            // 计算位置：在cell正上方居中
            const rect = cell.getBoundingClientRect();
            const tooltipRect = globalTooltip.getBoundingClientRect();
            let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
            let top = rect.top - tooltipRect.height - 8;

            // 防止超出左右边界
            if (left < 5) left = 5;
            if (left + tooltipRect.width > window.innerWidth - 5) {
                left = window.innerWidth - tooltipRect.width - 5;
            }

            // 如果上方空间不够，显示在下方
            if (top < 5) {
                top = rect.bottom + 8;
            }

            globalTooltip.style.left = left + 'px';
            globalTooltip.style.top = top + 'px';
            globalTooltip.style.visibility = '';
            globalTooltip.style.display = '';
            globalTooltip.classList.add('visible');
        });

        // 鼠标离开时隐藏tooltip
        cell.addEventListener('mouseleave', () => {
            globalTooltip.classList.remove('visible');
        });
    });

    // 绑定月份点击事件（进入月视图）
    container.querySelectorAll('.heatmap-month-block').forEach(block => {
        block.style.cursor = 'pointer';
        block.addEventListener('click', (e) => {
            // 如果点击的是日期格子，不触发月份点击
            if (e.target.closest('.heatmap-cell[data-date]')) return;
            const year = parseInt(block.dataset.year);
            const month = parseInt(block.dataset.month);
            showHeatmapMonthDetail(year, month);
        });
    });

    // 绑定帮助按钮点击事件
    const helpBtn = document.getElementById('heatmapHelpBtn');
    if (helpBtn) {
        helpBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showHeatmapLevelHelp(helpBtn);
        });
    }
}

// 显示热力图等级说明
function showHeatmapLevelHelp(anchorBtn) {
    const isEn = currentLang === 'en';

    // 如果已存在，先移除
    const existing = document.getElementById('heatmapLevelPopup');
    if (existing) {
        existing.remove();
        return;
    }

    const popup = document.createElement('div');
    popup.id = 'heatmapLevelPopup';
    popup.className = 'heatmap-level-popup';
    popup.innerHTML = `
        <div class="heatmap-level-title">${isEn ? 'Review Level' : '复习等级说明'}</div>
        <div class="heatmap-level-list">
            <div class="heatmap-level-row">
                <div class="heatmap-cell level-0"></div>
                <span>0 ${isEn ? 'reviews' : '次'}</span>
            </div>
            <div class="heatmap-level-row">
                <div class="heatmap-cell level-1"></div>
                <span>1-15 ${isEn ? 'reviews' : '次'}</span>
            </div>
            <div class="heatmap-level-row">
                <div class="heatmap-cell level-2"></div>
                <span>16-50 ${isEn ? 'reviews' : '次'}</span>
            </div>
            <div class="heatmap-level-row">
                <div class="heatmap-cell level-3"></div>
                <span>51-150 ${isEn ? 'reviews' : '次'}</span>
            </div>
            <div class="heatmap-level-row">
                <div class="heatmap-cell level-4"></div>
                <span>151+ ${isEn ? 'reviews' : '次'}</span>
            </div>
        </div>
    `;

    document.body.appendChild(popup);

    // 定位到按钮上方
    const rect = anchorBtn.getBoundingClientRect();
    popup.style.position = 'fixed';
    popup.style.bottom = (window.innerHeight - rect.top + 8) + 'px';
    popup.style.right = (window.innerWidth - rect.right) + 'px';

    // 点击其他地方关闭
    const closeHandler = (e) => {
        if (!popup.contains(e.target) && e.target !== anchorBtn) {
            popup.remove();
            document.removeEventListener('click', closeHandler);
        }
    };
    setTimeout(() => document.addEventListener('click', closeHandler), 0);
}

// 显示热力图日期详情（二级UI）
async function showHeatmapDateDetail(dateStr) {
    const isEn = currentLang === 'en';
    const container = document.getElementById('heatmapContainer');
    if (!container) return;

    // 获取翻牌历史
    const result = await new Promise(resolve => {
        browserAPI.storage.local.get(['flipHistory'], resolve);
    });
    const flipHistory = result.flipHistory || [];

    // 筛选当天的记录
    const dayRecords = flipHistory.filter(flip => {
        if (!flip.timestamp) return false;
        const date = new Date(flip.timestamp);
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const d = String(date.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}` === dateStr;
    });

    // 获取书签信息
    const bookmarkMap = new Map();
    try {
        const tree = await new Promise(resolve => browserAPI.bookmarks.getTree(resolve));
        const flatten = (nodes) => {
            for (const node of nodes) {
                if (node.url) bookmarkMap.set(node.id, node);
                if (node.children) flatten(node.children);
            }
        };
        flatten(tree);
    } catch (e) {
        console.warn('[热力图] 获取书签失败:', e);
    }

    // 格式化日期
    const [year, month, day] = dateStr.split('-').map(Number);
    const dateLabel = isEn ? `${month}/${day}/${year}` : `${year}年${month}月${day}日`;

    // 生成详情HTML
    let html = `
        <div class="heatmap-detail-view">
            <div class="heatmap-detail-header">
                <button class="heatmap-back-btn" id="heatmapBackBtn">
                    <i class="fas fa-arrow-left"></i>
                    <span>${isEn ? 'Back' : '返回'}</span>
                </button>
                <span class="heatmap-detail-title">${dateLabel}</span>
                <span class="heatmap-detail-count">${dayRecords.length} ${isEn ? 'reviews' : '次复习'}</span>
            </div>
            <div class="heatmap-detail-list">
    `;

    if (dayRecords.length === 0) {
        html += `<div class="heatmap-detail-empty">${isEn ? 'No reviews on this day' : '当天没有复习记录'}</div>`;
    } else {
        // 按时间倒序排列
        dayRecords.sort((a, b) => b.timestamp - a.timestamp);

        for (const record of dayRecords) {
            const bookmark = bookmarkMap.get(record.bookmarkId);
            const time = new Date(record.timestamp);
            const timeStr = `${String(time.getHours()).padStart(2, '0')}:${String(time.getMinutes()).padStart(2, '0')}`;

            if (bookmark) {
                html += `
                    <div class="heatmap-detail-item" data-url="${escapeHtml(bookmark.url)}">
                        <img class="heatmap-detail-favicon" src="${getFaviconUrl(bookmark.url)}">
                        <div class="heatmap-detail-info">
                            <div class="heatmap-detail-item-title">${escapeHtml(bookmark.title || bookmark.url)}</div>
                            <div class="heatmap-detail-item-url">${escapeHtml(bookmark.url)}</div>
                        </div>
                        <span class="heatmap-detail-time">${timeStr}</span>
                    </div>
                `;
            } else {
                html += `
                    <div class="heatmap-detail-item deleted">
                        <i class="fas fa-bookmark heatmap-detail-favicon-icon"></i>
                        <div class="heatmap-detail-info">
                            <div class="heatmap-detail-item-title">${isEn ? 'Bookmark deleted' : '书签已删除'}</div>
                            <div class="heatmap-detail-item-url">ID: ${record.bookmarkId}</div>
                        </div>
                        <span class="heatmap-detail-time">${timeStr}</span>
                    </div>
                `;
            }
        }
    }

    html += `</div></div>`;

    container.innerHTML = html;

    // 绑定返回按钮
    document.getElementById('heatmapBackBtn').addEventListener('click', () => {
        loadHeatmapData();
    });

    // 绑定书签点击事件
    container.querySelectorAll('.heatmap-detail-item[data-url]').forEach(item => {
        item.style.cursor = 'pointer';
        item.addEventListener('click', () => {
            const url = item.dataset.url;
            if (url) window.open(url, '_blank');
        });
    });
}

// 显示热力图月份详情（书签复习排行）
async function showHeatmapMonthDetail(year, month) {
    const isEn = currentLang === 'en';
    const container = document.getElementById('heatmapContainer');
    if (!container) return;

    // 获取翻牌历史
    const result = await new Promise(resolve => {
        browserAPI.storage.local.get(['flipHistory'], resolve);
    });
    const flipHistory = result.flipHistory || [];

    // 筛选当月的记录，按书签ID统计次数
    const bookmarkCountMap = new Map(); // bookmarkId -> { count, lastTime }
    for (const flip of flipHistory) {
        if (!flip.timestamp || !flip.bookmarkId) continue;
        const date = new Date(flip.timestamp);
        if (date.getFullYear() === year && date.getMonth() + 1 === month) {
            if (!bookmarkCountMap.has(flip.bookmarkId)) {
                bookmarkCountMap.set(flip.bookmarkId, { count: 0, lastTime: 0 });
            }
            const stat = bookmarkCountMap.get(flip.bookmarkId);
            stat.count++;
            if (flip.timestamp > stat.lastTime) stat.lastTime = flip.timestamp;
        }
    }

    // 获取书签信息
    const bookmarkMap = new Map();
    try {
        const tree = await new Promise(resolve => browserAPI.bookmarks.getTree(resolve));
        const flatten = (nodes) => {
            for (const node of nodes) {
                if (node.url) bookmarkMap.set(node.id, node);
                if (node.children) flatten(node.children);
            }
        };
        flatten(tree);
    } catch (e) {
        console.warn('[热力图] 获取书签失败:', e);
    }

    const monthNames = isEn ?
        ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'] :
        ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
    const monthLabel = isEn ? `${monthNames[month - 1]} ${year}` : `${year}年${monthNames[month - 1]}`;

    const totalCount = Array.from(bookmarkCountMap.values()).reduce((sum, s) => sum + s.count, 0);

    // 按复习次数排序
    const sortedBookmarks = Array.from(bookmarkCountMap.entries())
        .sort((a, b) => b[1].count - a[1].count);

    // 生成详情HTML
    let html = `
        <div class="heatmap-detail-view">
            <div class="heatmap-detail-header">
                <button class="heatmap-back-btn" id="heatmapBackBtn">
                    <i class="fas fa-arrow-left"></i>
                    <span>${isEn ? 'Back' : '返回'}</span>
                </button>
                <span class="heatmap-detail-title">${monthLabel} ${isEn ? 'Ranking' : '复习排行'}</span>
                <span class="heatmap-detail-count">${totalCount} ${isEn ? 'reviews' : '次复习'}</span>
            </div>
            <div class="heatmap-detail-list">
    `;

    if (sortedBookmarks.length === 0) {
        html += `<div class="heatmap-detail-empty">${isEn ? 'No reviews this month' : '当月没有复习记录'}</div>`;
    } else {
        let rank = 0;
        for (const [bookmarkId, stat] of sortedBookmarks) {
            rank++;
            const bookmark = bookmarkMap.get(bookmarkId);

            if (bookmark) {
                html += `
                    <div class="heatmap-detail-item heatmap-ranking-item" data-url="${escapeHtml(bookmark.url)}">
                        <span class="heatmap-rank ${rank <= 3 ? 'top-' + rank : ''}">${rank}</span>
                        <img class="heatmap-detail-favicon" src="${getFaviconUrl(bookmark.url)}">
                        <div class="heatmap-detail-info">
                            <div class="heatmap-detail-item-title">${escapeHtml(bookmark.title || bookmark.url)}</div>
                            <div class="heatmap-detail-item-url">${escapeHtml(bookmark.url)}</div>
                        </div>
                        <span class="heatmap-review-count">${stat.count} ${isEn ? 'times' : '次'}</span>
                    </div>
                `;
            } else {
                html += `
                    <div class="heatmap-detail-item heatmap-ranking-item deleted">
                        <span class="heatmap-rank">${rank}</span>
                        <i class="fas fa-bookmark heatmap-detail-favicon-icon"></i>
                        <div class="heatmap-detail-info">
                            <div class="heatmap-detail-item-title">${isEn ? 'Bookmark deleted' : '书签已删除'}</div>
                            <div class="heatmap-detail-item-url">ID: ${bookmarkId}</div>
                        </div>
                        <span class="heatmap-review-count">${stat.count} ${isEn ? 'times' : '次'}</span>
                    </div>
                `;
            }
        }
    }

    html += `</div></div>`;

    container.innerHTML = html;

    // 绑定返回按钮
    document.getElementById('heatmapBackBtn').addEventListener('click', () => {
        loadHeatmapData();
    });

    // 绑定书签点击事件
    container.querySelectorAll('.heatmap-detail-item[data-url]').forEach(item => {
        item.style.cursor = 'pointer';
        item.addEventListener('click', () => {
            const url = item.dataset.url;
            if (url) window.open(url, '_blank');
        });
    });
}

// =============================================================================
// 清除记录菜单
// =============================================================================

function showTrackingClearMenu(anchorEl) {
    // 移除已有菜单
    const existingMenu = document.getElementById('trackingClearMenu');
    if (existingMenu) existingMenu.remove();

    const isEn = currentLang === 'en';
    const rangeLabels = i18n.trackingClearRange[currentLang];

    const menu = document.createElement('div');
    menu.id = 'trackingClearMenu';
    menu.className = 'tracking-clear-menu';
    menu.innerHTML = `
        <div class="tracking-clear-menu-title">${isEn ? 'Clear Current Sessions' : '清除正在追踪'}</div>
        <div class="tracking-clear-menu-item" data-action="current">${isEn ? 'Clear all current sessions' : '清除全部当前会话'}</div>
        <div class="tracking-clear-menu-divider"></div>
        <div class="tracking-clear-menu-title">${isEn ? 'Clear Ranking Data' : '清除综合排行'}</div>
        <div class="tracking-clear-menu-item" data-action="ranking" data-range="week">${isEn ? 'Older than 1 week' : '一周以前'}</div>
        <div class="tracking-clear-menu-item" data-action="ranking" data-range="month">${isEn ? 'Older than 1 month' : '一个月以前'}</div>
        <div class="tracking-clear-menu-item" data-action="ranking" data-range="year">${isEn ? 'Older than 1 year' : '一年以前'}</div>
        <div class="tracking-clear-menu-item danger" data-action="ranking" data-range="all">${isEn ? 'Clear all' : '清除全部'}</div>
    `;

    // 定位菜单
    const rect = anchorEl.getBoundingClientRect();
    menu.style.position = 'fixed';
    menu.style.top = `${rect.bottom + 4}px`;
    menu.style.right = `${window.innerWidth - rect.right}px`;

    document.body.appendChild(menu);

    // 点击菜单项
    menu.querySelectorAll('.tracking-clear-menu-item').forEach(item => {
        item.addEventListener('click', async () => {
            const action = item.dataset.action;
            const range = item.dataset.range;

            if (action === 'current') {
                if (!confirm(i18n.trackingClearCurrentConfirm[currentLang])) {
                    menu.remove();
                    return;
                }
                try {
                    await browserAPI.runtime.sendMessage({ action: 'clearCurrentTrackingSessions' });
                    await loadCurrentTrackingSessions();
                    console.log('[时间捕捉] 正在追踪的会话已清除');
                } catch (e) {
                    console.error('[时间捕捉] 清除失败:', e);
                }
            } else if (action === 'ranking') {
                const rangeLabel = rangeLabels[range];
                const confirmMsg = i18n.trackingClearRangeConfirm[currentLang].replace('{range}', rangeLabel);
                if (!confirm(confirmMsg)) {
                    menu.remove();
                    return;
                }
                try {
                    const response = await browserAPI.runtime.sendMessage({
                        action: 'clearTrackingStatsByRange',
                        range: range
                    });
                    if (response && response.success) {
                        const msg = i18n.trackingClearedCount[currentLang].replace('{count}', response.cleared);
                        console.log('[时间捕捉]', msg);
                        await loadActiveTimeRanking();
                    }
                } catch (e) {
                    console.error('[时间捕捉] 清除失败:', e);
                }
            }
            menu.remove();
        });
    });

    // 点击外部关闭
    const closeMenu = (e) => {
        if (!menu.contains(e.target) && e.target !== anchorEl) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
        }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 0);
}

// =============================================================================
// 综合排行
// =============================================================================

async function loadActiveTimeRanking() {
    const container = document.getElementById('trackingRankingList');
    if (!container) return;

    // 排行榜刷新时，清除T值缓存，下次计算S值时会获取最新数据
    clearTrackingRankingCache();

    try {
        // 获取排行类型（综合时间 / 唤醒次数）
        const rankingTypeSelect = document.getElementById('trackingRankingType');
        const rankingType = rankingTypeSelect ? rankingTypeSelect.value : 'composite';

        // 获取时间范围
        const rangeSelect = document.getElementById('trackingRankingRange');
        const range = rangeSelect ? rangeSelect.value : 'week';

        // 并行获取：已保存的统计 + 当前正在追踪的会话
        const [statsResponse, sessionsResponse] = await Promise.all([
            browserAPI.runtime.sendMessage({ action: 'getTrackingStats' }),
            browserAPI.runtime.sendMessage({ action: 'getCurrentActiveSessions' })
        ]);

        // 合并数据：已保存的 + 当前正在追踪的
        const titleStats = new Map();

        // 1. 先加载已保存的统计
        if (statsResponse?.success && statsResponse.stats) {
            for (const stat of Object.values(statsResponse.stats)) {
                const key = stat.title || stat.url;
                titleStats.set(key, {
                    url: stat.url,
                    title: stat.title || stat.url,
                    totalCompositeMs: stat.totalCompositeMs || 0,
                    wakeCount: stat.totalWakeCount || 0,
                    sessionCount: stat.sessionCount || 0,
                    lastUpdate: stat.lastUpdate
                });
            }
        }

        // 2. 再加上当前正在追踪的会话（只加尚未保存的部分，避免与 trackingStats 重复）
        if (sessionsResponse?.success && sessionsResponse.sessions) {
            // 按标题分组，计算每组尚未保存的总和
            const groupedByTitle = new Map();
            for (const session of sessionsResponse.sessions) {
                const key = session.title || session.url;
                if (!groupedByTitle.has(key)) {
                    groupedByTitle.set(key, {
                        url: session.url,
                        title: session.title || session.url,
                        unsavedCompositeMs: 0,
                        unsavedWakeCount: 0
                    });
                }
                const group = groupedByTitle.get(key);
                // 使用 unsavedCompositeMs（尚未保存的时间），避免重复
                group.unsavedCompositeMs += session.unsavedCompositeMs || 0;
                group.unsavedWakeCount += session.unsavedWakeCount || 0;
            }

            // 合并到排行榜
            for (const [key, group] of groupedByTitle) {
                if (titleStats.has(key)) {
                    const existing = titleStats.get(key);
                    existing.totalCompositeMs += group.unsavedCompositeMs;
                    existing.wakeCount += group.unsavedWakeCount;
                } else {
                    titleStats.set(key, {
                        url: group.url,
                        title: group.title,
                        totalCompositeMs: group.unsavedCompositeMs,
                        wakeCount: group.unsavedWakeCount,
                        sessionCount: 1,
                        lastUpdate: Date.now()
                    });
                }
            }
        }

        if (titleStats.size === 0) {
            container.innerHTML = `<div class="tracking-empty">${i18n.trackingNoData[currentLang]}</div>`;
            return;
        }

        // 过滤掉被时间追踪屏蔽的项目
        const blockedSets = await getTrackingBlockedSets();
        const cache = await getTrackingBookmarkCache();
        const items = Array.from(titleStats.values());
        const blockedFlags = await Promise.all(
            items.map(item => isTrackingItemBlocked(item, blockedSets, cache))
        );

        // 根据排行类型排序，并过滤掉被屏蔽的项目
        const sorted = items
            .filter((_, index) => !blockedFlags[index])
            .sort((a, b) => {
                if (rankingType === 'wakes') {
                    return b.wakeCount - a.wakeCount;
                }
                return b.totalCompositeMs - a.totalCompositeMs;
            })
            .slice(0, 10);

        if (sorted.length === 0) {
            container.innerHTML = `<div class="tracking-empty">${i18n.trackingNoData[currentLang]}</div>`;
            return;
        }

        // 计算最大值用于进度条（根据排行类型）
        const maxValue = rankingType === 'wakes'
            ? sorted[0].wakeCount
            : sorted[0].totalCompositeMs;

        // 截断标题函数
        const truncateTitle = (title, maxLen = 45) => {
            if (!title) return '';
            return title.length > maxLen ? title.substring(0, maxLen) + '...' : title;
        };

        // 唤醒次数高频阈值（根据时间范围）
        const wakeThresholds = {
            'today': 15,
            'week': 50,
            'month': 100,
            'year': 500,
            'all': 1000
        };
        const wakeThreshold = wakeThresholds[range] || 15;

        // 渲染列表
        container.innerHTML = sorted.map((item, index) => {
            const compositeTime = formatActiveTime(item.totalCompositeMs);
            // 根据排行类型计算进度条宽度
            const barWidth = maxValue > 0
                ? ((rankingType === 'wakes' ? item.wakeCount : item.totalCompositeMs) / maxValue * 100)
                : 0;
            const displayTitle = truncateTitle(item.title || item.url);
            const faviconUrl = getFaviconUrl(item.url);

            // 高亮逻辑：根据排行类型选择主要指标的高亮
            let wakeHighlight = '';
            let timeHighlight = '';
            if (rankingType === 'wakes') {
                // 唤醒次数排行：唤醒次数用强调色（primary），时间正常显示
                wakeHighlight = 'ranking-primary';
                timeHighlight = `time-level-${getTimeGradientLevel(item.totalCompositeMs, range)}`;
            } else {
                // 综合时间排行：高频唤醒用橙色，时间用梯度蓝色
                wakeHighlight = item.wakeCount >= wakeThreshold ? 'wakes-highlight' : '';
                timeHighlight = `time-level-${getTimeGradientLevel(item.totalCompositeMs, range)} ranking-primary`;
            }

            return `
                <div class="tracking-ranking-item" data-url="${escapeHtml(item.url)}" data-bookmark-url="${escapeHtml(item.url)}">
                    <span class="ranking-number">${index + 1}</span>
                    <img class="ranking-favicon" src="${faviconUrl}" alt="">
                    <div class="ranking-info">
                        <div class="ranking-title" title="${escapeHtml(item.title || item.url)}">${escapeHtml(displayTitle)}</div>
                        <div class="ranking-bar">
                            <div class="ranking-bar-fill" style="width: ${barWidth}%"></div>
                        </div>
                    </div>
                    <span class="ranking-wakes ${wakeHighlight}">${item.wakeCount}${currentLang === 'en' ? 'x' : '次'}</span>
                    <span class="ranking-time ${timeHighlight}">${compositeTime}</span>
                </div>
            `;
        }).join('');

        // 点击打开对应URL
        container.querySelectorAll('.tracking-ranking-item').forEach(item => {
            item.addEventListener('click', () => {
                const url = item.dataset.url;
                if (url) {
                    browserAPI.tabs.create({ url });
                }
            });
        });

    } catch (error) {
        console.error('[综合排行] 加载失败:', error);
        container.innerHTML = `<div class="tracking-empty">${i18n.trackingLoadFailed[currentLang]}</div>`;
    }
}

function formatActiveTime(ms) {
    if (!ms || ms < 0) return '0s';

    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) {
        return `${hours}h${minutes % 60}m`;
    } else if (minutes > 0) {
        return `${minutes}m${seconds % 60}s`;
    } else {
        return `${seconds}s`;
    }
}

// 获取综合时间的梯度级别（用于蓝色深浅）
// range: 'today', 'week', 'month', 'year', 'all', 'current'（正在追踪）
// Level 0-4: 正常梯度蓝色，Level 5: 极端使用（深紫色）
function getTimeGradientLevel(ms, range = 'today') {
    const minutes = (ms || 0) / 60000;
    const hours = minutes / 60;

    // 根据时间范围使用不同的阈值
    if (range === 'week') {
        // 本周：30分钟、2小时、5小时、10小时、20小时（极端）
        if (minutes < 30) return 0;
        if (hours < 2) return 1;
        if (hours < 5) return 2;
        if (hours < 10) return 3;
        if (hours < 20) return 4;
        return 5;  // 极端：20小时+
    } else if (range === 'month') {
        // 本月：2小时、10小时、30小时、60小时、100小时（极端）
        if (hours < 2) return 0;
        if (hours < 10) return 1;
        if (hours < 30) return 2;
        if (hours < 60) return 3;
        if (hours < 100) return 4;
        return 5;  // 极端：100小时+
    } else if (range === 'year' || range === 'all') {
        // 本年/全部：10小时、50小时、150小时、300小时、500小时（极端）
        if (hours < 10) return 0;
        if (hours < 50) return 1;
        if (hours < 150) return 2;
        if (hours < 300) return 3;
        if (hours < 500) return 4;
        return 5;  // 极端：500小时+
    } else {
        // 今日/正在追踪（current）：1分钟、5分钟、15分钟、30分钟、2小时（极端）
        if (minutes < 1) return 0;
        if (minutes < 5) return 1;
        if (minutes < 15) return 2;
        if (minutes < 30) return 3;
        if (hours < 2) return 4;
        return 5;  // 极端：2小时+
    }
}


// =============================================================================
// 当前变化视图
// =============================================================================

// 书签树预览展开状态持久化（独立于书签画布）
const CHANGES_PREVIEW_EXPANDED_KEY = 'changesPreviewExpandedNodes';
const CHANGES_PREVIEW_SCROLL_KEY = 'changesPreviewScrollTop';

// 当前变化视图渲染状态（避免重复触发多次抖动）
let isRenderingCurrentChangesView = false;
let pendingCurrentChangesRender = null;

// 点击diff行时高亮对应的书签树节点
function highlightTreeNodesByChangeType(changeType) {
    const previewContainer = document.getElementById('changesTreePreviewInline');
    if (!previewContainer) return;

    // 移除之前的所有高亮（在 .tree-item 上操作）
    previewContainer.querySelectorAll('.tree-item').forEach(item => {
        item.classList.remove('highlight-added', 'highlight-deleted', 'highlight-modified', 'highlight-moved');
    });

    // 根据变化类型找到对应的节点（通过tree-change-*类或change-badge类）
    // 注意：tree-change-mixed 类表示同时有 modified 和 moved，需要在两种情况下都选中
    let selector;
    switch (changeType) {
        case 'added':
            selector = '.tree-item.tree-change-added, .change-badge.added';
            break;
        case 'deleted':
            selector = '.tree-item.tree-change-deleted, .change-badge.deleted';
            break;
        case 'modified':
            // modified 也选择 mixed 类（mixed = modified + moved）
            selector = '.tree-item.tree-change-modified, .tree-item.tree-change-mixed, .change-badge.modified';
            break;
        case 'moved':
            // moved 也选择 mixed 类（mixed = modified + moved）
            selector = '.tree-item.tree-change-moved, .tree-item.tree-change-mixed, .change-badge.moved';
            break;
        default:
            return;
    }

    const matchedElements = previewContainer.querySelectorAll(selector);
    const itemsToHighlight = new Set();

    matchedElements.forEach(el => {
        // 找到tree-item元素
        const treeItem = el.classList.contains('tree-item') ? el : el.closest('.tree-item');
        if (treeItem) {
            itemsToHighlight.add(treeItem);

            // 展开所有父节点
            let parent = treeItem.parentElement;
            while (parent && parent !== previewContainer) {
                if (parent.classList.contains('tree-children')) {
                    parent.classList.add('expanded');
                }
                const parentItem = parent.previousElementSibling;
                if (parentItem && parentItem.classList.contains('tree-item')) {
                    const toggle = parentItem.querySelector('.tree-toggle');
                    const folderIcon = parentItem.querySelector('.fa-folder');
                    if (toggle) toggle.classList.add('expanded');
                    if (folderIcon) {
                        folderIcon.classList.remove('fa-folder');
                        folderIcon.classList.add('fa-folder-open');
                    }
                    // 将自动展开的父节点也写入预览展开状态记忆
                    const parentId = parentItem.getAttribute('data-node-id');
                    if (parentId) {
                        try {
                            saveChangesPreviewExpandedState(String(parentId), true);
                        } catch (_) { /* 忽略存储错误 */ }
                    }
                }
                parent = parent.parentElement;
            }
        }
    });

    // 添加高亮动画
    itemsToHighlight.forEach(item => {
        item.classList.add(`highlight-${changeType}`);
    });

    // 滚动到第一个高亮的节点
    if (itemsToHighlight.size > 0) {
        const firstItem = Array.from(itemsToHighlight)[0];
        firstItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // 动画结束后移除高亮类
    setTimeout(() => {
        itemsToHighlight.forEach(item => {
            item.classList.remove(`highlight-${changeType}`);
        });
    }, 1200); // 0.6s * 2次 = 1.2s
}

function getChangesPreviewExpandedState() {
    try {
        const saved = localStorage.getItem(CHANGES_PREVIEW_EXPANDED_KEY);
        return saved ? JSON.parse(saved) : [];
    } catch (e) {
        return [];
    }
}

function saveChangesPreviewExpandedState(nodeId, isExpanded) {
    try {
        const expandedIds = getChangesPreviewExpandedState();
        const index = expandedIds.indexOf(nodeId);

        if (isExpanded && index === -1) {
            expandedIds.push(nodeId);
        } else if (!isExpanded && index !== -1) {
            expandedIds.splice(index, 1);
        }

        localStorage.setItem(CHANGES_PREVIEW_EXPANDED_KEY, JSON.stringify(expandedIds));
    } catch (e) {
        console.warn('[书签树预览] 保存展开状态失败:', e);
    }
}

function getChangesPreviewScrollTop() {
    try {
        const saved = localStorage.getItem(CHANGES_PREVIEW_SCROLL_KEY);
        const value = saved != null ? parseInt(saved, 10) : 0;
        return Number.isNaN(value) ? 0 : value;
    } catch (e) {
        return 0;
    }
}

function saveChangesPreviewScrollTop(scrollTop) {
    try {
        const value = typeof scrollTop === 'number' && !Number.isNaN(scrollTop) ? scrollTop : 0;
        localStorage.setItem(CHANGES_PREVIEW_SCROLL_KEY, String(value));
    } catch (e) {
        console.warn('[书签树预览] 保存滚动位置失败:', e);
    }
}

// 渲染书签树映射预览（完全克隆永久栏目）
async function renderChangesTreePreview(changeData) {
    const targetContainer = document.getElementById('changesTreePreviewInline');
    if (!targetContainer) return;

    try {
        console.log('[书签树映射预览] 开始...');

        // 0. 在重建预览前记录并持久化当前滚动位置
        let lastScrollTop = getChangesPreviewScrollTop();
        const existingPreviewBody = targetContainer.querySelector('.changes-preview-readonly .permanent-section-body');
        if (existingPreviewBody) {
            lastScrollTop = existingPreviewBody.scrollTop;
            saveChangesPreviewScrollTop(lastScrollTop);
        }

        // 1. 确保永久栏目存在（如果不存在就创建）
        let permanentSection = document.getElementById('permanentSection');
        if (!permanentSection) {
            console.log('[书签树映射预览] 创建永久栏目...');
            const canvasContent = document.getElementById('canvasContent');
            const template = document.getElementById('permanentSectionTemplate');
            if (template && canvasContent) {
                const clone = template.content.cloneNode(true);
                canvasContent.appendChild(clone);
                permanentSection = document.getElementById('permanentSection');
                // 应用语言
                setTimeout(() => applyLanguage(), 0);
            }
        }

        // 2. 检查书签树是否需要首次渲染
        const bookmarkTreeEl = document.getElementById('bookmarkTree');
        const needsFirstRender = !bookmarkTreeEl || bookmarkTreeEl.children.length === 0 || bookmarkTreeEl.querySelector('.loading');

        if (needsFirstRender) {
            console.log('[书签树映射预览] 首次渲染书签树...');
            // 直接渲染书签树（同步等待完成）
            await renderTreeViewSync();
        } else {
            // 已有书签树，只需刷新 treeChangeMap
            console.log('[书签树映射预览] 刷新变化标记...');
            await renderTreeViewSync();
        }

        // 3. 再次获取永久栏目（确保已渲染）
        permanentSection = document.getElementById('permanentSection');
        const finalBookmarkTreeEl = document.getElementById('bookmarkTree');

        if (!permanentSection || !finalBookmarkTreeEl || finalBookmarkTreeEl.children.length === 0) {
            console.error('[书签树映射预览] 永久栏目或书签树不存在');
            targetContainer.innerHTML = `<div class="empty-state-small">${currentLang === 'zh_CN' ? '请切换到书签画布查看详情' : 'Switch to Canvas for details'}</div>`;
            return;
        }

        // 4. 构建或复用预览用的永久栏目容器
        console.log('[书签树映射预览] 更新永久栏目预览...');
        let clonedSection = document.getElementById('changesPreviewPermanentSection');
        const isFirstPreview = !clonedSection;

        if (isFirstPreview) {
            console.log('[书签树映射预览] 首次创建预览容器');
            clonedSection = permanentSection.cloneNode(true);

            // 修改ID避免冲突
            clonedSection.id = 'changesPreviewPermanentSection';
            clonedSection.querySelectorAll('[id]').forEach(el => {
                el.id = 'preview_' + el.id;
            });

            // 添加只读类
            clonedSection.classList.add('changes-preview-readonly');

            // 隐藏标题栏（header）
            const header = clonedSection.querySelector('.permanent-section-header');
            if (header) {
                header.style.display = 'none';
            }

            // 隐藏书签树里的图例（已在标题栏显示）
            const treeLegend = clonedSection.querySelector('.tree-legend');
            if (treeLegend) {
                treeLegend.style.display = 'none';
            }

            // 禁用拖拽 & 标记只读
            clonedSection.querySelectorAll('[draggable="true"]').forEach(el => {
                el.setAttribute('draggable', 'false');
            });
            clonedSection.querySelectorAll('.tree-item').forEach(el => {
                el.dataset.readonly = 'true';
            });

            // 首次挂载到目标容器（优化：先隐藏，避免渲染过程闪烁）
            targetContainer.innerHTML = '';
            targetContainer.style.visibility = 'hidden';
            targetContainer.appendChild(clonedSection);
        } else {
            console.log('[书签树映射预览] 复用已有预览容器，仅更新树内容');
            const sourceTree = permanentSection.querySelector('#bookmarkTree');
            const previewTree = clonedSection.querySelector('.bookmark-tree');
            if (sourceTree && previewTree) {
                // 优化：仅替换内容，不需要隐藏（避免白屏闪烁）
                // targetContainer.style.visibility = 'hidden';

                // 只替换内部结构，保持外层容器与滚动条稳定
                previewTree.innerHTML = sourceTree.innerHTML;

                // 禁用拖拽 & 标记只读
                previewTree.querySelectorAll('[draggable="true"]').forEach(el => {
                    el.setAttribute('draggable', 'false');
                });
                previewTree.querySelectorAll('.tree-item').forEach(el => {
                    el.dataset.readonly = 'true';
                });
            }
        }

        // 6. 重新绑定只读的展开/折叠事件
        const treeContainer = clonedSection.querySelector('.bookmark-tree');
        if (treeContainer) {
            // 移除原有事件（通过克隆）
            const items = treeContainer.querySelectorAll('.tree-item');
            items.forEach(item => {
                const newItem = item.cloneNode(true);
                item.parentNode.replaceChild(newItem, item);
            });

            // 重置所有展开状态，预览自身维护，不继承 Canvas 视图
            treeContainer.querySelectorAll('.tree-children').forEach(children => {
                children.classList.remove('expanded');
            });
            treeContainer.querySelectorAll('.tree-toggle').forEach(toggle => {
                toggle.classList.remove('expanded');
            });

            // 默认展开根节点，避免整棵树完全折叠
            const rootNode = treeContainer.querySelector('.tree-node');
            if (rootNode) {
                const rootChildren = rootNode.querySelector('.tree-children');
                const rootToggle = rootNode.querySelector('.tree-toggle');
                if (rootChildren) rootChildren.classList.add('expanded');
                if (rootToggle) rootToggle.classList.add('expanded');
            }

            // 恢复展开状态（独立存储，不同步到书签画布）
            const expandedIds = getChangesPreviewExpandedState();
            if (Array.isArray(expandedIds) && expandedIds.length > 0) {
                const idSet = new Set(expandedIds.map(id => String(id)));
                treeContainer.querySelectorAll('.tree-item[data-node-id]').forEach(item => {
                    const nodeId = item.getAttribute('data-node-id');
                    if (!nodeId || !idSet.has(nodeId)) return;
                    const treeNode = item.closest('.tree-node');
                    if (!treeNode) return;
                    const children = treeNode.querySelector('.tree-children');
                    const toggle = item.querySelector('.tree-toggle');
                    if (children) children.classList.add('expanded');
                    if (toggle) toggle.classList.add('expanded');
                    const folderIcon = item.querySelector('.tree-icon, .folder-icon');
                    if (folderIcon) {
                        folderIcon.classList.remove('fa-folder');
                        folderIcon.classList.add('fa-folder-open');
                    }
                });
            }

            // 绑定新的只读事件
            treeContainer.addEventListener('click', (e) => {
                // 阻止右键菜单
                if (e.button === 2) {
                    e.preventDefault();
                    return;
                }

                const treeItem = e.target.closest('.tree-item');
                if (!treeItem) return;

                // 允许链接点击
                if (e.target.closest('a')) return;

                // 展开/折叠
                const treeNode = treeItem.closest('.tree-node');
                const children = treeNode?.querySelector('.tree-children');
                const toggle = treeItem.querySelector('.tree-toggle:not(.placeholder)');
                const nodeId = treeItem.dataset.nodeId;

                if (children && toggle) {
                    const isExpanding = !children.classList.contains('expanded');
                    toggle.classList.toggle('expanded');
                    children.classList.toggle('expanded');

                    // 简略模式（compact-mode）下：变更文件夹需要能“展开查看内容”
                    // 说明：compact-mode 会隐藏无变化的子节点，但文件夹发生移动/修改/新增/删除时，用户需要确认文件夹里包含什么。
                    try {
                        const previewRoot = treeContainer.closest('.changes-tree-preview-inline');
                        const isCompactMode = !!(previewRoot && previewRoot.classList.contains('compact-mode'));
                        const isFolder = treeItem.dataset.nodeType === 'folder';
                        const isChangedFolder = isFolder && (
                            treeItem.classList.contains('tree-change-added') ||
                            treeItem.classList.contains('tree-change-deleted') ||
                            treeItem.classList.contains('tree-change-modified') ||
                            treeItem.classList.contains('tree-change-moved') ||
                            treeItem.classList.contains('tree-change-mixed')
                        );
                        if (isCompactMode && treeNode && isChangedFolder) {
                            if (isExpanding) treeNode.classList.add('compact-reveal-all');
                            else treeNode.classList.remove('compact-reveal-all');
                        } else if (treeNode) {
                            treeNode.classList.remove('compact-reveal-all');
                        }
                    } catch (_) { /* ignore */ }

                    // 更新文件夹图标
                    const folderIcon = treeItem.querySelector('.tree-icon, .folder-icon');
                    if (folderIcon) {
                        if (isExpanding) {
                            folderIcon.classList.remove('fa-folder');
                            folderIcon.classList.add('fa-folder-open');
                        } else {
                            folderIcon.classList.remove('fa-folder-open');
                            folderIcon.classList.add('fa-folder');
                        }
                    }

                    // 保存展开状态（独立存储）
                    if (nodeId) {
                        saveChangesPreviewExpandedState(nodeId, isExpanding);
                    }
                }
            });

            // 禁用右键菜单
            treeContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }

        // 7. 恢复预览中的滚动位置并监听滚动变化
        const previewBody = clonedSection.querySelector('.permanent-section-body');
        if (previewBody) {
            if (typeof lastScrollTop === 'number' && !Number.isNaN(lastScrollTop)) {
                previewBody.scrollTop = lastScrollTop;
            }
            previewBody.addEventListener('scroll', () => {
                saveChangesPreviewScrollTop(previewBody.scrollTop);
            });
        }

        console.log('[书签树映射预览] 完成');

        // 8. 恢复显示（优化：渲染完成后一次性显示）
        if (targetContainer) {
            requestAnimationFrame(() => {
                targetContainer.style.visibility = '';
            });
        }

    } catch (error) {
        console.error('[书签树映射预览] 失败:', error);
        targetContainer.innerHTML = '';
    }
}



// 初始化书签树映射预览的交互
function initChangesTreePreview() {
    const previewSection = document.getElementById('changesTreePreview');
    const toggleBtn = document.getElementById('changesTreeToggleBtn');
    const editBtn = document.getElementById('changesTreeEditBtn');
    const header = document.querySelector('.changes-tree-header');

    if (!previewSection) return;

    // 折叠/展开功能
    if (toggleBtn) {
        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            previewSection.classList.toggle('collapsed');
        });
    }

    // 点击头部也可以折叠/展开
    if (header) {
        header.addEventListener('click', (e) => {
            if (e.target.closest('.changes-tree-action-btn')) return;
            previewSection.classList.toggle('collapsed');
        });
    }

    // 编辑按钮 - 跳转到Canvas视图
    if (editBtn) {
        editBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            switchView('canvas');
            setTimeout(() => {
                if (window.CanvasModule && window.CanvasModule.locatePermanent) {
                    window.CanvasModule.locatePermanent();
                }
            }, 200);
        });
    }
}

// 带重试机制的渲染函数
async function renderCurrentChangesViewWithRetry(maxRetries = 3, forceRefresh = false) {
    // 合并并发请求，避免多次抖动
    if (isRenderingCurrentChangesView) {
        pendingCurrentChangesRender = pendingCurrentChangesRender || { maxRetries: 0, forceRefresh: false };
        pendingCurrentChangesRender.maxRetries = Math.max(pendingCurrentChangesRender.maxRetries, maxRetries);
        pendingCurrentChangesRender.forceRefresh = pendingCurrentChangesRender.forceRefresh || forceRefresh;
        console.log('[渲染重试] 已有渲染在进行中，合并请求:', pendingCurrentChangesRender);
        return;
    }

    isRenderingCurrentChangesView = true;

    try {
        let finalChangeData = null;
        let finalForceRefresh = forceRefresh;

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            console.log(`[渲染重试] 第 ${attempt}/${maxRetries} 次尝试`);

            // 第一次尝试使用forceRefresh参数，后续尝试也使用
            const shouldForceRefresh = forceRefresh || attempt === 1;

            // 先静默获取数据，不碰 UI，避免多次抖动
            const changeData = await getDetailedChanges(shouldForceRefresh);
            finalChangeData = changeData;
            finalForceRefresh = shouldForceRefresh;

            // 如果有数量变化，但没有详细列表，且不是最后一次尝试，则重试
            const hasQuantityChange = Boolean(changeData.diffMeta?.hasNumericalChange);
            const hasDetailedList = (changeData.added && changeData.added.length > 0) ||
                (changeData.deleted && changeData.deleted.length > 0) ||
                (changeData.moved && changeData.moved.length > 0);

            console.log(`[渲染重试] 检查结果:`, {
                attempt,
                hasQuantityChange,
                hasDetailedList,
                bookmarkDiff: changeData.diffMeta?.bookmarkDiff,
                deletedCount: changeData.deleted?.length || 0
            });

            // 如果有变化且有详细列表，或者没有变化，或者是最后一次尝试，则停止
            if (!hasQuantityChange || hasDetailedList || attempt === maxRetries) {
                console.log(`[渲染重试] 完成，不再重试（即将一次性渲染 UI）`);
                break;
            }

            // 等待 300ms 后重试
            console.log(`[渲染重试] 等待 300ms 后重试...`);
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        // 仅在最终数据确定后渲染一次 UI，避免多次抖动
        await renderCurrentChangesView(finalForceRefresh, { prefetchedChangeData: finalChangeData });
    } finally {
        isRenderingCurrentChangesView = false;

        // 如果期间又有新的请求，合并后再额外渲染一次
        if (pendingCurrentChangesRender) {
            const next = pendingCurrentChangesRender;
            pendingCurrentChangesRender = null;
            console.log('[渲染重试] 处理挂起的渲染请求:', next);
            // 不递归阻塞：异步延迟一段时间再执行，防抖动
            setTimeout(() => {
                renderCurrentChangesViewWithRetry(next.maxRetries, next.forceRefresh);
            }, 300);
        }
    }
}

async function renderCurrentChangesView(forceRefresh = false, options = {}) {
    const { prefetchedChangeData = null } = options;
    const container = document.getElementById('currentChangesList');

    // 仅在首次渲染或容器为空时显示加载状态，避免刷新时闪烁
    const isFirstRender = !container.children.length || container.querySelector('.loading') || container.querySelector('.no-changes-message');
    if (isFirstRender) {
        container.innerHTML = `<div class="loading">${i18n.loading[currentLang]}</div>`;
    }

    console.log('[当前变化视图] 开始加载...', forceRefresh ? '(强制刷新)' : '');

    try {
        // 从 background 获取详细变化数据（如果上游已预取，则复用）
        const changeData = prefetchedChangeData || await getDetailedChanges(forceRefresh);

        console.log('[当前变化视图] 获取到的数据:', changeData);

        if (!changeData || !changeData.hasChanges) {
            // 没有变化
            console.log('[当前变化视图] 无变化');
            container.innerHTML = `
                <div class="no-changes-message">
                    <div class="no-changes-icon"><i class="fas fa-check-circle"></i></div>
                    <div class="no-changes-title">${i18n.noChanges[currentLang]}</div>
                    <div class="no-changes-desc">${i18n.noChangesDesc[currentLang]}</div>
                </div>
            `;
            return;
        }

        let html = '';

        const stats = changeData.stats || {};
        const diffMeta = changeData.diffMeta || {
            bookmarkDiff: stats.bookmarkDiff || 0,
            folderDiff: stats.folderDiff || 0,
            hasNumericalChange: stats.hasNumericalChange === true || (stats.bookmarkDiff !== 0 || stats.folderDiff !== 0),
            currentBookmarkCount: stats.currentBookmarkCount ?? stats.bookmarkCount ?? 0,
            currentFolderCount: stats.currentFolderCount ?? stats.folderCount ?? 0
        };

        // 确保 hasNumericalChange 正确设置（即使 diffMeta 来自 changeData）
        const bookmarkDiff = diffMeta.bookmarkDiff || 0;
        const folderDiff = diffMeta.folderDiff || 0;
        if (!diffMeta.hasNumericalChange && (bookmarkDiff !== 0 || folderDiff !== 0)) {
            diffMeta.hasNumericalChange = true;
        }

        const summary = buildChangeSummary(diffMeta, stats, currentLang);
        // 直接检查是否有数量变化（不仅依赖 summary）
        const hasQuantityChange = summary.hasQuantityChange || (bookmarkDiff !== 0 || folderDiff !== 0);
        const hasStructureChange = summary.hasStructuralChange;

        if (hasQuantityChange || hasStructureChange) {
            // Git diff 风格的容器
            html += '<div class="git-diff-container">';

            // diff 头部
            html += '<div class="diff-header">';
            html += `<span class="diff-title">${currentLang === 'zh_CN' ? '当前变化' : 'Current Changes'}</span>`;
            // 图例放在标题右边
            html += '<span class="diff-header-legend">';
            html += `<span class="legend-item"><span class="legend-dot added"></span>${currentLang === 'zh_CN' ? '新增' : 'Added'}</span>`;
            html += `<span class="legend-item"><span class="legend-dot deleted"></span>${currentLang === 'zh_CN' ? '删除' : 'Deleted'}</span>`;
            html += `<span class="legend-item"><span class="legend-dot moved"></span>${currentLang === 'zh_CN' ? '移动' : 'Moved'}</span>`;
            html += `<span class="legend-item"><span class="legend-dot modified"></span>${currentLang === 'zh_CN' ? '修改' : 'Modified'}</span>`;
            html += '</span>';
            html += '<span class="diff-header-spacer"></span>';
            // 导出按钮
            html += `<button class="diff-edit-btn icon-only" id="exportChangesBtn">`;
            html += '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>';
            html += `<span class="btn-tooltip">${currentLang === 'zh_CN' ? '导出变化' : 'Export Changes'}</span>`;
            html += '</button>';
            // 详略切换按钮 - 使用两个SVG图标，根据状态显示不同图标
            // 详细模式图标：4条横线（表示展开全部）
            // 简略模式图标：2条横线（表示只显示变化）
            html += `<button class="diff-edit-btn icon-only" id="toggleTreeDetailBtn">`;
            // 默认显示详细模式图标（4条横线）
            html += '<svg class="icon-detail" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="10" x2="20" y2="10"/><line x1="4" y1="14" x2="20" y2="14"/><line x1="4" y1="18" x2="20" y2="18"/></svg>';
            // 简略模式图标（2条横线+高亮）- 默认隐藏
            html += '<svg class="icon-compact" style="display:none" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><circle cx="2" cy="9" r="1.5" fill="currentColor" stroke="none"/><circle cx="2" cy="15" r="1.5" fill="currentColor" stroke="none"/></svg>';
            html += `<span class="btn-tooltip" id="toggleTreeDetailTooltip">${currentLang === 'zh_CN' ? '切换为简略' : 'Switch to compact'}</span>`;
            html += '</button>';
            // 编辑按钮
            html += `<button class="diff-edit-btn icon-only" id="jumpToCanvasBtn">`;
            html += '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>';
            html += `<span class="btn-tooltip">${currentLang === 'zh_CN' ? '在画布中编辑' : 'Edit in Canvas'}</span>`;
            html += '</button>';
            // 全部撤销按钮
            html += `<button class="diff-edit-btn icon-only" id="revertAllCurrentBtn">`;
            html += '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>';
            html += `<span class="btn-tooltip">${currentLang === 'zh_CN' ? '全部撤销' : 'Revert All'}</span>`;
            html += '</button>';
            html += '</div>';

            // diff 主体
            html += '<div class="diff-body">';

            // 数量变化部分 - 书签和文件夹合并显示
            if (hasQuantityChange) {
                const isZh = currentLang === 'zh_CN';

                const bookmarkAddedCount = typeof stats.bookmarkAdded === 'number' ? stats.bookmarkAdded : (bookmarkDiff > 0 ? bookmarkDiff : 0);
                const folderAddedCount = typeof stats.folderAdded === 'number' ? stats.folderAdded : (folderDiff > 0 ? folderDiff : 0);
                const bookmarkDeletedCount = typeof stats.bookmarkDeleted === 'number' ? stats.bookmarkDeleted : (bookmarkDiff < 0 ? Math.abs(bookmarkDiff) : 0);
                const folderDeletedCount = typeof stats.folderDeleted === 'number' ? stats.folderDeleted : (folderDiff < 0 ? Math.abs(folderDiff) : 0);

                // 收集增加的项目
                const addedParts = [];
                if (bookmarkAddedCount > 0) addedParts.push(`${bookmarkAddedCount} ${isZh ? '个书签' : 'bookmarks'}`);
                if (folderAddedCount > 0) addedParts.push(`${folderAddedCount} ${isZh ? '个文件夹' : 'folders'}`);

                // 收集减少的项目
                const deletedParts = [];
                if (bookmarkDeletedCount > 0) deletedParts.push(`${bookmarkDeletedCount} ${isZh ? '个书签' : 'bookmarks'}`);
                if (folderDeletedCount > 0) deletedParts.push(`${folderDeletedCount} ${isZh ? '个文件夹' : 'folders'}`);

                // 显示增加行
                if (addedParts.length > 0) {
                    html += '<div class="diff-line added clickable" data-change-type="added" style="display: flex; align-items: center; justify-content: space-between;">';
                    html += '<div style="display: flex; align-items: baseline;">';
                    html += '<span class="diff-prefix">+</span>';
                    html += `<span class="diff-content">${addedParts.join(isZh ? '，' : ', ')}</span>`;
                    html += '</div>';
                    html += '<div class="jump-to-related-btn-container" style="opacity: 0; transition: opacity 0.2s ease; margin-right: 8px;">';
                    html += `<button class="jump-to-related-btn" data-change-type="added" title="${isZh ? '跳转至对应位置' : 'Jump to changes'}">`;
                    html += '<i class="fas fa-external-link-alt"></i>';
                    html += '</button>';
                    html += '</div>';
                    html += '</div>';
                }

                // 显示减少行
                if (deletedParts.length > 0) {
                    html += '<div class="diff-line deleted clickable" data-change-type="deleted" style="display: flex; align-items: center; justify-content: space-between;">';
                    html += '<div style="display: flex; align-items: baseline;">';
                    html += '<span class="diff-prefix">-</span>';
                    html += `<span class="diff-content">${deletedParts.join(isZh ? '，' : ', ')}</span>`;
                    html += '</div>';
                    html += '<div class="jump-to-related-btn-container" style="opacity: 0; transition: opacity 0.2s ease; margin-right: 8px;">';
                    html += `<button class="jump-to-related-btn" data-change-type="deleted" title="${isZh ? '跳转至对应位置' : 'Jump to changes'}">`;
                    html += '<i class="fas fa-external-link-alt"></i>';
                    html += '</button>';
                    html += '</div>';
                    html += '</div>';
                }
            }

            // 结构变化部分 - 数量优先使用 background 的净变化计数（与主UI一致）
            let movedCount = (changeData.moved && changeData.moved.length) || 0;
            let modifiedCount = (changeData.modified && changeData.modified.length) || 0;

            if (typeof stats.movedCount === 'number') {
                movedCount = stats.movedCount;
            }
            if (typeof stats.modifiedCount === 'number') {
                modifiedCount = stats.modifiedCount;
            }

            // 如果没有从 changeData 获取到移动数量，但有移动标记，尝试从 recentMovedIds 获取
            if (movedCount === 0 && (stats.bookmarkMoved || stats.folderMoved)) {
                try {
                    const data = await new Promise(resolve => {
                        browserAPI.storage.local.get(['recentMovedIds'], result => resolve(result));
                    });
                    const recentMovedIds = data && Array.isArray(data.recentMovedIds) ? data.recentMovedIds : [];
                    movedCount = recentMovedIds.length;
                    console.log('[书签变化统计] 从 recentMovedIds 获取移动数量:', movedCount);
                } catch (e) {
                    console.warn('[书签变化统计] 获取 recentMovedIds 失败:', e);
                }
            }

            // 如果没有从 changeData 获取到修改数量，但有修改标记，尝试从 recentModifiedIds 获取
            if (modifiedCount === 0 && (stats.bookmarkModified || stats.folderModified)) {
                try {
                    const data = await new Promise(resolve => {
                        browserAPI.storage.local.get(['recentModifiedIds'], result => resolve(result));
                    });
                    const recentModifiedIds = data && Array.isArray(data.recentModifiedIds) ? data.recentModifiedIds : [];
                    modifiedCount = recentModifiedIds.length;
                    console.log('[书签变化统计] 从 recentModifiedIds 获取修改数量:', modifiedCount);
                } catch (e) {
                    console.warn('[书签变化统计] 获取 recentModifiedIds 失败:', e);
                }
            }

            const hasMovedOrModified = movedCount > 0 || modifiedCount > 0 || hasStructureChange;

            if (hasMovedOrModified) {
                const isZh = currentLang === 'zh_CN';

                // 显示移动行
                if (movedCount > 0 || (stats.bookmarkMoved || stats.folderMoved)) {
                    const displayCount = movedCount > 0 ? movedCount : '';
                    const movedText = isZh
                        ? (displayCount ? `${displayCount} 个移动` : '移动')
                        : (displayCount ? `${displayCount} moved` : 'Moved');

                    html += `<div class="diff-line moved clickable" data-change-type="moved" style="display: flex; align-items: center; justify-content: space-between;">`;
                    html += '<div style="display: flex; align-items: baseline;">';
                    html += `<span class="diff-prefix">↔</span>`;
                    html += `<span class="diff-content">${movedText}</span>`;
                    html += '</div>';
                    html += '<div class="jump-to-related-btn-container" style="opacity: 0; transition: opacity 0.2s ease; margin-right: 8px;">';
                    html += `<button class="jump-to-related-btn" data-change-type="moved" title="${isZh ? '跳转至对应位置' : 'Jump to changes'}">`;
                    html += '<i class="fas fa-external-link-alt"></i>';
                    html += '</button>';
                    html += '</div>';
                    html += '</div>';
                }

                // 显示修改行
                if (modifiedCount > 0 || (stats.bookmarkModified || stats.folderModified)) {
                    const displayCount = modifiedCount > 0 ? modifiedCount : '';
                    const modifiedText = isZh
                        ? (displayCount ? `${displayCount} 个修改` : '修改')
                        : (displayCount ? `${displayCount} modified` : 'Modified');

                    html += `<div class="diff-line modified clickable" data-change-type="modified" style="display: flex; align-items: center; justify-content: space-between;">`;
                    html += '<div style="display: flex; align-items: baseline;">';
                    html += `<span class="diff-prefix">~</span>`;
                    html += `<span class="diff-content">${modifiedText}</span>`;
                    html += '</div>';
                    html += '<div class="jump-to-related-btn-container" style="opacity: 0; transition: opacity 0.2s ease; margin-right: 8px;">';
                    html += `<button class="jump-to-related-btn" data-change-type="modified" title="${isZh ? '跳转至对应位置' : 'Jump to changes'}">`;
                    html += '<i class="fas fa-external-link-alt"></i>';
                    html += '</button>';
                    html += '</div>';
                    html += '</div>';
                }
            }

            // 如果没有任何变化
            if (!hasQuantityChange && !hasStructureChange) {
                html += '<div class="diff-line unchanged">';
                html += '<span class="diff-prefix">=</span>';
                html += `<span class="diff-content">${currentLang === 'zh_CN' ? '无变化' : 'No changes'}</span>`;
                html += '</div>';
            }

            // 书签树预览（放在变化统计下方）
            html += '<div id="changesTreePreviewInline" class="changes-tree-preview-inline"></div>';

            html += '</div>'; // 结束 diff-body
            html += '</div>'; // 结束 git-diff-container
        }

        // 2. 智能分析书签变化 + 生成 Git diff
        browserAPI.storage.local.get(['lastBookmarkData', 'currentChangesViewMode'], async (lastData) => {
            // 获取当前书签树（working directory）
            browserAPI.bookmarks.getTree(async (currentTree) => {
                // 获取上次备份的书签树（HEAD / last commit）
                let oldTree = null;
                if (lastData.lastBookmarkData && lastData.lastBookmarkData.bookmarkTree) {
                    oldTree = lastData.lastBookmarkData.bookmarkTree;
                }

                container.innerHTML = html;

                // =================================================================
                // 1. 立即绑定基础事件 (Fix: 移到渲染前，避免被阻塞)
                // =================================================================

                // 保存展开函数的引用，供渲染后调用
                let expandFoldersRef = null;

                // 详略切换按钮逻辑
                const toggleTreeDetailBtn = document.getElementById('toggleTreeDetailBtn');
                const treePreviewContainer = document.getElementById('changesTreePreviewInline');

                if (toggleTreeDetailBtn && treePreviewContainer) {
                    const expandFoldersWithChanges = (forceCollapseChangedFolders = false) => {
                        const changeClasses = ['.tree-change-added', '.tree-change-deleted', '.tree-change-modified', '.tree-change-moved', '.tree-change-mixed'];
                        const selector = changeClasses.join(', ');
                        const changedItems = treePreviewContainer.querySelectorAll(selector);

                        console.log('[详略切换] 找到变化节点数:', changedItems.length);

                        const isCompactMode = treePreviewContainer.classList.contains('compact-mode');
                        const isChangedFolderItem = (item) => {
                            try {
                                const type = (item.getAttribute('data-node-type') || item.dataset.nodeType);
                                if (type !== 'folder') return false;
                                return item.classList.contains('tree-change-added') ||
                                    item.classList.contains('tree-change-deleted') ||
                                    item.classList.contains('tree-change-modified') ||
                                    item.classList.contains('tree-change-moved') ||
                                    item.classList.contains('tree-change-mixed');
                            } catch (_) {
                                return false;
                            }
                        };
                        const syncCompactRevealAll = () => {
                            if (!isCompactMode) return;
                            try {
                                treePreviewContainer.querySelectorAll('.tree-item[data-node-type="folder"]').forEach(item => {
                                    const treeNode = item.closest('.tree-node');
                                    const children = treeNode?.querySelector(':scope > .tree-children');
                                    if (!treeNode || !children) return;
                                    const isChangedFolder = isChangedFolderItem(item);
                                    if (isChangedFolder && children.classList.contains('expanded')) {
                                        treeNode.classList.add('compact-reveal-all');
                                    } else {
                                        treeNode.classList.remove('compact-reveal-all');
                                    }
                                });
                            } catch (_) { /* ignore */ }
                        };

                        // 切换到简略模式时：强制把“变更文件夹对象”折叠回去（祖先路径仍可展开）
                        if (isCompactMode && forceCollapseChangedFolders) {
                            try {
                                treePreviewContainer.querySelectorAll('.tree-item[data-node-type="folder"]').forEach(item => {
                                    if (!isChangedFolderItem(item)) return;
                                    const treeNode = item.closest('.tree-node');
                                    const children = treeNode?.querySelector(':scope > .tree-children');
                                    const toggle = item.querySelector('.tree-toggle');
                                    if (children) children.classList.remove('expanded');
                                    if (toggle) toggle.classList.remove('expanded');
                                    const folderIcon = item.querySelector('.tree-icon.fas.fa-folder-open');
                                    if (folderIcon) {
                                        folderIcon.classList.remove('fa-folder-open');
                                        folderIcon.classList.add('fa-folder');
                                    }
                                    if (treeNode) treeNode.classList.remove('compact-reveal-all');
                                });
                            } catch (_) { /* ignore */ }
                        }

                        changedItems.forEach(item => {
                            // 简略模式：变更文件夹本身默认折叠，但其祖先路径保持展开
                            // 同时：变更文件夹即使包含其他变化，也不自动展开（由用户手动展开）
                            let parent = item.closest('.tree-node');
                            while (parent) {
                                const children = parent.querySelector(':scope > .tree-children');
                                const treeItem = parent.querySelector(':scope > .tree-item');

                                // compact 模式下：遇到“变更文件夹”则保持折叠（但仍继续展开其祖先）
                                const shouldSkipExpand = isCompactMode && treeItem && isChangedFolderItem(treeItem);

                                if (!shouldSkipExpand && children) {
                                    children.classList.add('expanded');
                                    children.style.display = '';
                                }
                                if (!shouldSkipExpand && treeItem) {
                                    const toggle = treeItem.querySelector('.tree-toggle');
                                    if (toggle) toggle.classList.add('expanded');
                                    const icon = treeItem.querySelector('.tree-icon.fas');
                                    if (icon) {
                                        icon.classList.remove('fa-folder');
                                        icon.classList.add('fa-folder-open');
                                    }
                                }

                                const parentChildren = parent.parentElement;
                                parent = parentChildren ? parentChildren.closest('.tree-node') : null;
                            }
                        });
                        syncCompactRevealAll();
                    };
                    expandFoldersRef = expandFoldersWithChanges;

                    // 初始化状态：读取存储的模式（默认为简略模式 'compact'）
                    const savedMode = lastData.currentChangesViewMode || 'compact';
                    const isCompactInit = savedMode === 'compact';

                    // 辅助函数：更新图标显示
                    const updateDetailToggleIcon = (isCompact) => {
                        const iconDetail = toggleTreeDetailBtn.querySelector('.icon-detail');
                        const iconCompact = toggleTreeDetailBtn.querySelector('.icon-compact');
                        if (isCompact) {
                            // 简略模式：显示简略图标，隐藏详细图标
                            if (iconDetail) iconDetail.style.display = 'none';
                            if (iconCompact) iconCompact.style.display = 'block';
                        } else {
                            // 详细模式：显示详细图标，隐藏简略图标
                            if (iconDetail) iconDetail.style.display = 'block';
                            if (iconCompact) iconCompact.style.display = 'none';
                        }
                    };

                    // 获取tooltip元素
                    const toggleTooltip = document.getElementById('toggleTreeDetailTooltip');

                    if (isCompactInit) {
                        treePreviewContainer.classList.add('compact-mode');
                        toggleTreeDetailBtn.classList.add('active');
                        if (toggleTooltip) toggleTooltip.textContent = currentLang === 'zh_CN' ? '切换为详细' : 'Switch to detailed';
                        updateDetailToggleIcon(true);
                    } else {
                        treePreviewContainer.classList.remove('compact-mode');
                        toggleTreeDetailBtn.classList.remove('active');
                        if (toggleTooltip) toggleTooltip.textContent = currentLang === 'zh_CN' ? '切换为简略' : 'Switch to compact';
                        updateDetailToggleIcon(false);
                    }

                    // 绑定点击事件
                    toggleTreeDetailBtn.addEventListener('click', () => {
                        const isCompact = treePreviewContainer.classList.contains('compact-mode');
                        // 切换状态
                        if (isCompact) {
                            // 当前是简略，切换到详细
                            treePreviewContainer.classList.remove('compact-mode');
                            toggleTreeDetailBtn.classList.remove('active');
                            if (toggleTooltip) toggleTooltip.textContent = currentLang === 'zh_CN' ? '切换为简略' : 'Switch to compact';
                            updateDetailToggleIcon(false);
                            // 保存状态
                            browserAPI.storage.local.set({ currentChangesViewMode: 'detailed' });
                        } else {
                            // 当前是详细，切换到简略
                            treePreviewContainer.classList.add('compact-mode');
                            toggleTreeDetailBtn.classList.add('active');
                            if (toggleTooltip) toggleTooltip.textContent = currentLang === 'zh_CN' ? '切换为详细' : 'Switch to detailed';
                            updateDetailToggleIcon(true);
                            // 展开变化
                            expandFoldersWithChanges(true);
                            // 保存状态
                            browserAPI.storage.local.set({ currentChangesViewMode: 'compact' });
                        }
                    });
                }

                // 跳转Canvas按钮
                const jumpToCanvasBtn = document.getElementById('jumpToCanvasBtn');
                if (jumpToCanvasBtn) {
                    jumpToCanvasBtn.addEventListener('click', () => {
                        document.querySelector('[data-view="canvas"]')?.click();
                    });
                }

                // 导出按钮
                const exportChangesBtn = document.getElementById('exportChangesBtn');
                if (exportChangesBtn) {
                    exportChangesBtn.addEventListener('click', () => {
                        showExportChangesModal(changeData);
                    });
                }

                // Diff行点击事件
                document.querySelectorAll('.diff-line.clickable').forEach(line => {
                    line.addEventListener('click', (e) => {
                        if (e.target.closest('.jump-to-related-btn-container') || e.target.closest('.jump-to-related-btn')) {
                            return;
                        }
                        const changeType = line.dataset.changeType;
                        highlightTreeNodesByChangeType(changeType);
                    });
                });

                document.querySelectorAll('.jump-to-related-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const changeType = btn.dataset.changeType;
                        highlightTreeNodesByChangeType(changeType);
                    });
                });

                // =================================================================
                // 2. 渲染预览树
                // =================================================================
                try {
                    // 渲染书签树映射预览（内嵌到Bookmark Changes内部）
                    await renderChangesTreePreview(changeData);
                } catch (err) {
                    console.warn('[CurrentChanges] Tree preview render error:', err);
                }

                // 渲染后再次尝试展开（如果有变化）
                if (expandFoldersRef) {
                    // 暂时禁用过渡动画，避免刷新时出现"展开动作"
                    const style = document.createElement('style');
                    style.id = 'temp-disable-transition';
                    style.innerHTML = `
                        .tree-children, .tree-toggle {
                            transition: none !important;
                        }
                    `;
                    document.head.appendChild(style);

                    // 执行展开
                    expandFoldersRef();

                    // 恢复动画 (延迟一点以确保渲染完成)
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            const s = document.getElementById('temp-disable-transition');
                            if (s) s.remove();
                        }, 100);
                    });
                }
            });
        });
    } catch (error) {
        console.error('加载变化数据失败:', error);
        container.innerHTML = `
            <div class="no-changes-message">
                <div class="no-changes-icon"><i class="fas fa-exclamation-circle"></i></div>
                <div class="no-changes-title">${currentLang === 'zh_CN' ? '加载失败' : 'Failed to Load'}</div>
                <div class="no-changes-desc">${error.message}</div>
            </div>
        `;
    }
}

// 获取详细变化数据 - 使用与状态卡片完全相同的逻辑
async function getDetailedChanges(forceRefresh = false) {
    return new Promise((resolve) => {
        console.log('[getDetailedChanges] 开始获取数据...', forceRefresh ? '(强制刷新)' : '(使用缓存)');

        // 使用和 popup.js 完全相同的逻辑：并行获取三个数据源
        Promise.all([
            // 1. 获取当前统计（支持强制刷新）
            new Promise((res, rej) => {
                browserAPI.runtime.sendMessage({
                    action: "getBackupStats",
                    forceRefresh: forceRefresh
                }, response => {
                    if (browserAPI.runtime.lastError) {
                        rej(new Error(browserAPI.runtime.lastError.message));
                        return;
                    }
                    if (response && response.success) res(response);
                    else rej(new Error(response?.error || '获取备份统计失败'));
                });
            }),
            // 2. 获取备份历史
            new Promise((res, rej) => {
                browserAPI.runtime.sendMessage({ action: "getSyncHistory" }, response => {
                    if (browserAPI.runtime.lastError) {
                        rej(new Error(browserAPI.runtime.lastError.message));
                        return;
                    }
                    if (response && response.success) res(response.syncHistory || []);
                    else rej(new Error(response?.error || '获取备份历史失败'));
                });
            }),
            // 3. 获取清空后的缓存记录
            new Promise((res) => {
                browserAPI.storage.local.get('cachedRecordAfterClear', result => {
                    res(result.cachedRecordAfterClear);
                });
            })
        ]).then(([backupResponse, syncHistory, cachedRecordFromStorage]) => {
            console.log('[getDetailedChanges] 获取到的完整数据:', {
                backupResponse,
                'stats对象': backupResponse.stats,
                syncHistoryLength: syncHistory.length,
                hasCachedRecord: !!cachedRecordFromStorage
            });

            const diffResult = calculateBookmarkFolderDiffs(
                backupResponse.stats,
                syncHistory,
                cachedRecordFromStorage
            );

            const bookmarkDiff = diffResult.bookmarkDiff || 0;
            const folderDiff = diffResult.folderDiff || 0;
            const hasNumericalChange = diffResult.hasNumericalChange === true;

            // 新口径：若 background 提供新增/删除分开计数，则数量变化以它为准
            const bmAdded = typeof backupResponse.stats.bookmarkAdded === 'number' ? backupResponse.stats.bookmarkAdded : null;
            const bmDeleted = typeof backupResponse.stats.bookmarkDeleted === 'number' ? backupResponse.stats.bookmarkDeleted : null;
            const fdAdded = typeof backupResponse.stats.folderAdded === 'number' ? backupResponse.stats.folderAdded : null;
            const fdDeleted = typeof backupResponse.stats.folderDeleted === 'number' ? backupResponse.stats.folderDeleted : null;
            const hasDetailedQuantity = (bmAdded !== null) || (bmDeleted !== null) || (fdAdded !== null) || (fdDeleted !== null);
            const hasQuantityChange = hasDetailedQuantity
                ? ((bmAdded || 0) > 0 || (bmDeleted || 0) > 0 || (fdAdded || 0) > 0 || (fdDeleted || 0) > 0)
                : hasNumericalChange;

            const hasStructuralChanges = backupResponse.stats.bookmarkMoved ||
                backupResponse.stats.folderMoved ||
                backupResponse.stats.bookmarkModified ||
                backupResponse.stats.folderModified;

            console.log('[getDetailedChanges] ✅ 直接使用 background 返回的差异（不再自己计算）:', {
                bookmarkDiff,
                folderDiff,
                hasStructuralChanges,
                '原始stats': {
                    bookmarkDiff: backupResponse.stats.bookmarkDiff,
                    folderDiff: backupResponse.stats.folderDiff
                }
            });

            // 检查是否有变化
            const hasChanges = hasQuantityChange || hasStructuralChanges;

            console.log('[getDetailedChanges] 是否有变化:', hasChanges);

            if (!hasChanges) {
                console.log('[getDetailedChanges] 无变化，返回');
                resolve({
                    hasChanges: false,
                    stats: { ...backupResponse.stats, bookmarkDiff, folderDiff, hasNumericalChange: false },
                    diffMeta: { ...diffResult, hasNumericalChange: false }
                });
                return;
            }

            // 构造 stats 对象
            const stats = {
                ...backupResponse.stats,
                bookmarkDiff,
                folderDiff,
                diffSource: diffResult.diffSource,
                currentBookmarkCount: diffResult.currentBookmarkCount,
                currentFolderCount: diffResult.currentFolderCount,
                hasNumericalChange: hasQuantityChange
            };

            // 获取指纹数据进行详细分析
            browserAPI.storage.local.get(['lastBookmarkData'], async (data) => {
                const lastData = data.lastBookmarkData;

                console.log('[getDetailedChanges] lastBookmarkData:', {
                    exists: !!lastData,
                    hasPrints: !!(lastData && lastData.bookmarkPrints),
                    printsCount: lastData?.bookmarkPrints?.length || 0,
                    timestamp: lastData?.timestamp || 'unknown'
                });

                if (!lastData || !lastData.bookmarkPrints) {
                    // 只有数量变化，无法获取详细列表
                    console.warn('[getDetailedChanges] 没有 lastBookmarkData，无法获取详细列表');
                    resolve({
                        hasChanges: true,
                        stats: stats,
                        diffMeta: diffResult,
                        added: [],
                        deleted: [],
                        moved: [],
                        modified: []
                    });
                    return;
                }

                // 获取当前书签树并生成指纹
                browserAPI.bookmarks.getTree(async (tree) => {
                    try {
                        const currentPrints = generateFingerprintsFromTree(tree);
                        const oldBookmarkPrints = new Set(lastData.bookmarkPrints || []);
                        const newBookmarkPrints = new Set(currentPrints.bookmarks);

                        const added = [];
                        const deleted = [];
                        const moved = [];
                        const modified = [];

                        // 解析新增、移动和修改
                        for (const print of newBookmarkPrints) {
                            if (!oldBookmarkPrints.has(print)) {
                                const bookmark = parseBookmarkFingerprint(print);
                                if (bookmark) {
                                    // 检查是否是移动或修改
                                    let isMovedOrModified = false;
                                    for (const oldPrint of oldBookmarkPrints) {
                                        const oldBookmark = parseBookmarkFingerprint(oldPrint);
                                        if (oldBookmark && oldBookmark.url === bookmark.url) {
                                            // URL 相同，检查是移动还是修改
                                            const pathChanged = oldBookmark.path !== bookmark.path;
                                            const titleChanged = oldBookmark.title !== bookmark.title;

                                            if (pathChanged) {
                                                // 位置改变 = 移动
                                                isMovedOrModified = true;
                                                moved.push({
                                                    ...bookmark,
                                                    oldPath: oldBookmark.path,
                                                    oldTitle: oldBookmark.title,
                                                    changeType: 'moved'
                                                });
                                            } else if (titleChanged) {
                                                // 只有标题改变 = 修改
                                                isMovedOrModified = true;
                                                modified.push({
                                                    ...bookmark,
                                                    oldTitle: oldBookmark.title,
                                                    changeType: 'modified'
                                                });
                                            }
                                            break;
                                        }
                                    }
                                    if (!isMovedOrModified) {
                                        added.push(bookmark);
                                    }
                                }
                            }
                        }

                        // 解析删除
                        for (const print of oldBookmarkPrints) {
                            if (!newBookmarkPrints.has(print)) {
                                const bookmark = parseBookmarkFingerprint(print);
                                if (bookmark) {
                                    const isInMoved = moved.some(m => m.url === bookmark.url);
                                    if (!isInMoved) {
                                        deleted.push(bookmark);
                                    }
                                }
                            }
                        }

                        console.log('变化分析结果:', {
                            added: added.length,
                            deleted: deleted.length,
                            moved: moved.length,
                            stats
                        });

                        resolve({
                            hasChanges: true,
                            stats,
                            diffMeta: diffResult,
                            added,
                            deleted,
                            moved,
                            modified
                        });
                    } catch (error) {
                        console.error('分析书签变化失败:', error);
                        resolve({
                            hasChanges: true,
                            stats: stats,
                            diffMeta: diffResult,
                            added: [],
                            deleted: [],
                            moved: [],
                            modified: []
                        });
                    }
                });
            });
        }).catch(error => {
            console.error('[getDetailedChanges] 获取数据失败:', error);
            resolve({ hasChanges: false, diffMeta: null, stats: null });
        });
    });
}

// 从书签树生成指纹
function generateFingerprintsFromTree(bookmarkNodes) {
    const bookmarkPrints = [];
    const folderPrints = [];

    function traverse(nodes, path) {
        if (!nodes) return;
        for (const node of nodes) {
            if (node.url) {
                const bookmarkFingerprint = `B:${path}|${node.title}|${node.url}`;
                bookmarkPrints.push(bookmarkFingerprint);
            } else if (node.children) {
                const currentPath = path ? `${path}/${node.title}` : node.title;
                let directBookmarkCount = 0;
                let directFolderCount = 0;
                for (const child of node.children) {
                    if (child.url) directBookmarkCount++;
                    else if (child.children) directFolderCount++;
                }
                const contentSignature = `c:${directBookmarkCount},${directFolderCount}`;
                const folderFingerprint = `F:${currentPath}|${contentSignature}`;
                folderPrints.push(folderFingerprint);
                traverse(node.children, currentPath);
            }
        }
    }

    if (bookmarkNodes && bookmarkNodes.length > 0 && bookmarkNodes[0].children) {
        traverse(bookmarkNodes[0].children, '');
    }

    return { bookmarks: bookmarkPrints, folders: folderPrints };
}

// 解析书签指纹
function parseBookmarkFingerprint(fingerprint) {
    // 格式: B:path|title|url
    if (!fingerprint || !fingerprint.startsWith('B:')) return null;

    const parts = fingerprint.substring(2).split('|');
    if (parts.length < 3) return null;

    return {
        path: parts[0],
        title: parts[1],
        url: parts[2]
    };
}

function groupBookmarksByFolder(bookmarks, lastBackupTime) {
    const result = {
        added: [],
        deleted: [],
        modified: [],
        moved: []
    };

    if (!lastBackupTime) {
        // 如果没有备份记录，所有书签都算新增
        result.added = bookmarks;
        return result;
    }

    // 找出新增的书签（添加时间晚于最后备份时间）
    bookmarks.forEach(bookmark => {
        if (bookmark.dateAdded > lastBackupTime) {
            result.added.push(bookmark);
        }
    });

    return result;
}

// 按路径分别生成 diff（确保移动的书签在两个路径都显示）
function generateDiffByPath(oldLines, newLines) {
    // 收集所有路径
    const allPaths = new Set();
    oldLines.forEach(line => {
        if (line.path) allPaths.add(line.path);
    });
    newLines.forEach(line => {
        if (line.path) allPaths.add(line.path);
    });

    const result = [];

    // 为每个路径单独生成 diff
    allPaths.forEach(path => {
        // 提取该路径下的行，保留全局索引
        const pathOldLines = [];
        const pathNewLines = [];

        oldLines.forEach((line, globalIdx) => {
            if (line.path === path || (!line.path && !path)) {
                // 保留全局索引
                pathOldLines.push({ ...line, globalIdx });
            }
        });

        newLines.forEach((line, globalIdx) => {
            if (line.path === path || (!line.path && !path)) {
                // 保留全局索引
                pathNewLines.push({ ...line, globalIdx });
            }
        });

        // 如果这个路径下有内容，生成 diff
        if (pathOldLines.length > 0 || pathNewLines.length > 0) {
            const hunks = generateGitDiff(pathOldLines, pathNewLines, true);

            if (hunks.length > 0) {
                result.push({
                    path: path,
                    hunks: hunks
                });
            }
        }
    });

    return result;
}

// 智能分析书签结构变化（移动、重命名、修改）
function analyzeStructuralChanges(oldTree, newTree) {
    const changes = {
        renamed: [],   // 重命名：{type: 'bookmark'|'folder', oldTitle, newTitle, url}
        moved: [],     // 移动：{type: 'bookmark'|'folder', title, oldPath, newPath, url}
        modified: []   // URL修改：{title, oldUrl, newUrl}
    };

    if (!oldTree) {
        return changes;
    }

    // 提取所有书签和文件夹的信息（带路径）
    const extractItems = (nodes, path = []) => {
        const items = { bookmarks: [], folders: [] };

        const traverse = (node, currentPath) => {
            if (!node) return;

            if (node.url) {
                // 书签
                items.bookmarks.push({
                    id: node.id,
                    title: node.title,
                    url: node.url,
                    path: currentPath.join(' > ')
                });
            } else if (node.children) {
                // 文件夹
                if (node.title) {  // 排除根节点
                    items.folders.push({
                        id: node.id,
                        title: node.title,
                        path: currentPath.join(' > ')
                    });
                }

                const newPath = node.title ? [...currentPath, node.title] : currentPath;
                node.children.forEach(child => traverse(child, newPath));
            }
        };

        nodes.forEach(node => traverse(node, path));
        return items;
    };

    const oldItems = extractItems(oldTree);
    const newItems = extractItems(newTree);

    // 1. 检测书签的重命名、移动、修改
    oldItems.bookmarks.forEach(oldBm => {
        // 通过 URL 匹配（URL 是书签的唯一标识）
        const newBm = newItems.bookmarks.find(n => n.url === oldBm.url);

        if (newBm) {
            // 书签存在
            if (oldBm.title !== newBm.title) {
                // 重命名
                changes.renamed.push({
                    type: 'bookmark',
                    oldTitle: oldBm.title,
                    newTitle: newBm.title,
                    url: oldBm.url
                });
            }
            if (oldBm.path !== newBm.path) {
                // 移动
                changes.moved.push({
                    type: 'bookmark',
                    title: newBm.title,
                    oldPath: oldBm.path,
                    newPath: newBm.path,
                    url: oldBm.url
                });
            }
        }
    });

    // 检测 URL 修改（通过标题匹配，但 URL 不同）
    oldItems.bookmarks.forEach(oldBm => {
        const newBm = newItems.bookmarks.find(n =>
            n.title === oldBm.title &&
            n.path === oldBm.path &&
            n.url !== oldBm.url
        );

        if (newBm) {
            changes.modified.push({
                title: oldBm.title,
                oldUrl: oldBm.url,
                newUrl: newBm.url
            });
        }
    });

    // 2. 检测文件夹的重命名、移动（简化版）
    oldItems.folders.forEach(oldFolder => {
        const newFolder = newItems.folders.find(n => n.title === oldFolder.title);

        if (newFolder && oldFolder.path !== newFolder.path) {
            changes.moved.push({
                type: 'folder',
                title: oldFolder.title,
                oldPath: oldFolder.path,
                newPath: newFolder.path
            });
        }
    });

    return changes;
}

// 渲染结构变化摘要
function renderStructuralChangesSummary(changes, lang) {
    const isZh = lang === 'zh_CN';
    let html = '<div class="structural-changes-summary">';
    html += `<div class="summary-header"><i class="fas fa-info-circle"></i> ${isZh ? '结构变化摘要' : 'Structural Changes'}</div>`;
    html += '<div class="summary-body">';

    // 重命名
    if (changes.renamed.length > 0) {
        html += '<div class="change-group">';
        html += `<div class="change-type"><i class="fas fa-pen"></i> ${isZh ? '重命名' : 'Renamed'} (${changes.renamed.length})</div>`;
        changes.renamed.slice(0, 5).forEach(item => {
            const icon = item.type === 'bookmark' ? '🔖' : '📁';
            html += `<div class="change-item">${icon} "${escapeHtml(item.oldTitle)}" → "${escapeHtml(item.newTitle)}"</div>`;
        });
        if (changes.renamed.length > 5) {
            html += `<div class="change-item-more">... ${isZh ? '等' : 'and'} ${changes.renamed.length - 5} ${isZh ? '项' : 'more'}</div>`;
        }
        html += '</div>';
    }

    // 移动
    if (changes.moved.length > 0) {
        html += '<div class="change-group">';
        html += `<div class="change-type"><i class="fas fa-arrows-alt"></i> ${isZh ? '移动' : 'Moved'} (${changes.moved.length})</div>`;
        changes.moved.slice(0, 5).forEach(item => {
            const icon = item.type === 'bookmark' ? '🔖' : '📁';
            html += `<div class="change-item">${icon} "${escapeHtml(item.title)}"<br>`;
            html += `<span style="margin-left: 20px; font-size: 0.9em; color: var(--text-tertiary);">`;
            html += `${escapeHtml(item.oldPath || 'Root')} → ${escapeHtml(item.newPath || 'Root')}`;
            html += `</span></div>`;
        });
        if (changes.moved.length > 5) {
            html += `<div class="change-item-more">... ${isZh ? '等' : 'and'} ${changes.moved.length - 5} ${isZh ? '项' : 'more'}</div>`;
        }
        html += '</div>';
    }

    // URL 修改
    if (changes.modified.length > 0) {
        html += '<div class="change-group">';
        html += `<div class="change-type"><i class="fas fa-edit"></i> ${isZh ? 'URL修改' : 'URL Modified'} (${changes.modified.length})</div>`;
        changes.modified.slice(0, 5).forEach(item => {
            html += `<div class="change-item" style="color: #fd7e14; font-weight: 500;">🔖 "${escapeHtml(item.title)}" <span style="color: #fd7e14; font-weight: 600;">~</span><br>`;
            html += `<span style="margin-left: 20px; font-size: 0.85em; color: #fd7e14; word-break: break-all;">`;
            html += `<span style="color: #fd7e14;">Bookmark URL:</span><br>`;
            html += `<span style="color: #fd7e14; text-decoration: line-through; opacity: 0.7;">- ${escapeHtml(item.oldUrl)}</span><br>`;
            html += `<span style="color: #fd7e14; font-weight: 600;">+ ${escapeHtml(item.newUrl)}</span>`;
            html += `</span></div>`;
        });
        if (changes.modified.length > 5) {
            html += `<div class="change-item-more">... ${isZh ? '等' : 'and'} ${changes.modified.length - 5} ${isZh ? '项' : 'more'}</div>`;
        }
        html += '</div>';
    }

    html += '</div></div>';
    return html;
}

// 将书签树转换为类似HTML文件的行数组
function bookmarkTreeToLines(tree, parentPath = '') {
    const lines = [];

    function traverse(nodes, path) {
        if (!nodes) return;

        nodes.forEach(node => {
            // 使用 ' > ' 作为路径分隔符，避免和文件夹名称中的 '/' 冲突
            const currentPath = path ? `${path} > ${node.title}` : node.title;

            if (node.url) {
                // 书签节点 - 类似 HTML 的 <DT><A> 行
                lines.push({
                    type: 'bookmark',
                    path: path || (currentLang === 'zh_CN' ? '根目录' : 'Root'),
                    title: node.title,
                    url: node.url,
                    line: `<DT><A HREF="${node.url}" ADD_DATE="${node.dateAdded || ''}">${node.title}</A>`,
                    id: node.id
                });
            } else if (node.children) {
                // 文件夹节点
                lines.push({
                    type: 'folder',
                    path: path || (currentLang === 'zh_CN' ? '根目录' : 'Root'),
                    title: node.title,
                    line: `<DT><H3 ADD_DATE="${node.dateAdded || ''}">${node.title}</H3>`,
                    id: node.id
                });
                lines.push({ type: 'tag', line: '<DL><p>' });
                traverse(node.children, currentPath);
                lines.push({ type: 'tag', line: '</DL><p>' });
            }
        });
    }

    if (tree && tree[0] && tree[0].children) {
        traverse(tree[0].children, '');
    }

    return lines;
}

// 生成真正的 Git diff（像 GitHub Desktop）
function generateGitDiff(oldLines, newLines, useGlobalIndex = false) {
    const hunks = [];
    const contextLines = 3; // 上下文行数

    // 使用简单的逐行比对
    let i = 0;
    let j = 0;

    while (i < oldLines.length || j < newLines.length) {
        // 找到下一个差异点
        const matchStart = { old: i, new: j };

        // 跳过相同的行
        while (i < oldLines.length && j < newLines.length &&
            oldLines[i].line === newLines[j].line) {
            i++;
            j++;
        }

        // 如果没有差异了，结束
        if (i >= oldLines.length && j >= newLines.length) {
            break;
        }

        // 找到了差异，记录差异的起始位置（减去上下文）
        const hunkOldStart = Math.max(0, i - contextLines);
        const hunkNewStart = Math.max(0, j - contextLines);

        // 添加前置上下文
        const contextBefore = [];
        for (let k = hunkOldStart; k < i; k++) {
            if (k < oldLines.length) {
                const actualOldIdx = useGlobalIndex && oldLines[k].globalIdx !== undefined ? oldLines[k].globalIdx : k;
                const actualNewIdx = useGlobalIndex && newLines[j - (i - k)] && newLines[j - (i - k)].globalIdx !== undefined ? newLines[j - (i - k)].globalIdx : (j - (i - k));
                contextBefore.push({
                    type: 'context',
                    line: oldLines[k],
                    oldIdx: actualOldIdx,
                    newIdx: actualNewIdx
                });
            }
        }

        // 收集变化
        const changes = [];
        const changeStartOld = i;
        const changeStartNew = j;

        // 找变化的范围（继续往前直到再次匹配或结束）
        while (i < oldLines.length || j < newLines.length) {
            // 检查是否重新匹配（连续匹配几行）
            let matchCount = 0;
            let ti = i, tj = j;
            while (ti < oldLines.length && tj < newLines.length &&
                oldLines[ti].line === newLines[tj].line && matchCount < contextLines + 1) {
                matchCount++;
                ti++;
                tj++;
            }

            // 如果连续匹配了足够多行，说明差异段结束
            if (matchCount >= contextLines + 1) {
                break;
            }

            // 否则继续收集差异
            if (i < oldLines.length && (j >= newLines.length || oldLines[i].line !== newLines[j].line)) {
                // 检查这行是否在 newLines 的后面出现（可能是新增导致的偏移）
                let foundInNew = -1;
                for (let search = j; search < Math.min(j + 10, newLines.length); search++) {
                    if (oldLines[i].line === newLines[search].line) {
                        foundInNew = search;
                        break;
                    }
                }

                if (foundInNew > j) {
                    // 说明中间有新增的行
                    while (j < foundInNew) {
                        const actualOldIdx = useGlobalIndex && oldLines[i] && oldLines[i].globalIdx !== undefined ? oldLines[i].globalIdx : i;
                        const actualNewIdx = useGlobalIndex && newLines[j].globalIdx !== undefined ? newLines[j].globalIdx : j;
                        changes.push({ type: 'add', line: newLines[j], oldIdx: actualOldIdx, newIdx: actualNewIdx });
                        j++;
                    }
                } else {
                    // 这是删除的行
                    const actualOldIdx = useGlobalIndex && oldLines[i].globalIdx !== undefined ? oldLines[i].globalIdx : i;
                    const actualNewIdx = useGlobalIndex && newLines[j] && newLines[j].globalIdx !== undefined ? newLines[j].globalIdx : j;
                    changes.push({ type: 'delete', line: oldLines[i], oldIdx: actualOldIdx, newIdx: actualNewIdx });
                    i++;
                }
            } else if (j < newLines.length && (i >= oldLines.length || oldLines[i].line !== newLines[j].line)) {
                // 新增的行
                const actualOldIdx = useGlobalIndex && oldLines[i] && oldLines[i].globalIdx !== undefined ? oldLines[i].globalIdx : i;
                const actualNewIdx = useGlobalIndex && newLines[j].globalIdx !== undefined ? newLines[j].globalIdx : j;
                changes.push({ type: 'add', line: newLines[j], oldIdx: actualOldIdx, newIdx: actualNewIdx });
                j++;
            } else if (i < oldLines.length && j < newLines.length && oldLines[i].line === newLines[j].line) {
                // 相同的行（但在差异段内）
                const actualOldIdx = useGlobalIndex && oldLines[i].globalIdx !== undefined ? oldLines[i].globalIdx : i;
                const actualNewIdx = useGlobalIndex && newLines[j].globalIdx !== undefined ? newLines[j].globalIdx : j;
                changes.push({ type: 'context', line: oldLines[i], oldIdx: actualOldIdx, newIdx: actualNewIdx });
                i++;
                j++;
            } else {
                break;
            }
        }

        // 添加后置上下文
        const contextAfter = [];
        const afterStart = { old: i, new: j };
        for (let k = 0; k < contextLines && (i + k) < oldLines.length && (j + k) < newLines.length; k++) {
            if (oldLines[i + k].line === newLines[j + k].line) {
                const actualOldIdx = useGlobalIndex && oldLines[i + k].globalIdx !== undefined ? oldLines[i + k].globalIdx : (i + k);
                const actualNewIdx = useGlobalIndex && newLines[j + k].globalIdx !== undefined ? newLines[j + k].globalIdx : (j + k);
                contextAfter.push({
                    type: 'context',
                    line: oldLines[i + k],
                    oldIdx: actualOldIdx,
                    newIdx: actualNewIdx
                });
            }
        }

        // 跳过后置上下文的行数
        const skipCount = contextAfter.length;
        i += skipCount;
        j += skipCount;

        // 如果有变化，添加 hunk
        if (changes.length > 0) {
            const deleteCount = changes.filter(c => c.type === 'delete').length;
            const addCount = changes.filter(c => c.type === 'add').length;
            const contextInChanges = changes.filter(c => c.type === 'context').length;

            // 提取路径信息（从变化的行或上下文中）
            let hunkPath = null;
            for (const change of changes) {
                if (change.line && change.line.path) {
                    hunkPath = change.line.path;
                    break;
                }
            }
            if (!hunkPath && contextBefore.length > 0) {
                hunkPath = contextBefore[0].line.path;
            }

            hunks.push({
                oldStart: hunkOldStart + 1,
                oldCount: contextBefore.length + deleteCount + contextInChanges + contextAfter.length,
                newStart: hunkNewStart + 1,
                newCount: contextBefore.length + addCount + contextInChanges + contextAfter.length,
                path: hunkPath,  // 添加路径信息
                contextBefore,
                changes,
                contextAfter
            });
        }
    }

    return hunks;
}

// ==================== 将hunks转换为真正的Git Diff文本格式 ====================
function hunksToGitDiffText(hunks, oldFileName = 'bookmarks.json', newFileName = 'bookmarks.json', lang = 'zh_CN') {
    if (!hunks || hunks.length === 0) {
        return '';
    }

    let diffText = '';

    // 生成diff文件头
    diffText += `diff --git a/${oldFileName} b/${newFileName}\n`;
    diffText += `index 000000..111111 100644\n`;
    diffText += `--- a/${oldFileName}\n`;
    diffText += `+++ b/${newFileName}\n`;

    let fileIndex = 0;
    hunks.forEach((hunk, index) => {
        // 生成hunk头
        diffText += `@@ -${hunk.oldStart},${hunk.oldCount} +${hunk.newStart},${hunk.newCount} @@`;

        // 添加路径作为hunk标题（如果有的话）
        if (hunk.path) {
            diffText += ` ${hunk.path}`;
        }
        diffText += '\n';

        // 添加上下文
        if (hunk.contextBefore) {
            hunk.contextBefore.forEach(ctx => {
                diffText += ` ${ctx.line.line}\n`;
            });
        }

        // 添加变化
        if (hunk.changes) {
            hunk.changes.forEach(change => {
                if (change.type === 'add') {
                    diffText += `+${change.line.line}\n`;
                } else if (change.type === 'delete') {
                    diffText += `-${change.line.line}\n`;
                } else if (change.type === 'context') {
                    diffText += ` ${change.line.line}\n`;
                }
            });
        }

        // 添加后置上下文
        if (hunk.contextAfter) {
            hunk.contextAfter.forEach(ctx => {
                diffText += ` ${ctx.line.line}\n`;
            });
        }
    });

    return diffText;
}

// ==================== 生成JSON对比的Git Diff ====================
// 对比两个JSON对象并生成git diff格式
function generateJsonGitDiff(oldData, newData, fileName = 'bookmarks.json', lang = 'zh_CN') {
    if (!oldData || !newData) {
        return '';
    }

    // 将JSON对象格式化为行
    const oldJson = JSON.stringify(oldData, null, 2).split('\n');
    const newJson = JSON.stringify(newData, null, 2).split('\n');

    // 转换为generateGitDiff需要的格式
    const oldLines = oldJson.map(line => ({ line, type: 'text' }));
    const newLines = newJson.map(line => ({ line, type: 'text' }));

    // 生成hunks
    const hunks = generateGitDiff(oldLines, newLines);

    // 转换为文本格式
    return hunksToGitDiffText(hunks, fileName, fileName, lang);
}

// ==================== 深度对比两个书签树 ====================
// 对比两个书签树，生成详细的变化列表
function deepCompareBookmarkTrees(oldTree, newTree, lang = 'zh_CN') {
    if (!oldTree || !newTree) {
        return {
            added: [],
            deleted: [],
            modified: [],
            moved: [],
            hasChanges: false
        };
    }

    // 生成书签指纹映射
    function generateBookmarkMap(tree, parentPath = '') {
        const map = new Map(); // id -> { title, url, path, dateAdded }
        const pathMap = new Map(); // path+title+url -> id

        function traverse(nodes, path) {
            if (!nodes) return;
            nodes.forEach(node => {
                const currentPath = path ? `${path}/${node.title}` : node.title;
                if (node.url) {
                    const key = `${currentPath}|${node.url}`;
                    map.set(node.id, {
                        title: node.title,
                        url: node.url,
                        path: currentPath,
                        dateAdded: node.dateAdded,
                        id: node.id
                    });
                    pathMap.set(key, node.id);
                } else if (node.children) {
                    traverse(node.children, currentPath);
                }
            });
        }

        if (tree && tree[0] && tree[0].children) {
            traverse(tree[0].children, '');
        }

        return { map, pathMap };
    }

    const { map: oldMap, pathMap: oldPathMap } = generateBookmarkMap(oldTree);
    const { map: newMap, pathMap: newPathMap } = generateBookmarkMap(newTree);

    const added = [];
    const deleted = [];
    const modified = [];
    const moved = [];

    // 检查新增和修改
    newMap.forEach((newBkm, newId) => {
        const oldBkm = oldMap.get(newId);
        if (!oldBkm) {
            // 检查是否是移动（相同URL，不同位置）
            let foundMoved = false;
            oldMap.forEach((oldItem, oldId) => {
                if (oldItem.url === newBkm.url && oldItem.path !== newBkm.path) {
                    moved.push({
                        title: newBkm.title,
                        url: newBkm.url,
                        oldPath: oldItem.path,
                        newPath: newBkm.path
                    });
                    foundMoved = true;
                }
            });
            if (!foundMoved) {
                added.push({
                    title: newBkm.title,
                    url: newBkm.url,
                    path: newBkm.path
                });
            }
        } else {
            // 检查是否修改
            if (oldBkm.title !== newBkm.title || oldBkm.url !== newBkm.url || oldBkm.path !== newBkm.path) {
                modified.push({
                    title: newBkm.title,
                    url: newBkm.url,
                    oldTitle: oldBkm.title,
                    oldPath: oldBkm.path,
                    newPath: newBkm.path
                });
            }
        }
    });

    // 检查删除
    oldMap.forEach((oldBkm, oldId) => {
        const newBkm = newMap.get(oldId);
        if (!newBkm) {
            // 检查是否是移动
            let foundMoved = moved.some(m => m.url === oldBkm.url && m.oldPath === oldBkm.path);
            if (!foundMoved) {
                deleted.push({
                    title: oldBkm.title,
                    url: oldBkm.url,
                    path: oldBkm.path
                });
            }
        }
    });

    const hasChanges = added.length > 0 || deleted.length > 0 || modified.length > 0 || moved.length > 0;

    return {
        added,
        deleted,
        modified,
        moved,
        hasChanges,
        addedCount: added.length,
        deletedCount: deleted.length,
        modifiedCount: modified.length,
        movedCount: moved.length
    };
}

// 简化的 LCS 算法
function computeLCS(oldLines, newLines) {
    const m = oldLines.length;
    const n = newLines.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (oldLines[i - 1].line === newLines[j - 1].line) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // 回溯
    const lcs = [];
    let i = m, j = n;
    while (i > 0 && j > 0) {
        if (oldLines[i - 1].line === newLines[j - 1].line) {
            lcs[i - 1] = newLines[j - 1].line;
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    return lcs;
}

// ==================== Git Diff 辅助函数 ====================

// 渲染文件夹路径为面包屑导航
function renderBreadcrumb(path, lang) {
    if (!path) {
        return `<div class="breadcrumb">
            <span class="breadcrumb-item root">
                <i class="fas fa-home"></i>
                <span>${lang === 'zh_CN' ? '根目录' : 'Root'}</span>
            </span>
        </div>`;
    }

    // 只按 ' > ' 拆分路径（避免误拆文件夹名称中的 '/'）
    const parts = path.split(' > ').filter(p => p.trim());

    let html = '<div class="breadcrumb">';

    parts.forEach((part, index) => {
        if (index > 0) {
            html += '<span class="breadcrumb-separator"><i class="fas fa-chevron-right"></i></span>';
        }

        html += `<span class="breadcrumb-item">`;
        html += `<i class="fas fa-folder"></i>`;
        html += `<span class="breadcrumb-text">${escapeHtml(part.trim())}</span>`;
        html += `</span>`;
    });

    html += '</div>';
    return html;
}

// 折叠/展开单个 hunk（片段）
function toggleHunk(hunkId) {
    const content = document.getElementById(hunkId);
    const icon = document.getElementById(hunkId + '-icon');

    if (!content || !icon) {
        console.error('[toggleHunk] 找不到元素:', hunkId);
        return;
    }

    if (content.classList.contains('collapsed')) {
        content.classList.remove('collapsed');
        icon.classList.remove('fa-chevron-right');
        icon.classList.add('fa-chevron-down');
    } else {
        content.classList.add('collapsed');
        icon.classList.remove('fa-chevron-down');
        icon.classList.add('fa-chevron-right');
    }
}

function renderChangeCategory(type, bookmarks) {
    if (bookmarks.length === 0) return '';

    // 这个函数现在不再使用，因为我们要渲染完整的 diff
    return '';
}

function renderChangeTreeItem(bookmark, type) {
    // 使用 Google S2 服务获取favicon - 更可靠
    const favicon = getFaviconUrl(bookmark.url);

    let displayInfo = '';
    if (type === 'moved') {
        // 移动的书签显示原路径和新路径
        displayInfo = `
            <div class="change-tree-item-title">${escapeHtml(bookmark.title || bookmark.url)}</div>
            <div class="change-tree-item-url">${escapeHtml(bookmark.url)}</div>
            <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 4px;">
                ${currentLang === 'zh_CN' ? '从' : 'From'}: ${escapeHtml(bookmark.oldPath || '')}
                ${bookmark.oldTitle !== bookmark.title ? ` (${escapeHtml(bookmark.oldTitle)})` : ''}
            </div>
        `;
    } else {
        displayInfo = `
            <div class="change-tree-item-title">${escapeHtml(bookmark.title || bookmark.url)}</div>
            <div class="change-tree-item-url">${escapeHtml(bookmark.url)}</div>
        `;
    }

    return `
        <div class="change-tree-item" data-bookmark-url="${escapeHtml(bookmark.url || '')}">
            ${favicon ? `<img class="change-tree-item-icon" 
                 src="${favicon}" 
                 alt="">` : ''}
            <div class="change-tree-item-info">
                ${displayInfo}
            </div>
            <span class="change-tree-item-badge ${type}">
                ${type === 'added' ? i18n.added[currentLang] :
            type === 'deleted' ? i18n.deleted[currentLang] :
                type === 'modified' ? i18n.modified[currentLang] :
                    i18n.moved[currentLang]}
            </span>
        </div>
    `;
}

// =============================================================================
// 备份历史视图
// =============================================================================

let currentHistoryPage = 1;
const HISTORY_PAGE_SIZE = 10;

function renderHistoryView() {
    const container = document.getElementById('historyList');
    // 分页控件元素
    const pagination = document.getElementById('historyPagination');
    const pageInput = document.getElementById('historyPageInput');
    const totalPagesEl = document.getElementById('historyTotalPages');
    const prevBtn = document.getElementById('historyPrevPage');
    const nextBtn = document.getElementById('historyNextPage');

    if (syncHistory.length === 0) {
        if (container) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i class="fas fa-history"></i></div>
                    <div class="empty-state-title">${i18n.emptyHistory[currentLang]}</div>
                </div>
            `;
        }
        if (pagination) pagination.style.display = 'none';
        return;
    }

    // 反转数组，最新的在前
    const reversedHistory = [...syncHistory].reverse();
    const totalRecords = reversedHistory.length;

    // 分页计算
    const totalPages = Math.ceil(reversedHistory.length / HISTORY_PAGE_SIZE);

    // 确保当前页码有效
    if (currentHistoryPage < 1) currentHistoryPage = 1;
    if (currentHistoryPage > totalPages) currentHistoryPage = totalPages;

    const startIndex = (currentHistoryPage - 1) * HISTORY_PAGE_SIZE;
    const endIndex = Math.min(startIndex + HISTORY_PAGE_SIZE, reversedHistory.length);
    const pageRecords = reversedHistory.slice(startIndex, endIndex);

    // 更新分页控件 UI
    if (pagination) {
        if (totalPages <= 1) {
            pagination.style.display = 'none';
        } else {
            pagination.style.display = 'flex';
            if (pageInput) {
                pageInput.value = currentHistoryPage;
                // pageInput.max = totalPages; // input type="text" doesn't use max
            }
            if (totalPagesEl) totalPagesEl.textContent = totalPages;
            if (prevBtn) prevBtn.disabled = currentHistoryPage <= 1;
            if (nextBtn) nextBtn.disabled = currentHistoryPage >= totalPages;
        }
    }

    if (!container) return;

    // 使用当前页的数据进行渲染，注意 index 需要加上 offset 以保持 calculateChanges 正确（如果它依赖全局索引）
    // calculateChanges takes (record, index, allRecords). 
    // Usually index is used to compare with previous record (index+1).
    // So passing reversedHistory (full list) to calculateChanges is correct, but we need the correct index in that full list.

    container.innerHTML = pageRecords.map((record, i) => {
        const globalIndex = startIndex + i; // Index in the full reversedHistory array
        const seqNumber = Number.isFinite(Number(record.seqNumber)) ? Number(record.seqNumber) : '-';

        const time = formatTime(record.time);
        // 使用 type 字段代替 isAutoBackup：'manual', 'auto', 'switch'
        const isAuto = record.type !== 'manual';
        const fingerprint = record.fingerprint || '';

        // 计算变化
        const changes = calculateChanges(record, globalIndex, reversedHistory);

        // 位置/方向标识（兼容旧记录 + 云端1/云端2）
        const directionKey = (record.direction || 'none').toString().toLowerCase();
        const cloud1Label = currentLang === 'zh_CN' ? '云端1' : 'Cloud 1';
        const cloud2Label = currentLang === 'zh_CN' ? '云端2' : 'Cloud 2';
        const localLabel = currentLang === 'zh_CN' ? '本地' : 'Local';
        const cloudLabel = currentLang === 'zh_CN' ? '云端' : 'Cloud';
        const joinText = ', ';

        const directionInfoMap = {
            // Legacy
            upload: { icon: '<i class="fas fa-cloud-upload-alt"></i>', text: cloudLabel },
            download: { icon: '<i class="fas fa-hdd"></i>', text: localLabel },
            both: { icon: '<i class="fas fa-cloud"></i> <i class="fas fa-hdd"></i>', text: `${cloud1Label}${joinText}${localLabel}` },

            // New
            webdav: { icon: '<i class="fas fa-cloud"></i>', text: `${cloud1Label} (WebDAV)` },
            github_repo: { icon: '<i class="fab fa-github"></i>', text: `${cloud2Label} (GitHub Repo)` },
            gist: { icon: '<i class="fab fa-github"></i>', text: `${cloud2Label} (GitHub Repo)` }, // legacy
            cloud: { icon: '<i class="fas fa-cloud"></i> <i class="fab fa-github"></i>', text: `${cloud1Label}${joinText}${cloud2Label}` },
            webdav_local: { icon: '<i class="fas fa-cloud"></i> <i class="fas fa-hdd"></i>', text: `${cloud1Label} (WebDAV)${joinText}${localLabel}` },
            github_repo_local: { icon: '<i class="fab fa-github"></i> <i class="fas fa-hdd"></i>', text: `${cloud2Label} (GitHub Repo)${joinText}${localLabel}` },
            gist_local: { icon: '<i class="fab fa-github"></i> <i class="fas fa-hdd"></i>', text: `${cloud2Label} (GitHub Repo)${joinText}${localLabel}` }, // legacy
            cloud_local: { icon: '<i class="fas fa-cloud"></i> <i class="fab fa-github"></i> <i class="fas fa-hdd"></i>', text: `${cloud1Label}${joinText}${cloud2Label}${joinText}${localLabel}` },
            local: { icon: '<i class="fas fa-hdd"></i>', text: localLabel },
            none: { icon: '<i class="fas fa-minus-circle"></i>', text: currentLang === 'zh_CN' ? '无' : 'None' }
        };

        const directionInfo = directionInfoMap[directionKey] || { icon: '<i class="fas fa-question-circle"></i>', text: directionKey };
        const directionIcon = directionInfo.icon;
        const directionText = directionInfo.text;

        // 构建提交项
        // 切换标识徽章（可选显示）
        // 模式显示文本
        const savedMode = getRecordDetailMode(record.time);
        const defaultMode = historyDetailMode || 'simple';
        const mode = savedMode || defaultMode;
        const modeText = mode === 'simple'
            ? (currentLang === 'zh_CN' ? '简略' : 'Simple')
            : (currentLang === 'zh_CN' ? '详细' : 'Detailed');

        // 特殊处理恢复记录
        const isRestore = record.type === 'restore';
        if (isRestore) {
            // 隐藏统计信息：不显示具体的书签文件夹数量
            changes.isRestoreHiddenStats = true;
        }

        // 构建显示标题
        let displayTitle = record.note;

        // 尝试构建更详细的标题（包含源备份的备注）
        if (isRestore && record.restoreInfo) {
            let { sourceSeqNumber, sourceTime, sourceNote } = record.restoreInfo;

            // 如果 restoreInfo 中没有 sourceNote（旧记录），尝试从历史记录中查找
            if (!sourceNote && sourceTime) {
                const sourceRecord = syncHistory.find(r => r.time === sourceTime);
                if (sourceRecord) {
                    sourceNote = sourceRecord.note;
                }
            }

            // 构造标题：恢复至 #序号 [源备注]
            const timeStr = formatTime(sourceTime);
            let newTitle = currentLang === 'zh_CN'
                ? `恢复至 #${sourceSeqNumber}`
                : `Restored to #${sourceSeqNumber}`;

            if (sourceNote) {
                newTitle += ` ${sourceNote}`;
            } else {
                newTitle += ` (${timeStr})`;
            }

            // 覆盖显示标题
            displayTitle = newTitle;
        }

        // 如果仍然没有备注，回退到时间
        displayTitle = displayTitle || time;

        if (isRestore && record.restoreInfo) {
            // 用户要求格式：恢复至序号备注 哈希值
            // 优先使用源哈希值，如果不存在（旧记录）则回退到当前哈希
            let hashToUse = record.restoreInfo.sourceFingerprint;

            // 如果没有直接保存 sourceFingerprint，尝试通过 sourceTime 查找源记录
            if (!hashToUse && record.restoreInfo.sourceTime) {
                const sourceRecord = syncHistory.find(r => r.time === record.restoreInfo.sourceTime);
                if (sourceRecord) {
                    hashToUse = sourceRecord.fingerprint;
                }
            }

            // 兜底：如果还是找不到（比如源记录已被删除），才显示当前的（虽然不准确，但总比没有好，或者也可以选择不显示）
            // 用户反馈明确说“哈希值变成了他自己的...而不是我们恢复的那个”，所以如果找不到源哈希，也许应该显示一个提示或者什么都不显示？
            // 但为了保持格式一致性，我们暂时回退到 current fingerprint，或者仅仅为空？
            // 用户的意图是想看到它是“从哪个版本”恢复来的。如果源版本都没了，显示当前版本哈希也没意义（因为它肯定和源版本哈希一样...如果恢复成功的话。其实 current fingerprint 就是 restored content fingerprint，也就是 source content fingerprint）。
            // 等等，如果恢复成功，Current Fingerprint 应该等于 Source Fingerprint！
            // 除非... 恢复过程中有变化？或者指纹计算 包含 时间戳/元数据？
            // "Bookmarks Fingerprint" usually relies on content (URL, Title, Structure).
            // Let's check generateFingerprints in background.js.
            // It relies on Path, Title, URL. So logicallly restored content hash == source content hash.
            // User says: "his hash value became his own hash... instead of the hash of the thing we restored from"
            // This suggests the "Restore Record" itself has a different fingerprint than the "Source Record".
            // Why? Maybe because "Auto Backup" triggered after restore captures the state *after* restore.
            // If the restore was perfect, content is same.
            // BUT, if the user had some other changes or if "Restore" added a "Restore Note" that is NOT part of bookmark content...
            // Wait, fingerprint calculation `generateFingerprints` only looks at bookmarks.
            // Maybe the user refers to the "Fingerprint" displayed in the UI which might be a Commit Hash (Sequence Number treated as ID?) or something else?
            // "Commit ID" / "Fingerprint".
            // Let's assume the user wants to see the "Source Fingerprint" explicitly to verify it matches.

            // If `hashToUse` is found (Source Fingerprint), use it.
            // If not found, use `record.fingerprint`.
            const finalHash = hashToUse || record.fingerprint;

            const shortHash = (finalHash || '').substring(0, 7);
            if (shortHash && !displayTitle.includes(shortHash)) {
                displayTitle = `${displayTitle} (${shortHash})`;
            }
        }

        let typeBadge = '';
        if (record.type === 'switch') {
            typeBadge = `<span class="commit-badge switch" title="${currentLang === 'zh_CN' ? '切换备份' : 'Switch Backup'}">
                   <i class="fas fa-exchange-alt"></i> ${currentLang === 'zh_CN' ? '切换' : 'Switch'}
               </span>`;
        } else if (isRestore) {
            typeBadge = `<span class="commit-badge restore" title="${currentLang === 'zh_CN' ? '恢复操作' : 'Restore Operation'}" style="background: var(--accent-light); color: var(--accent-primary); border: 1px solid var(--accent-primary);">
                   <i class="fas fa-undo"></i> ${currentLang === 'zh_CN' ? '恢复' : 'Restore'}
               </span>`;
        }

        // ...

        const titleClass = isRestore ? 'commit-title restore-title' : 'commit-title';
        const seqClass = isRestore ? 'commit-seq-badge restore-seq' : 'commit-seq-badge';

        return `
            <div class="commit-item" data-record-time="${record.time}">
                <div class="commit-header">
                    <div class="commit-title-group">
                        <span class="${seqClass}" title="${currentLang === 'zh_CN' ? '序号' : 'No.'}">${seqNumber}</span>
                        <div class="${titleClass}" title="${currentLang === 'zh_CN' ? '点击编辑备注' : 'Click to edit note'}">${escapeHtml(displayTitle)}</div>
                        <button class="commit-note-edit-btn" data-time="${record.time}" title="${currentLang === 'zh_CN' ? '编辑备注' : 'Edit Note'}">
                            <i class="fas fa-edit"></i>
                        </button>
                    </div>
                    <div class="commit-actions">
                        <button class="action-btn restore-btn" data-time="${record.time}" data-display-title="${escapeHtml(displayTitle)}" title="${currentLang === 'zh_CN' ? '恢复到此版本' : 'Restore to this version'}">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button class="action-btn detail-btn" data-time="${record.time}">
                            <i class="fas fa-angle-right"></i>
                            <span class="btn-tooltip">${modeText}</span>
                        </button>
                    </div>
                </div>
                <div class="commit-meta">
                    <div class="commit-time">
                        <i class="fas fa-clock"></i> ${time}
                    </div>
                    ${renderCommitStatsInline(changes)}
                    ${!typeBadge ? `<span class="commit-badge ${isAuto ? 'auto' : 'manual'}">
                        <i class="fas ${isAuto ? 'fa-robot' : 'fa-hand-pointer'}"></i>
                        ${isAuto ? i18n.autoBackup[currentLang] : i18n.manualBackup[currentLang]}
                    </span>` : ''}
                    ${typeBadge}
                    <span class="commit-badge direction">
                        ${directionIcon}
                        ${directionText}
                    </span>
                    <span class="commit-fingerprint" title="${currentLang === 'zh_CN' ? '提交指纹号' : 'Commit Fingerprint'}">#${escapeHtml(fingerprint.substring(0, 7))}</span>
                </div>
            </div>
        `;
    }).join('');

    // 添加按钮事件（使用事件委托）
    container.querySelectorAll('.action-btn.detail-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            const recordTime = btn.dataset.time;
            const record = syncHistory.find(r => r.time === recordTime);
            if (record) showDetailModal(record);
        });
    });

    // 添加备注编辑按钮事件
    container.querySelectorAll('.commit-note-edit-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            const recordTime = btn.dataset.time;
            editCommitNote(recordTime);
        });
    });

    // 添加恢复按钮事件
    container.querySelectorAll('.action-btn.restore-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            const recordTime = btn.dataset.time;
            const record = syncHistory.find(r => r.time === recordTime);
            const displayTitle = btn.dataset.displayTitle;
            if (record) showRestoreModal(record, displayTitle);
        });
    });

    // 添加行点击交互 (详情)
    container.querySelectorAll('.commit-item').forEach(item => {
        item.style.cursor = 'pointer';
        item.addEventListener('click', (e) => {
            // 如果点击的是按钮或交互元素，则忽略
            if (e.target.closest('button') || e.target.closest('a') || e.target.closest('.commit-note-edit-btn')) return;

            const recordTime = item.dataset.recordTime;
            const record = syncHistory.find(r => r.time === recordTime);
            if (record) showDetailModal(record);
        });
    });
}

function initHistoryPagination() {
    const prevBtn = document.getElementById('historyPrevPage');
    const nextBtn = document.getElementById('historyNextPage');
    const pageInput = document.getElementById('historyPageInput');

    if (prevBtn) {
        prevBtn.addEventListener('click', () => {
            if (currentHistoryPage > 1) {
                currentHistoryPage--;
                renderHistoryView();
            }
        });
    }

    if (nextBtn) {
        nextBtn.addEventListener('click', () => {
            const totalPages = Math.ceil(syncHistory.length / HISTORY_PAGE_SIZE);
            if (currentHistoryPage < totalPages) {
                currentHistoryPage++;
                renderHistoryView();
            }
        });
    }

    if (pageInput) {
        pageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const totalPages = Math.ceil(syncHistory.length / HISTORY_PAGE_SIZE);
                let targetPage = parseInt(pageInput.value, 10);
                if (isNaN(targetPage) || targetPage < 1) targetPage = 1;
                if (targetPage > totalPages) targetPage = totalPages;
                currentHistoryPage = targetPage;
                renderHistoryView();
            }
        });
        pageInput.addEventListener('blur', () => {
            const totalPages = Math.ceil(syncHistory.length / HISTORY_PAGE_SIZE);
            let targetPage = parseInt(pageInput.value, 10);
            if (isNaN(targetPage) || targetPage < 1) targetPage = 1;
            if (targetPage > totalPages) targetPage = totalPages;
            if (targetPage !== currentHistoryPage) {
                currentHistoryPage = targetPage;
                renderHistoryView();
            } else {
                pageInput.value = currentHistoryPage;
            }
        });
    }
}

// 编辑备注
async function editCommitNote(recordTime) {
    const record = syncHistory.find(r => r.time === recordTime);
    if (!record) return;

    const currentNote = record.note || '';
    const newNote = prompt(
        currentLang === 'zh_CN' ? '输入备注（留空则删除备注）：' : 'Enter note (leave empty to remove):',
        currentNote
    );

    // 如果用户取消，返回
    if (newNote === null) return;

    // 更新本地记录
    record.note = newNote || '';

    // 同步到存储
    try {
        await new Promise((resolve) => {
            browserAPI.storage.local.get(['syncHistory'], (data) => {
                const history = data.syncHistory || [];
                const index = history.findIndex(r => r.time === recordTime);
                if (index >= 0) {
                    history[index].note = record.note;
                    browserAPI.storage.local.set({ syncHistory: history }, resolve);
                } else {
                    resolve();
                }
            });
        });

        // 重新渲染历史视图
        renderHistoryView();

        // 显示成功提示
        showToast(currentLang === 'zh_CN' ? '备注已更新' : 'Note updated');
    } catch (error) {
        console.error('[editCommitNote] 保存备注失败:', error);
        showToast(currentLang === 'zh_CN' ? '保存备注失败' : 'Failed to save note');
    }
}

function calculateChanges(record, index, reversedHistory) {
    const bookmarkStats = record.bookmarkStats || {};

    // 如果是第一次备份
    // 兼容旧数据：如果没有 isFirstBackup 字段，则把最旧的一条视为首次备份
    const isFirstBackup = record.isFirstBackup === true ||
        (typeof record.isFirstBackup !== 'boolean' && index === reversedHistory.length - 1);
    if (isFirstBackup) {
        return {
            bookmarkDiff: bookmarkStats.currentBookmarkCount || 0,
            folderDiff: bookmarkStats.currentFolderCount || 0,
            isFirst: true,
            hasNoChange: false
        };
    }

    // 获取数量变化（来自 bookmarkStats）
    const bookmarkDiff = bookmarkStats.bookmarkDiff || 0;
    const folderDiff = bookmarkStats.folderDiff || 0;

    // 新口径：新增/删除分开计数（支持“加减相同数量但内容不同”）
    const bookmarkAdded = typeof bookmarkStats.bookmarkAdded === 'number' ? bookmarkStats.bookmarkAdded : (bookmarkDiff > 0 ? bookmarkDiff : 0);
    const bookmarkDeleted = typeof bookmarkStats.bookmarkDeleted === 'number' ? bookmarkStats.bookmarkDeleted : (bookmarkDiff < 0 ? Math.abs(bookmarkDiff) : 0);
    const folderAdded = typeof bookmarkStats.folderAdded === 'number' ? bookmarkStats.folderAdded : (folderDiff > 0 ? folderDiff : 0);
    const folderDeleted = typeof bookmarkStats.folderDeleted === 'number' ? bookmarkStats.folderDeleted : (folderDiff < 0 ? Math.abs(folderDiff) : 0);

    // 获取结构变化标记（来自 bookmarkStats）
    const bookmarkMoved = bookmarkStats.bookmarkMoved || false;
    const folderMoved = bookmarkStats.folderMoved || false;
    const bookmarkModified = bookmarkStats.bookmarkModified || false;
    const folderModified = bookmarkStats.folderModified || false;

    // 获取结构变化的具体数量（如果是数字则使用，否则为0或1）
    const bookmarkMovedCount = typeof bookmarkStats.movedBookmarkCount === 'number'
        ? bookmarkStats.movedBookmarkCount
        : (typeof bookmarkStats.bookmarkMoved === 'number' ? bookmarkStats.bookmarkMoved : (bookmarkMoved ? 1 : 0));
    const folderMovedCount = typeof bookmarkStats.movedFolderCount === 'number'
        ? bookmarkStats.movedFolderCount
        : (typeof bookmarkStats.folderMoved === 'number' ? bookmarkStats.folderMoved : (folderMoved ? 1 : 0));
    const bookmarkModifiedCount = typeof bookmarkStats.modifiedBookmarkCount === 'number'
        ? bookmarkStats.modifiedBookmarkCount
        : (typeof bookmarkStats.bookmarkModified === 'number' ? bookmarkStats.bookmarkModified : (bookmarkModified ? 1 : 0));
    const folderModifiedCount = typeof bookmarkStats.modifiedFolderCount === 'number'
        ? bookmarkStats.modifiedFolderCount
        : (typeof bookmarkStats.folderModified === 'number' ? bookmarkStats.folderModified : (folderModified ? 1 : 0));

    // 判断变化类型
    const hasNumericalChange = bookmarkAdded > 0 || bookmarkDeleted > 0 || folderAdded > 0 || folderDeleted > 0;
    const hasStructuralChange = bookmarkMoved || folderMoved || bookmarkModified || folderModified;
    const hasNoChange = !hasNumericalChange && !hasStructuralChange;

    return {
        bookmarkDiff,
        folderDiff,
        bookmarkAdded,
        bookmarkDeleted,
        folderAdded,
        folderDeleted,
        isFirst: false,
        hasNoChange,
        hasNumericalChange,
        hasStructuralChange,
        bookmarkMoved,
        folderMoved,
        bookmarkModified,
        folderModified,
        // 新增：具体数量
        bookmarkMovedCount,
        folderMovedCount,
        bookmarkModifiedCount,
        folderModifiedCount
    };
}

function renderCommitStats(changes) {
    if (changes.isFirst) {
        return `
            <div class="commit-stats">
                <span>${i18n.firstBackup[currentLang]}: ${changes.bookmarkDiff} ${i18n.bookmarks[currentLang]}, ${changes.folderDiff} ${i18n.folders[currentLang]}</span>
            </div>
        `;
    }

    // 使用bookmarkStats的数据来判断是否有变化
    if (changes.hasNoChange) {
        return `
            <div class="commit-stats no-change">
                <span style="color: var(--text-tertiary);">
                    <i class="fas fa-check-circle" style="color: var(--success); margin-right: 4px;"></i>
                    ${currentLang === 'zh_CN' ? '无变化' : 'No Changes'}
                </span>
            </div>
        `;
    }

    const parts = [];

    // 显示数量变化
    if (changes.hasNumericalChange) {
        const quantityParts = [];
        if (changes.bookmarkAdded > 0) quantityParts.push(`+${changes.bookmarkAdded} ${i18n.bookmarks[currentLang]}`);
        if (changes.bookmarkDeleted > 0) quantityParts.push(`-${changes.bookmarkDeleted} ${i18n.bookmarks[currentLang]}`);
        if (changes.folderAdded > 0) quantityParts.push(`+${changes.folderAdded} ${i18n.folders[currentLang]}`);
        if (changes.folderDeleted > 0) quantityParts.push(`-${changes.folderDeleted} ${i18n.folders[currentLang]}`);
        const quantityText = quantityParts.join(', ');

        parts.push(`
            <span class="stat-change added">
                <i class="fas fa-plus-circle"></i>
                ${quantityText}
            </span>
        `);
    }

    // 显示结构变化的具体类型
    if (changes.bookmarkMoved || changes.folderMoved) {
        parts.push(`
            <span class="stat-change moved">
                <i class="fas fa-arrows-alt"></i>
                ${currentLang === 'zh_CN' ? '移动' : 'Moved'}
            </span>
        `);
    }

    if (changes.bookmarkModified || changes.folderModified) {
        parts.push(`
            <span class="stat-change modified">
                <i class="fas fa-edit"></i>
                ${currentLang === 'zh_CN' ? '修改' : 'Modified'}
            </span>
        `);
    }

    if (parts.length === 0) {
        parts.push(`<span style="color: var(--text-tertiary);">${currentLang === 'zh_CN' ? '无变化' : 'No Changes'}</span>`);
    }

    return `<div class="commit-stats">${parts.join('')}</div>`;
}

// 用于在中间行显示的内联变化信息
function renderCommitStatsInline(changes) {
    // 恢复操作：隐藏具体的增删数量统计
    if (changes.isRestoreHiddenStats) {
        return '';
    }

    if (changes.isRestore) { // 之前的逻辑保留备用，但现在主要靠 isRestoreHiddenStats
        return `<span class="stat-badge restore" style="background: var(--accent-light); color: var(--accent-primary); border: 1px solid var(--accent-primary);">
                    <i class="fas fa-undo"></i> ${currentLang === 'zh_CN' ? '恢复' : 'Restore'}
                </span>`;
    }

    if (changes.isFirst) {
        return `<span class="stat-badge first">${currentLang === 'zh_CN' ? '首次备份' : 'First Backup'}</span>`;
    }

    // 使用bookmarkStats的数据来判断是否有变化
    if (changes.hasNoChange) {
        return `
            <span class="stat-badge no-change">
                <i class="fas fa-check-circle" style="color: var(--success);"></i>
                ${currentLang === 'zh_CN' ? '无变化' : 'No Changes'}
            </span>
        `;
    }

    // 收集所有统计项，合并到一个横条里
    const statItems = [];

    // 增加的统计
    if (changes.bookmarkAdded > 0 || changes.folderAdded > 0) {
        const addedParts = [];
        if (changes.bookmarkAdded > 0) {
            const bookmarkLabel = currentLang === 'zh_CN' ? '书签' : 'BKM';
            addedParts.push(`<span class="stat-label">${bookmarkLabel}</span> <span class="stat-color added">+${changes.bookmarkAdded}</span>`);
        }
        if (changes.folderAdded > 0) {
            const folderLabel = currentLang === 'zh_CN' ? '文件夹' : 'FLD';
            addedParts.push(`<span class="stat-label">${folderLabel}</span> <span class="stat-color added">+${changes.folderAdded}</span>`);
        }
        if (addedParts.length > 0) statItems.push(addedParts.join(' '));
    }

    // 删除的统计
    if (changes.bookmarkDeleted > 0 || changes.folderDeleted > 0) {
        const deletedParts = [];
        if (changes.bookmarkDeleted > 0) {
            const bookmarkLabel = currentLang === 'zh_CN' ? '书签' : 'BKM';
            deletedParts.push(`<span class="stat-label">${bookmarkLabel}</span> <span class="stat-color deleted">-${changes.bookmarkDeleted}</span>`);
        }
        if (changes.folderDeleted > 0) {
            const folderLabel = currentLang === 'zh_CN' ? '文件夹' : 'FLD';
            deletedParts.push(`<span class="stat-label">${folderLabel}</span> <span class="stat-color deleted">-${changes.folderDeleted}</span>`);
        }
        if (deletedParts.length > 0) statItems.push(deletedParts.join(' '));
    }

    // 移动的统计（只显示总数）
    if (changes.bookmarkMoved || changes.folderMoved) {
        const movedTotal = (changes.bookmarkMovedCount || 0) + (changes.folderMovedCount || 0);
        const movedLabel = currentLang === 'zh_CN' ? '移动' : 'Moved';
        if (movedTotal > 0) {
            statItems.push(`<span class="stat-label">${movedLabel}</span> <span class="stat-color moved">${movedTotal}</span>`);
        } else {
            statItems.push(`<span class="stat-color moved">${movedLabel}</span>`);
        }
    }

    // 修改的统计（只显示总数）
    if (changes.bookmarkModified || changes.folderModified) {
        const modifiedTotal = (changes.bookmarkModifiedCount || 0) + (changes.folderModifiedCount || 0);
        const modifiedLabel = currentLang === 'zh_CN' ? '修改' : 'Modified';
        if (modifiedTotal > 0) {
            statItems.push(`<span class="stat-label">${modifiedLabel}</span> <span class="stat-color modified">${modifiedTotal}</span>`);
        } else {
            statItems.push(`<span class="stat-color modified">${modifiedLabel}</span>`);
        }
    }

    if (statItems.length === 0) {
        return `<span class="stat-badge no-change">${currentLang === 'zh_CN' ? '无变化' : 'No Changes'}</span>`;
    }

    // 所有项目合并到一个横条里，用分隔符分开
    const separator = ' <span style="color:var(--text-tertiary);margin:0 4px;">|</span> ';
    return `<span class="stat-badge quantity">${statItems.join(separator)}</span>`;
}

// =============================================================================
// 书签温故视图
// =============================================================================

function renderAdditionsView() {
    const container = document.getElementById('additionsList');

    // 【修复】容器已被删除（在UI重构中），直接返回
    if (!container) {
        console.log('[renderAdditionsView] additionsList容器不存在，跳过渲染');
        return;
    }

    if (allBookmarks.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fas fa-bookmark"></i></div>
                <div class="empty-state-title">${i18n.emptyAdditions[currentLang]}</div>
            </div>
        `;
        return;
    }

    // 按时间范围分组（年、月、日）
    const groupedByTime = groupBookmarksByTime(allBookmarks, currentTimeFilter);

    // 过滤
    const filtered = filterBookmarks(groupedByTime);

    container.innerHTML = renderBookmarkGroups(filtered, currentTimeFilter);

    // 绑定折叠/展开事件
    attachAdditionGroupEvents();
}

// 初始化「书签温故」子视图标签和行为
function initAdditionsSubTabs() {
    const tabs = document.querySelectorAll('.additions-tab');
    const reviewPanel = document.getElementById('additionsReviewPanel');
    const browsingPanel = document.getElementById('additionsBrowsingPanel');
    const trackingPanel = document.getElementById('additionsTrackingPanel');

    if (!tabs.length || !reviewPanel || !browsingPanel) {
        console.warn('[initAdditionsSubTabs] 主标签或面板缺失');
        return;
    }

    let browsingHistoryInitialized = false;
    let trackingInitialized = false;

    // 标签切换函数
    const switchToTab = (target, shouldSave = true) => {
        // 切换标签高亮
        tabs.forEach(t => t.classList.remove('active'));
        const targetTab = document.querySelector(`.additions-tab[data-tab="${target}"]`);
        if (targetTab) targetTab.classList.add('active');

        // 切换子视图
        reviewPanel.classList.remove('active');
        browsingPanel.classList.remove('active');
        if (trackingPanel) trackingPanel.classList.remove('active');

        if (target === 'review') {
            reviewPanel.classList.add('active');
            try {
                renderAdditionsView();
            } catch (error) {
                console.warn('[initAdditionsSubTabs] 渲染书签添加记录失败:', error);
            }
        } else if (target === 'browsing') {
            browsingPanel.classList.add('active');
            // 初始化浏览记录日历（首次点击时）
            if (!browsingHistoryInitialized) {
                browsingHistoryInitialized = true;
                try {
                    initBrowsingHistoryCalendar();
                } catch (e) {
                    console.error('[Additions] 初始化浏览记录日历失败:', e);
                }
            } else {
                refreshBrowsingHistoryData({ forceFull: false, silent: true });
            }
        } else if (target === 'tracking' && trackingPanel) {
            trackingPanel.classList.add('active');
            // 初始化时间捕捉（首次点击时）
            if (!trackingInitialized) {
                trackingInitialized = true;
                initTrackingToggle();
            }
            // 每次切换到标签时加载最新数据
            loadCurrentTrackingSessions();
            loadActiveTimeRanking();
            // 启动当前会话的实时刷新（排行榜不定时刷新）
            startTrackingRefresh();
        }

        // 保存当前状态
        if (shouldSave) {
            localStorage.setItem('additionsActiveTab', target);
        }
    };

    // 绑定点击事件
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            switchToTab(tab.dataset.tab, true);
        });
    });

    // 恢复上次选中的标签
    const savedTab = localStorage.getItem('additionsActiveTab');
    if (savedTab && ['review', 'browsing', 'tracking'].includes(savedTab)) {
        switchToTab(savedTab, false);
    }

    // 初始化浏览记录的子标签
    initBrowsingSubTabs();
}

// 初始化浏览记录子标签
function initBrowsingSubTabs() {
    const subTabs = document.querySelectorAll('.browsing-sub-tab');
    const historyPanel = document.getElementById('browsingHistoryPanel');
    const rankingPanel = document.getElementById('browsingRankingPanel');
    const relatedPanel = document.getElementById('browsingRelatedPanel');
    let browsingRankingInitialized = false;
    let browsingRelatedInitialized = false;

    if (!subTabs.length || !historyPanel || !rankingPanel || !relatedPanel) {
        console.warn('[initBrowsingSubTabs] 子标签或面板缺失');
        return;
    }

    // 子标签切换函数
    const switchToSubTab = (target, shouldSave = true) => {
        // 切换子标签高亮
        subTabs.forEach(t => t.classList.remove('active'));
        const targetTab = document.querySelector(`.browsing-sub-tab[data-sub-tab="${target}"]`);
        if (targetTab) targetTab.classList.add('active');

        // 切换子面板
        historyPanel.classList.remove('active');
        rankingPanel.classList.remove('active');
        relatedPanel.classList.remove('active');

        if (target === 'history') {
            historyPanel.classList.add('active');
            refreshBrowsingHistoryData({ forceFull: false, silent: true });
        } else if (target === 'ranking') {
            rankingPanel.classList.add('active');
            if (!browsingRankingInitialized) {
                browsingRankingInitialized = true;
                try {
                    initBrowsingClickRanking();
                } catch (e) {
                    console.error('[initBrowsingSubTabs] 初始化点击排行失败:', e);
                }
            } else {
                refreshBrowsingHistoryData({ forceFull: false, silent: true });
                browsingClickRankingStats = null;
                refreshActiveBrowsingRankingIfVisible();
            }
        } else if (target === 'related') {
            relatedPanel.classList.add('active');
            if (!browsingRelatedInitialized) {
                browsingRelatedInitialized = true;
                try {
                    initBrowsingRelatedHistory();
                } catch (e) {
                    console.error('[initBrowsingSubTabs] 初始化书签关联记录失败:', e);
                }
            } else {
                refreshBrowsingRelatedHistory();
            }
        }

        // 保存当前状态
        if (shouldSave) {
            localStorage.setItem('browsingActiveSubTab', target);
        }
    };

    // 绑定点击事件
    subTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            switchToSubTab(tab.dataset.subTab, true);
        });
    });

    // 恢复上次选中的子标签
    const savedSubTab = localStorage.getItem('browsingActiveSubTab');
    if (savedSubTab && ['history', 'ranking', 'related'].includes(savedSubTab)) {
        switchToSubTab(savedSubTab, false);
    }
}

/*
 * ============================================================================
 * 以下「书签点击排行」相关代码已注释，UI已删除，等待重构
 * ============================================================================
 */

/*
// 基于浏览器历史记录的“书签点击排行榜”（书签温故第二个子视图）
function loadBookmarkClickRankingForAdditions(container) {
    if (!container) return;
 
    container.innerHTML = `
        <div class="empty-state">
            <div class="empty-state-icon"><i class="fas fa-clock"></i></div>
            <div class="empty-state-title">${currentLang === 'zh_CN' ? '正在读取历史记录...' : 'Loading history...'}</div>
        </div>
    `;
 
    if (!browserAPI || !browserAPI.history || typeof browserAPI.history.getVisits !== 'function') {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fas fa-ban"></i></div>
                <div class="empty-state-title">${currentLang === 'zh_CN' ? '当前环境不支持历史记录统计' : 'History statistics are not available in this environment'}</div>
                <div class="empty-state-description">${currentLang === 'zh_CN' ? '请确认扩展已获得浏览器的历史记录权限。' : 'Please ensure the extension has permission to access browser history.'}</div>
            </div>
        `;
        return;
    }
 
    if (!Array.isArray(allBookmarks) || allBookmarks.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fas fa-bookmark"></i></div>
                <div class="empty-state-title">${currentLang === 'zh_CN' ? '暂无书签可统计' : 'No bookmarks to analyze'}</div>
            </div>
        `;
        return;
    }
 
    // 仅统计有效的 HTTP/HTTPS 书签，限制数量避免开销过大
    const candidates = allBookmarks
        .filter(b => b.url && (b.url.startsWith('http://') || b.url.startsWith('https://')))
        .slice(0, 150);
 
    if (!candidates.length) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fas fa-bookmark"></i></div>
                <div class="empty-state-title">${currentLang === 'zh_CN' ? '暂无可统计的书签' : 'No bookmarks available for statistics'}</div>
            </div>
        `;
        return;
    }
 
    const now = Date.now();
    const oneDay = 24 * 60 * 60 * 1000;
 
    const rankingMap = new Map(); // url -> stats
    let pending = candidates.length;
 
    const finishIfDone = () => {
        pending -= 1;
        if (pending > 0) return;
 
        const items = Array.from(rankingMap.values())
            // 只保留至少有一次访问的
            .filter(item =>
                item.last1d ||
                item.last3d ||
                item.last7d ||
                item.last30d ||
                item.last90d ||
                item.last180d ||
                item.last365d
            );
 
        if (!items.length) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i class="fas fa-clock"></i></div>
                    <div class="empty-state-title">${currentLang === 'zh_CN' ? '暂无点击记录' : 'No click records found'}</div>
                    <div class="empty-state-description">${currentLang === 'zh_CN' ? '浏览器历史记录中尚未找到这些书签的访问记录。' : 'No visit records for these bookmarks were found in browser history.'}</div>
                </div>
            `;
            return;
        }
 
        // 排序：优先最近 7 天，再看 30 天
        items.sort((a, b) => {
            if (b.last7d !== a.last7d) return b.last7d - a.last7d;
            if (b.last30d !== a.last30d) return b.last30d - a.last30d;
            return (b.last365d || 0) - (a.last365d || 0);
        });
 
        renderBookmarkClickRankingList(container, items.slice(0, 50));
    };
 
    candidates.forEach(bookmark => {
        try {
            browserAPI.history.getVisits({ url: bookmark.url }, (visits) => {
                const runtime = browserAPI.runtime;
                if (runtime && runtime.lastError) {
                    finishIfDone();
                    return;
                }
 
                const key = bookmark.url;
                let info = rankingMap.get(key);
                if (!info) {
                    info = {
                        url: bookmark.url,
                        title: bookmark.title || bookmark.url,
                        lastVisitTime: 0,
                        last1d: 0,
                        last3d: 0,
                        last7d: 0,
                        last30d: 0,
                        last90d: 0,
                        last180d: 0,
                        last365d: 0
                    };
                    rankingMap.set(key, info);
                }
 
                if (Array.isArray(visits)) {
                    visits.forEach(v => {
                        const t = typeof v.visitTime === 'number' ? v.visitTime : 0;
                        if (!t) return;
 
                        if (t > info.lastVisitTime) {
                            info.lastVisitTime = t;
                        }
 
                        const diff = now - t;
                        if (diff <= oneDay) info.last1d += 1;
                        if (diff <= 3 * oneDay) info.last3d += 1;
                        if (diff <= 7 * oneDay) info.last7d += 1;
                        if (diff <= 30 * oneDay) info.last30d += 1;
                        if (diff <= 90 * oneDay) info.last90d += 1;
                        if (diff <= 180 * oneDay) info.last180d += 1;
                        if (diff <= 365 * oneDay) info.last365d += 1;
                    });
                }
 
                finishIfDone();
            });
        } catch (e) {
            finishIfDone();
        }
    });
}
 
function renderBookmarkClickRankingList(container, items) {
    container.innerHTML = '';
 
    items.forEach(entry => {
        const row = document.createElement('div');
        row.className = 'addition-item ranking-item';
 
        const icon = document.createElement('img');
        icon.className = 'addition-icon';
        icon.src = getFaviconUrl(entry.url);
        icon.alt = '';
 
        const info = document.createElement('div');
        info.className = 'addition-info';
 
        const titleLink = document.createElement('a');
        titleLink.className = 'addition-title';
        titleLink.href = entry.url;
        titleLink.target = '_blank';
        titleLink.rel = 'noopener noreferrer';
        titleLink.textContent = entry.title;
 
        const urlDiv = document.createElement('div');
        urlDiv.className = 'addition-url';
        urlDiv.textContent = entry.url;
 
        info.appendChild(titleLink);
        info.appendChild(urlDiv);
 
        const counts = document.createElement('div');
        counts.className = 'ranking-counts';
        counts.textContent = currentLang === 'zh_CN'
            ? `7天：${entry.last7d}，30天：${entry.last30d}`
            : `7 days: ${entry.last7d}, 30 days: ${entry.last30d}`;
 
        const header = document.createElement('div');
        header.className = 'ranking-item-header';
        header.appendChild(info);
        header.appendChild(counts);
 
        const detail = document.createElement('div');
        detail.className = 'ranking-detail';
        detail.style.display = 'none';
 
        const lastVisitText = entry.lastVisitTime
            ? new Date(entry.lastVisitTime).toLocaleString()
            : (currentLang === 'zh_CN' ? '无访问记录' : 'No visits');
 
        if (currentLang === 'zh_CN') {
            detail.textContent =
                `1天：${entry.last1d}，3天：${entry.last3d}，7天：${entry.last7d}，` +
                `30天：${entry.last30d}，90天：${entry.last90d}，180天：${entry.last180d}，365天：${entry.last365d}；` +
                `最近访问：${lastVisitText}`;
        } else {
            detail.textContent =
                `1 day: ${entry.last1d}, 3 days: ${entry.last3d}, 7 days: ${entry.last7d}, ` +
                `30 days: ${entry.last30d}, 90 days: ${entry.last90d}, 180 days: ${entry.last180d}, 365 days: ${entry.last365d}; ` +
                `Last visit: ${lastVisitText}`;
        }
 
        row.appendChild(icon);
        row.appendChild(header);
        row.appendChild(detail);
 
        // 整行可点击：展开/收起详细统计，同时打开书签
        row.addEventListener('click', (e) => {
            // 如果直接点击的是标题链接，让浏览器默认打开，不拦截
            if (e.target === titleLink) {
                return;
            }
 
            e.preventDefault();
 
            // 切换详情可见性
            const visible = detail.style.display === 'block';
            detail.style.display = visible ? 'none' : 'block';
 
            // 打开对应书签
            try {
                if (browserAPI && browserAPI.tabs && typeof browserAPI.tabs.create === 'function') {
                    browserAPI.tabs.create({ url: entry.url });
                } else {
                    window.open(entry.url, '_blank');
                }
            } catch (err) {
                console.warn('[Additions] 打开书签失败:', err);
            }
        });
 
        container.appendChild(row);
    });
}
*/

/*
 * ============================================================================
 * 以上「书签点击排行」相关代码已注释，UI已删除，等待重构
 * ============================================================================
 */

// 基于浏览器历史记录的「点击排行」（书签浏览记录子视图）

function getBrowsingClickRankingBoundaries() {
    const now = new Date();
    const nowMs = now.getTime();

    // 当天起始（本地时区）
    const dayStartDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const dayStart = dayStartDate.getTime();

    // 与「点击记录」日历保持一致：
    // - 中文使用周一作为一周开始
    // - 其他语言使用周日作为一周开始
    const weekStartDay = currentLang === 'zh_CN' ? 1 : 0; // 0=周日,1=周一,...
    const weekStartDate = new Date(dayStartDate);
    const currentDay = weekStartDate.getDay(); // 0-6 (周日-周六)
    let diff = currentDay - weekStartDay;
    if (diff < 0) diff += 7;
    weekStartDate.setDate(weekStartDate.getDate() - diff);
    const weekStart = weekStartDate.getTime();

    // 当月起始
    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1).getTime();

    // 当年起始
    const yearStart = new Date(now.getFullYear(), 0, 1).getTime();

    return { now: nowMs, dayStart, weekStart, monthStart, yearStart };
}

async function ensureBrowsingClickRankingStats() {
    if (browsingClickRankingStats) {
        return browsingClickRankingStats;
    }

    // 如果历史记录 API 完全不可用，直接标记为不支持
    if (!browserAPI || !browserAPI.history || typeof browserAPI.history.search !== 'function') {
        browsingClickRankingStats = { items: [], error: 'noHistoryApi' };
        return browsingClickRankingStats;
    }

    // 确保「点击记录」日历已初始化
    try {
        if (typeof initBrowsingHistoryCalendar === 'function' && !window.browsingHistoryCalendarInstance) {
            initBrowsingHistoryCalendar();
        }
    } catch (e) {
        console.warn('[BrowsingRanking] 初始化 BrowsingHistoryCalendar 失败:', e);
    }

    // 等待日历数据（基于 bookmarksByDate）
    const waitForCalendarData = async () => {
        const start = Date.now();
        const timeout = 5000;
        while (Date.now() - start < timeout) {
            const inst = window.browsingHistoryCalendarInstance;
            if (inst && inst.bookmarksByDate && inst.bookmarksByDate.size > 0) {
                return inst;
            }
            await new Promise(resolve => setTimeout(resolve, 200));
        }
        return window.browsingHistoryCalendarInstance || null;
    };

    const calendar = await waitForCalendarData();

    if (!calendar || !calendar.bookmarksByDate) {
        browsingClickRankingStats = { items: [], error: 'noBookmarks' };
        return browsingClickRankingStats;
    }

    // 如果完全没有任何点击记录，则视为无数据
    if (calendar.bookmarksByDate.size === 0) {
        browsingClickRankingStats = { items: [], error: 'noBookmarks' };
        return browsingClickRankingStats;
    }

    const boundaries = getBrowsingClickRankingBoundaries();

    // ✨ 通过书签 API 获取 URL 和标题集合，用于构建书签标识映射
    // 与「书签关联记录」和「点击记录」保持一致，使用 URL 或标题的并集匹配
    let bookmarkData;
    try {
        bookmarkData = await getBookmarkUrlsAndTitles();
    } catch (error) {
        console.warn('[BrowsingRanking] 获取书签URL和标题失败:', error);
        browsingClickRankingStats = { items: [], error: 'noBookmarks' };
        return browsingClickRankingStats;
    }

    const bookmarkInfoByUrl = bookmarkData && bookmarkData.info ? bookmarkData.info : null;
    if (!bookmarkInfoByUrl || bookmarkInfoByUrl.size === 0) {
        browsingClickRankingStats = { items: [], error: 'noBookmarks' };
        return browsingClickRankingStats;
    }

    // 构建 URL/标题 -> 书签主键的映射
    // 标题相同的书签合并为同一个统计项（共享 bookmarkKey）
    const bookmarkKeyMap = new Map(); // url or title (normalized) -> bookmarkKey
    const bookmarkInfoMap = new Map(); // bookmarkKey -> { url, title, urls: [] }

    let bookmarkKeyCounter = 0;
    for (const [url, info] of bookmarkInfoByUrl.entries()) {
        const normalizedUrl = url;
        const normalizedTitle = info && typeof info.title === 'string' ? info.title.trim() : '';

        // 检查是否已有相同标题的书签
        let bookmarkKey = null;
        if (normalizedTitle) {
            bookmarkKey = bookmarkKeyMap.get(`title:${normalizedTitle}`);
        }

        if (bookmarkKey) {
            // 标题相同，复用已有的 bookmarkKey，添加 URL 映射
            bookmarkKeyMap.set(`url:${normalizedUrl}`, bookmarkKey);
            // 记录额外的 URL
            const existingInfo = bookmarkInfoMap.get(bookmarkKey);
            if (existingInfo && existingInfo.urls) {
                existingInfo.urls.push(normalizedUrl);
            }
        } else {
            // 创建新的 bookmarkKey
            bookmarkKey = `bm_${bookmarkKeyCounter++}`;
            bookmarkKeyMap.set(`url:${normalizedUrl}`, bookmarkKey);
            if (normalizedTitle) {
                bookmarkKeyMap.set(`title:${normalizedTitle}`, bookmarkKey);
            }
            bookmarkInfoMap.set(bookmarkKey, {
                url: normalizedUrl,
                title: normalizedTitle || normalizedUrl,
                urls: [normalizedUrl]
            });
        }
    }

    const statsMap = new Map(); // bookmarkKey -> stats

    // 从「点击记录」的数据结构中汇总统计信息
    for (const bookmarks of calendar.bookmarksByDate.values()) {
        bookmarks.forEach(bm => {
            if (!bm || !bm.url) return;

            const url = bm.url;
            const title = typeof bm.title === 'string' && bm.title.trim()
                ? bm.title.trim()
                : (bm.url || '');
            const t = typeof bm.visitTime === 'number'
                ? bm.visitTime
                : (bm.dateAdded instanceof Date ? bm.dateAdded.getTime() : 0);
            if (!t) return;

            // ✨ 每条历史记录的 visitCount 应该是 1（单次访问），不应累积浏览器的总访问次数
            // 因为我们已经将每次访问都记录为单独的记录
            const increment = 1;

            // ✨ 找出这条记录匹配的书签（优先URL匹配，其次标题匹配）
            let bookmarkKey = bookmarkKeyMap.get(`url:${url}`);
            if (!bookmarkKey && title) {
                // URL 不匹配，尝试标题匹配
                bookmarkKey = bookmarkKeyMap.get(`title:${title}`);
            }

            if (!bookmarkKey) {
                // 没有匹配的书签，跳过（理论上不应该发生，因为这些记录来自存储库3）
                return;
            }

            let stats = statsMap.get(bookmarkKey);
            if (!stats) {
                const info = bookmarkInfoMap.get(bookmarkKey);
                stats = {
                    url: info.url,
                    title: info.title,
                    lastVisitTime: 0,
                    dayCount: 0,
                    weekCount: 0,
                    monthCount: 0,
                    yearCount: 0,
                    allCount: 0
                };
                statsMap.set(bookmarkKey, stats);
            }

            if (t > stats.lastVisitTime) {
                stats.lastVisitTime = t;
            }

            // ✨ 修复时间统计：只统计当前时间之前的访问
            const now = boundaries.now;
            if (t <= now) {
                stats.allCount += increment; // 全部时间范围
                if (t >= boundaries.dayStart && t <= now) stats.dayCount += increment;
                if (t >= boundaries.weekStart && t <= now) stats.weekCount += increment;
                if (t >= boundaries.monthStart && t <= now) stats.monthCount += increment;
                if (t >= boundaries.yearStart && t <= now) stats.yearCount += increment;
            }
        });
    }

    const items = Array.from(statsMap.values());

    // 保存映射供筛选函数使用
    browsingClickRankingStats = { items, boundaries, bookmarkKeyMap, bookmarkInfoMap };
    return browsingClickRankingStats;
}

function getBrowsingRankingItemsForRange(range) {
    if (!browsingClickRankingStats || !Array.isArray(browsingClickRankingStats.items)) {
        return [];
    }

    const key = range === 'day'
        ? 'dayCount'
        : range === 'week'
            ? 'weekCount'
            : range === 'year'
                ? 'yearCount'
                : range === 'all'
                    ? 'allCount'
                    : 'monthCount';

    const items = browsingClickRankingStats.items
        .filter(item => item[key] > 0)
        .sort((a, b) => {
            if (b[key] !== a[key]) return b[key] - a[key];
            return (b.lastVisitTime || 0) - (a.lastVisitTime || 0);
        });

    // 返回完整有序列表，渲染层做懒加载
    return items;
}

// 渲染文件夹模式的点击排行列表
async function renderBrowsingFolderRankingList(container, items, range, stats) {
    container.innerHTML = '';

    const isZh = currentLang === 'zh_CN';

    // 确保书签信息已加载（包含 folderPath）
    await getBookmarkUrlsAndTitles();

    if (!items.length) {
        const title = isZh ? '暂无点击记录' : 'No click records found';
        const desc = isZh ? '当前时间范围内尚未找到这些书签的访问记录。' : 'No visit records were found in the selected time range.';
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fas fa-folder"></i></div>
                <div class="empty-state-title">${title}</div>
                <div class="empty-state-description">${desc}</div>
            </div>
        `;
        return;
    }

    // 按文件夹聚合统计
    const folderStats = new Map(); // folderPath -> { count, items: [] }
    const bookmarkInfo = stats.bookmarkInfoMap;

    items.forEach(item => {
        // 尝试从 getBookmarkUrlsAndTitles 获取 folderPath
        let folderPath = [];
        if (browsingRelatedBookmarkInfo && browsingRelatedBookmarkInfo.has(item.url)) {
            folderPath = browsingRelatedBookmarkInfo.get(item.url).folderPath || [];
        }

        // 使用完整的文件夹路径作为分组键（精确到最后一级文件夹）
        const folderKey = folderPath.length > 0 ? folderPath.join(' / ') : (isZh ? '未分类' : 'Uncategorized');
        const folderName = folderPath.length > 0 ? folderPath[folderPath.length - 1] : folderKey;

        if (!folderStats.has(folderKey)) {
            folderStats.set(folderKey, {
                name: folderName,
                fullPath: folderKey,
                folderPath: folderPath,
                count: 0,
                items: []
            });
        }

        const folderData = folderStats.get(folderKey);
        const itemCount = item.filteredCount !== undefined ? item.filteredCount : (
            range === 'day' ? item.dayCount :
                range === 'week' ? item.weekCount :
                    range === 'year' ? item.yearCount :
                        range === 'all' ? item.allCount : item.monthCount
        );
        folderData.count += itemCount;
        folderData.items.push({ ...item, count: itemCount, folderPath });
    });

    // 按点击次数排序文件夹
    const sortedFolders = Array.from(folderStats.values()).sort((a, b) => b.count - a.count);

    // 渲染文件夹列表
    const rangeLabel = (() => {
        if (range === 'day') return isZh ? '今天' : 'Today';
        if (range === 'week') return isZh ? '本周' : 'This week';
        if (range === 'year') return isZh ? '本年' : 'This year';
        if (range === 'all') return isZh ? '全部' : 'All';
        return isZh ? '本月' : 'This month';
    })();

    sortedFolders.forEach((folder, index) => {
        const folderRow = document.createElement('div');
        folderRow.className = 'ranking-item folder-ranking-item';
        folderRow.style.cursor = 'pointer';

        // 排名样式
        let rankClass = '';
        if (index === 0) rankClass = 'rank-gold';
        else if (index === 1) rankClass = 'rank-silver';
        else if (index === 2) rankClass = 'rank-bronze';

        const header = document.createElement('div');
        header.className = 'ranking-header';

        // 排名数字
        const rank = document.createElement('span');
        rank.className = 'ranking-rank';
        rank.textContent = index + 1;
        if (rankClass) rank.classList.add(rankClass);
        header.appendChild(rank);

        // 文件夹图标和名称
        const main = document.createElement('div');
        main.className = 'ranking-main';
        const pathDisplay = folder.fullPath !== folder.name ? folder.fullPath : '';
        const safeFolderName = escapeHtml(folder.name);
        const safeFolderFullPath = escapeHtml(folder.fullPath);
        const safePathDisplay = escapeHtml(pathDisplay);
        main.innerHTML = `
            <div class="ranking-icon" style="color: var(--accent-primary);">
                <i class="fas fa-folder"></i>
            </div>
            <div class="ranking-info">
                <div class="ranking-title" title="${safeFolderFullPath}">${safeFolderName}</div>
                <div class="ranking-meta">${pathDisplay ? `${safePathDisplay} · ` : ''}${isZh ? `${folder.items.length} 个书签` : `${folder.items.length} bookmarks`}</div>
            </div>
        `;
        header.appendChild(main);

        // 点击次数
        const counts = document.createElement('div');
        counts.className = 'ranking-counts';
        if (rankClass) counts.classList.add(rankClass);
        counts.textContent = folder.count.toLocaleString(isZh ? 'zh-CN' : 'en-US');
        counts.dataset.tooltip = isZh ? `${rangeLabel}：${folder.count} 次` : `${rangeLabel}: ${folder.count} clicks`;
        header.appendChild(counts);

        folderRow.appendChild(header);

        // 展开的书签列表
        const bookmarkList = document.createElement('div');
        bookmarkList.className = 'folder-bookmark-list';
        bookmarkList.style.display = 'none';
        bookmarkList.style.padding = '8px 0 8px 40px';
        bookmarkList.style.borderTop = '1px solid var(--border-color)';
        bookmarkList.style.marginTop = '8px';

        // 按点击次数排序书签
        folder.items.sort((a, b) => b.count - a.count);

        folder.items.forEach(item => {
            const bookmarkItem = document.createElement('div');
            bookmarkItem.style.display = 'flex';
            bookmarkItem.style.alignItems = 'center';
            bookmarkItem.style.gap = '8px';
            bookmarkItem.style.padding = '6px 8px';
            bookmarkItem.style.marginBottom = '4px';
            bookmarkItem.style.borderRadius = '4px';
            bookmarkItem.style.cursor = 'pointer';
            bookmarkItem.style.transition = 'background 0.2s';

            const itemTitle = item.title || item.url || '';
            const faviconSrc = typeof getFaviconUrl === 'function'
                ? getFaviconUrl(item.url)
                : `${(navigator.userAgent || '').includes('Edg/') ? 'edge' : 'chrome'}://favicon/${item.url || ''}`;

            bookmarkItem.innerHTML = `
                <img class="ranking-favicon" src="${escapeHtml(faviconSrc)}" style="width:16px;height:16px;flex-shrink:0;">
                <span style="flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:12px;" 
                      title="${escapeHtml(itemTitle)}">${escapeHtml(itemTitle)}</span>
                <span style="font-size:11px;color:var(--text-tertiary);flex-shrink:0;">${item.count}</span>
            `;

            bookmarkItem.addEventListener('mouseenter', () => {
                bookmarkItem.style.background = 'var(--bg-tertiary)';
            });
            bookmarkItem.addEventListener('mouseleave', () => {
                bookmarkItem.style.background = 'transparent';
            });
            bookmarkItem.addEventListener('click', (e) => {
                e.stopPropagation();
                try {
                    const browserAPI = (typeof chrome !== 'undefined') ? chrome : browser;
                    if (browserAPI?.tabs?.create) {
                        browserAPI.tabs.create({ url: item.url });
                    } else {
                        window.open(item.url, '_blank');
                    }
                } catch (err) {
                    console.warn('[FolderRanking] 打开书签失败:', err);
                }
            });

            bookmarkList.appendChild(bookmarkItem);
        });

        folderRow.appendChild(bookmarkList);

        // 点击展开/收起
        header.addEventListener('click', () => {
            const isExpanded = bookmarkList.style.display === 'block';
            bookmarkList.style.display = isExpanded ? 'none' : 'block';
            const icon = main.querySelector('.fa-folder, .fa-folder-open');
            if (icon) {
                icon.classList.toggle('fa-folder', isExpanded);
                icon.classList.toggle('fa-folder-open', !isExpanded);
            }
        });

        container.appendChild(folderRow);
    });
}

function renderBrowsingClickRankingList(container, items, range) {
    container.innerHTML = '';

    if (!items.length) {
        const isZh = currentLang === 'zh_CN';
        const title = i18n.browsingRankingEmptyTitle
            ? i18n.browsingRankingEmptyTitle[currentLang]
            : (isZh ? '暂无点击记录' : 'No click records found');
        const desc = i18n.browsingRankingEmptyDescription
            ? i18n.browsingRankingEmptyDescription[currentLang]
            : (isZh ? '当前时间范围内尚未找到这些书签的访问记录。' : 'No visit records were found in the selected time range.');

        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fas fa-clock"></i></div>
                <div class="empty-state-title">${title}</div>
                <div class="empty-state-description">${desc}</div>
            </div>
        `;
        return;
    }

    const isZh = currentLang === 'zh_CN';
    const rangeLabel = (() => {
        if (range === 'day') return isZh ? '今天' : 'Today';
        if (range === 'week') return isZh ? '本周' : 'This week';
        if (range === 'year') return isZh ? '本年' : 'This year';
        if (range === 'all') return isZh ? '全部' : 'All';
        return isZh ? '本月' : 'This month';
    })();

    const PAGE_SIZE = 200; // 每次加载200条
    let offset = 0;

    const appendNextPage = () => {
        const end = Math.min(offset + PAGE_SIZE, items.length);
        for (let i = offset; i < end; i++) {
            const entry = items[i];

            const row = document.createElement('div');
            row.className = 'addition-item ranking-item';

            const header = document.createElement('div');
            header.className = 'ranking-item-header';

            const main = document.createElement('div');
            main.className = 'ranking-main';

            const rankSpan = document.createElement('span');
            rankSpan.className = 'ranking-index';
            rankSpan.textContent = i + 1;
            let rankClass = '';
            if (i === 0) {
                rankClass = 'gold';
            } else if (i === 1) {
                rankClass = 'silver';
            } else if (i === 2) {
                rankClass = 'bronze';
            }
            if (rankClass) {
                rankSpan.classList.add(rankClass);
            }

            const icon = document.createElement('img');
            icon.className = 'addition-icon';
            icon.src = getFaviconUrl(entry.url);
            icon.alt = '';

            const info = document.createElement('div');
            info.className = 'addition-info';

            const titleLink = document.createElement('a');
            titleLink.className = 'addition-title';
            titleLink.href = entry.url;
            titleLink.target = '_blank';
            titleLink.rel = 'noopener noreferrer';
            titleLink.textContent = entry.title;

            const urlDiv = document.createElement('div');
            urlDiv.className = 'addition-url';
            urlDiv.textContent = entry.url;

            info.appendChild(titleLink);
            info.appendChild(urlDiv);

            main.appendChild(rankSpan);
            main.appendChild(icon);
            main.appendChild(info);

            const counts = document.createElement('div');
            counts.className = 'ranking-counts';

            // 优先使用筛选后的次数（如果存在）
            const value = entry.filteredCount !== undefined
                ? entry.filteredCount
                : (range === 'day'
                    ? entry.dayCount
                    : range === 'week'
                        ? entry.weekCount
                        : range === 'year'
                            ? entry.yearCount
                            : range === 'all'
                                ? entry.allCount
                                : entry.monthCount);
            const locale = currentLang === 'zh_CN' ? 'zh-CN' : 'en-US';
            const formattedValue = typeof value === 'number'
                ? value.toLocaleString(locale)
                : String(value);
            counts.textContent = formattedValue;

            if (rankClass) {
                counts.classList.add(rankClass);
            }

            const unitLabel = isZh ? '次' : (value === 1 ? 'click' : 'clicks');
            const accessibleLabel = isZh
                ? `${rangeLabel}：${value} ${unitLabel}`
                : `${rangeLabel}: ${value} ${unitLabel}`;
            counts.dataset.tooltip = accessibleLabel;
            counts.setAttribute('aria-label', accessibleLabel);

            header.appendChild(main);

            // 跳转按钮容器（点击次数左边）
            const jumpBtnContainer = document.createElement('div');
            jumpBtnContainer.className = 'jump-to-related-btn-container';
            jumpBtnContainer.style.display = 'flex';
            jumpBtnContainer.style.alignItems = 'center';
            jumpBtnContainer.style.flexShrink = '0';

            const jumpBtn = document.createElement('button');
            jumpBtn.className = 'jump-to-related-btn';
            jumpBtn.dataset.tooltip = isZh ? '跳转至关联记录' : 'Jump to Related History';
            jumpBtn.innerHTML = '<i class="fas fa-external-link-alt"></i>';
            jumpBtn.dataset.url = entry.url;
            jumpBtn.dataset.title = entry.title;
            jumpBtn.dataset.range = range;

            jumpBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (typeof jumpToRelatedHistoryFromRanking === 'function') {
                    jumpToRelatedHistoryFromRanking(entry.url, entry.title, range);
                }
            });

            // 容器也阻止事件冒泡
            jumpBtnContainer.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            jumpBtnContainer.appendChild(jumpBtn);
            header.appendChild(jumpBtnContainer);

            header.appendChild(counts);

            const detail = document.createElement('div');
            detail.className = 'ranking-detail';
            detail.style.display = 'none';

            const lastVisitText = entry.lastVisitTime
                ? new Date(entry.lastVisitTime).toLocaleString()
                : (isZh ? '无访问记录' : 'No visits');

            if (isZh) {
                detail.textContent =
                    `今天：${entry.dayCount} 次，本周：${entry.weekCount} 次，本月：${entry.monthCount} 次，本年：${entry.yearCount} 次；` +
                    `最近访问：${lastVisitText}`;
            } else {
                detail.textContent =
                    `Today: ${entry.dayCount} clicks, This week: ${entry.weekCount} clicks, ` +
                    `This month: ${entry.monthCount} clicks, This year: ${entry.yearCount} clicks; ` +
                    `Last visit: ${lastVisitText}`;
            }

            row.appendChild(header);
            row.appendChild(detail);

            // 整行可点击：展开/收起详细统计，同时打开书签
            row.addEventListener('click', (e) => {
                // 如果直接点击的是标题链接，让浏览器默认打开，不拦截
                if (e.target === titleLink) {
                    return;
                }

                // 如果点击的是跳转按钮或其容器，不执行打开书签操作
                if (e.target.closest('.jump-to-related-btn-container') ||
                    e.target.closest('.jump-to-related-btn')) {
                    return;
                }

                e.preventDefault();

                const visible = detail.style.display === 'block';
                detail.style.display = visible ? 'none' : 'block';

                try {
                    if (browserAPI && browserAPI.tabs && typeof browserAPI.tabs.create === 'function') {
                        browserAPI.tabs.create({ url: entry.url });
                    } else {
                        window.open(entry.url, '_blank');
                    }
                } catch (err) {
                    console.warn('[BrowsingRanking] 打开书签失败:', err);
                }
            });

            container.appendChild(row);
        }

        offset = end;
    };

    appendNextPage();

    // 找到真正的滚动容器（.content-area）
    const scrollContainer = container.closest('.content-area') || container;

    const onScroll = () => {
        if (offset >= items.length) return;
        // 提前加载：使用视口高度的3倍作为阈值，至少1500px
        const threshold = Math.max(1500, scrollContainer.clientHeight * 3);
        if (scrollContainer.scrollTop + scrollContainer.clientHeight + threshold >= scrollContainer.scrollHeight) {
            appendNextPage();
        }
    };

    // 清理旧的监听器
    if (scrollContainer.__browsingRankingScrollHandler) {
        scrollContainer.removeEventListener('scroll', scrollContainer.__browsingRankingScrollHandler);
    }
    scrollContainer.addEventListener('scroll', onScroll);
    scrollContainer.__browsingRankingScrollHandler = onScroll;

    // 暴露懒加载状态和函数，供跳转功能使用
    container.__lazyLoadState = {
        totalItems: items.length,
        getLoadedCount: () => offset,
        loadMore: appendNextPage,
        loadAll: () => {
            while (offset < items.length) {
                appendNextPage();
            }
        }
    };
}

async function loadBrowsingClickRanking(range) {
    const listContainer = document.getElementById('browsingRankingList');
    if (!listContainer) return;

    // 显示加载状态
    const isZh = currentLang === 'zh_CN';
    const loadingText = isZh ? '正在读取历史记录...' : 'Loading history...';
    listContainer.innerHTML = `
        <div class="empty-state">
            <div class="empty-state-icon"><i class="fas fa-clock"></i></div>
            <div class="empty-state-title">${loadingText}</div>
        </div>
    `;

    try {
        const stats = await ensureBrowsingClickRankingStats();

        if (stats.error === 'noHistoryApi') {
            const title = i18n.browsingRankingNotSupportedTitle
                ? i18n.browsingRankingNotSupportedTitle[currentLang]
                : (isZh ? '当前环境不支持历史记录统计' : 'History statistics are not available in this environment');
            const desc = i18n.browsingRankingNotSupportedDesc
                ? i18n.browsingRankingNotSupportedDesc[currentLang]
                : (isZh ? '请确认扩展已获得浏览器的历史记录权限。' : 'Please ensure the extension has permission to access browser history.');

            listContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i class="fas fa-ban"></i></div>
                    <div class="empty-state-title">${title}</div>
                    <div class="empty-state-description">${desc}</div>
                </div>
            `;
            return;
        }

        if (stats.error === 'noBookmarks') {
            const title = i18n.browsingRankingNoBookmarksTitle
                ? i18n.browsingRankingNoBookmarksTitle[currentLang]
                : (isZh ? '暂无书签可统计' : 'No bookmarks to analyze');

            listContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i class="fas fa-bookmark"></i></div>
                    <div class="empty-state-title">${title}</div>
                </div>
            `;
            return;
        }

        let items = getBrowsingRankingItemsForRange(range);

        // 应用二级菜单时间筛选
        if (browsingRankingTimeFilter && items.length > 0) {
            items = filterRankingItemsByTime(items, browsingRankingTimeFilter, stats.boundaries);
        }

        // 根据视图模式渲染
        initBrowsingRankingViewMode();
        if (browsingRankingViewMode === 'folder') {
            await renderBrowsingFolderRankingList(listContainer, items, range, stats);
        } else {
            renderBrowsingClickRankingList(listContainer, items, range);
        }
    } catch (error) {
        console.error('[BrowsingRanking] 加载点击排行失败:', error);
        const fallbackTitle = isZh ? '加载点击排行失败' : 'Failed to load click ranking';
        listContainer.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fas fa-exclamation-circle"></i></div>
                <div class="empty-state-title">${fallbackTitle}</div>
            </div>
        `;
    }
}

function initBrowsingClickRanking() {
    const panel = document.getElementById('browsingRankingPanel');
    if (!panel) return;

    const buttons = panel.querySelectorAll('.ranking-time-filter-btn');
    if (!buttons.length) return;

    const allowedRanges = ['day', 'week', 'month', 'year', 'all'];

    const setActiveRange = (range, shouldPersist = true) => {
        if (!allowedRanges.includes(range)) {
            range = 'month';
        }

        buttons.forEach(btn => {
            if (btn.dataset.range === range) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });

        // 显示时间菜单
        showBrowsingRankingTimeMenu(range);

        loadBrowsingClickRanking(range);

        if (shouldPersist) {
            try {
                localStorage.setItem('browsingRankingActiveRange', range);
            } catch (storageErr) {
                console.warn('[BrowsingRanking] 无法保存筛选范围:', storageErr);
            }
        }
    };

    buttons.forEach(btn => {
        btn.addEventListener('click', () => {
            const range = btn.dataset.range || 'month';
            setActiveRange(range);
        });
    });

    let initialRange = 'day';
    try {
        const saved = localStorage.getItem('browsingRankingActiveRange');
        if (saved && allowedRanges.includes(saved)) {
            initialRange = saved;
        }
    } catch (storageErr) {
        console.warn('[BrowsingRanking] 无法读取筛选范围:', storageErr);
    }

    setActiveRange(initialRange, false);
}

function getActiveBrowsingRankingRange() {
    const panel = document.getElementById('browsingRankingPanel');
    if (!panel) return null;
    const activeBtn = panel.querySelector('.ranking-time-filter-btn.active');
    return activeBtn ? (activeBtn.dataset.range || 'month') : null;
}

async function refreshActiveBrowsingRankingIfVisible() {
    const panel = document.getElementById('browsingRankingPanel');
    if (!panel || !panel.classList.contains('active')) return;

    // ✨ 等待日历数据同步完成（防止显示空白）
    const waitForCalendarData = async () => {
        const start = Date.now();
        const timeout = 2000; // 2秒超时
        while (Date.now() - start < timeout) {
            const inst = window.browsingHistoryCalendarInstance;
            if (inst && inst.bookmarksByDate && inst.bookmarksByDate.size > 0) {
                return true;
            }
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        return false;
    };

    const dataReady = await waitForCalendarData();
    if (!dataReady) {
        console.warn('[BrowsingRanking] 等待日历数据超时');
    }

    const range = getActiveBrowsingRankingRange() || 'month';
    loadBrowsingClickRanking(range);
}

document.addEventListener('browsingHistoryCacheUpdated', () => {
    console.log('[Event] browsingHistoryCacheUpdated 触发，刷新所有浏览记录相关页面');
    browsingClickRankingStats = null;
    refreshActiveBrowsingRankingIfVisible();
    refreshBrowsingRelatedHistory(); // 同时刷新书签关联页面
});

function groupBookmarksByTime(bookmarks, timeFilter) {
    const groups = {};

    bookmarks.forEach(bookmark => {
        const date = new Date(bookmark.dateAdded);
        let groupKey;

        switch (timeFilter) {
            case 'year':
                groupKey = date.getFullYear().toString();
                break;
            case 'month':
                groupKey = currentLang === 'zh_CN'
                    ? `${date.getFullYear()}年${date.getMonth() + 1}月`
                    : `${date.toLocaleDateString('en-US', { year: 'numeric', month: 'long' })}`;
                break;
            case 'day':
            case 'all':
            default:
                groupKey = date.toLocaleDateString(currentLang === 'en' ? 'en-US' : 'zh-CN');
                break;
        }

        if (!groups[groupKey]) {
            groups[groupKey] = [];
        }
        groups[groupKey].push(bookmark);
    });

    return groups;
}

// 保留旧函数用于兼容
function groupBookmarksByDate(bookmarks) {
    return groupBookmarksByTime(bookmarks, 'day');
}

function filterBookmarks(groups) {
    if (currentFilter === 'all') return groups;

    const filtered = {};

    Object.entries(groups).forEach(([date, bookmarks]) => {
        const filteredBookmarks = bookmarks.filter(b => {
            const isBackedUp = isBookmarkBackedUp(b);
            return currentFilter === 'backed-up' ? isBackedUp : !isBackedUp;
        });

        if (filteredBookmarks.length > 0) {
            filtered[date] = filteredBookmarks;
        }
    });

    return filtered;
}

function isBookmarkBackedUp(bookmark) {
    if (!lastBackupTime) return false;
    // 书签添加时间早于或等于最后备份时间，说明已备份
    return bookmark.dateAdded <= lastBackupTime;
}

function renderBookmarkGroups(groups, timeFilter) {
    const sortedDates = Object.keys(groups).sort((a, b) => {
        // 根据timeFilter决定排序方式
        if (timeFilter === 'year') {
            return parseInt(b) - parseInt(a);
        }
        return new Date(b) - new Date(a);
    });

    return sortedDates.map((date, index) => {
        const bookmarks = groups[date];
        const groupId = `group-${index}`;
        // 默认折叠
        const isExpanded = false;

        return `
            <div class="addition-group" data-group-id="${groupId}">
                <div class="addition-group-header" data-group-id="${groupId}">
                    <div class="addition-group-title">
                        <i class="fas fa-chevron-right addition-group-toggle ${isExpanded ? 'expanded' : ''}"></i>
                        <span class="addition-group-date">${date}</span>
                        <span class="addition-count">${bookmarks.length} ${i18n.bookmarks[currentLang]}</span>
                    </div>
                </div>
                <div class="addition-items ${isExpanded ? 'expanded' : ''}" data-group-id="${groupId}">
                    ${bookmarks.map(renderBookmarkItem).join('')}
                </div>
            </div>
        `;
    }).join('');
}

// 绑定折叠/展开事件
function attachAdditionGroupEvents() {
    document.querySelectorAll('.addition-group-header').forEach(header => {
        header.addEventListener('click', (e) => {
            const groupId = header.getAttribute('data-group-id');
            const items = document.querySelector(`.addition-items[data-group-id="${groupId}"]`);
            const toggle = header.querySelector('.addition-group-toggle');

            if (items && toggle) {
                items.classList.toggle('expanded');
                toggle.classList.toggle('expanded');
            }
        });
    });
}

function renderBookmarkItem(bookmark) {
    const isBackedUp = isBookmarkBackedUp(bookmark);
    const favicon = getFaviconUrl(bookmark.url);

    return `
        <div class="addition-item" data-bookmark-url="${escapeHtml(bookmark.url)}">
            <img class="addition-icon" src="${favicon}" alt="">
            <div class="addition-info">
                <a href="${escapeHtml(bookmark.url)}" target="_blank" class="addition-title" rel="noopener noreferrer">${escapeHtml(bookmark.title)}</a>
                <div class="addition-url">${escapeHtml(bookmark.url)}</div>
            </div>
            <span class="addition-status ${isBackedUp ? 'backed-up' : 'not-backed-up'}">
                ${isBackedUp ? i18n.backedUp[currentLang] : i18n.notBackedUp[currentLang]}
            </span>
        </div>
    `;
}

// =============================================================================
// 书签树视图
// =============================================================================

let treeChangeMap = null; // 缓存变动映射
let cachedTreeData = null; // 缓存树数据
let cachedOldTree = null; // 缓存旧树数据
let cachedCurrentTree = null; // 缓存当前树数据（用于智能路径检测）
let lastTreeFingerprint = null; // 上次树的指纹
let lastTreeSnapshotVersion = null; // 上次快照版本（来自 background 缓存）
let cachedCurrentTreeIndex = null; // id -> node（懒加载用，按需构建）

// Canvas 永久栏目树：懒加载配置（避免首次进入构建海量 DOM）
const CANVAS_PERMANENT_TREE_LAZY_ENABLED = true;
const CANVAS_PERMANENT_TREE_CHILD_BATCH = 200;

// Canvas 懒加载模式下的“变化提示缓存”（仅四类：新增/删除/修改/移动）
const CANVAS_LAZY_CHANGE_HINT_TTL_MS = 5 * 60 * 1000;
let canvasLazyChangeHints = {
    updatedAt: 0,
    added: new Set(),
    modified: new Set(),
    moved: new Set(),
    movedInfo: new Map(), // key -> { oldPath }
    deletedCount: 0,
    hasAny: false
};
let canvasLazyChangeHintsPromise = null;

// 清除树缓存（供拖拽模块调用，防止缓存覆盖DOM更新）
function clearTreeCache() {
    cachedTreeData = null;
    lastTreeFingerprint = null;
    lastTreeSnapshotVersion = null;
    cachedCurrentTreeIndex = null;
    console.log('[树缓存] 已清除');
}
window.clearTreeCache = clearTreeCache;

function clearCanvasLazyChangeHints(reason = '') {
    canvasLazyChangeHints = {
        updatedAt: 0,
        added: new Set(),
        modified: new Set(),
        moved: new Set(),
        movedInfo: new Map(),
        deletedCount: 0,
        hasAny: false
    };
    if (reason) console.log('[Canvas变化提示] 已清空:', reason);
}

function buildFingerprintKeyFromChangeItem(item) {
    if (!item) return '';
    const path = typeof item.path === 'string' ? item.path : '';
    const title = typeof item.title === 'string' ? item.title : '';
    const url = typeof item.url === 'string' ? item.url : '';
    return `B:${path}|${title}|${url}`;
}

function getFolderPathFromBreadcrumb(bc) {
    if (!bc) return '';
    const parts = bc.split(' > ').map(s => s.trim()).filter(Boolean);
    const rootTitle = cachedCurrentTree && cachedCurrentTree[0] ? cachedCurrentTree[0].title : '';
    if (rootTitle && parts[0] === rootTitle) parts.shift();
    if (parts.length <= 1) return '';
    parts.pop(); // 移除当前节点名
    return parts.join('/');
}

function buildFingerprintKeyForBookmarkNode(node) {
    if (!node || !node.url) return '';
    const bc = cachedCurrentTree ? getNamedPathFromTree(cachedCurrentTree, node.id) : '';
    const folderPath = getFolderPathFromBreadcrumb(bc);
    return `B:${folderPath}|${node.title || ''}|${node.url || ''}`;
}

function formatFingerprintPathToSlash(path) {
    if (typeof path !== 'string' || !path.length) return '/';
    return path.startsWith('/') ? path : `/${path}`;
}

async function ensureCanvasLazyChangeHints(forceRefresh = false) {
    if (!(currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED)) return null;
    const now = Date.now();
    if (!forceRefresh && canvasLazyChangeHints.updatedAt && (now - canvasLazyChangeHints.updatedAt) < CANVAS_LAZY_CHANGE_HINT_TTL_MS) {
        return canvasLazyChangeHints;
    }
    if (canvasLazyChangeHintsPromise) return canvasLazyChangeHintsPromise;

    canvasLazyChangeHintsPromise = (async () => {
        try {
            let changeData = await getDetailedChanges(forceRefresh);
            if (!forceRefresh && (!changeData || !changeData.hasChanges)) {
                changeData = await getDetailedChanges(true);
            }
            const added = new Set();
            const modified = new Set();
            const moved = new Set();
            const movedInfo = new Map();
            let deletedCount = 0;

            const stats = changeData && changeData.stats ? changeData.stats : null;
            const statsHasAny = !!(stats && (
                stats.bookmarkDiff || stats.folderDiff ||
                stats.bookmarkMoved || stats.folderMoved ||
                stats.bookmarkModified || stats.folderModified
            ));

            if (changeData && (changeData.hasChanges || statsHasAny)) {
                if (Array.isArray(changeData.added)) {
                    changeData.added.forEach(item => {
                        const key = buildFingerprintKeyFromChangeItem(item);
                        if (key) added.add(key);
                    });
                }
                if (Array.isArray(changeData.modified)) {
                    changeData.modified.forEach(item => {
                        const key = buildFingerprintKeyFromChangeItem(item);
                        if (key) modified.add(key);
                    });
                }
                if (Array.isArray(changeData.moved)) {
                    changeData.moved.forEach(item => {
                        const key = buildFingerprintKeyFromChangeItem(item);
                        if (key) {
                            moved.add(key);
                            if (item.oldPath) movedInfo.set(key, { oldPath: item.oldPath });
                        }
                    });
                }
                if (Array.isArray(changeData.deleted)) {
                    deletedCount = changeData.deleted.length;
                }
            }

            canvasLazyChangeHints = {
                updatedAt: Date.now(),
                added,
                modified,
                moved,
                movedInfo,
                deletedCount,
                hasAny: added.size > 0 || modified.size > 0 || moved.size > 0 || deletedCount > 0 || statsHasAny
            };
            return canvasLazyChangeHints;
        } catch (e) {
            console.warn('[Canvas变化提示] 生成失败，回退为空:', e);
            canvasLazyChangeHints = {
                updatedAt: Date.now(),
                added: new Set(),
                modified: new Set(),
                moved: new Set(),
                movedInfo: new Map(),
                deletedCount: 0,
                hasAny: false
            };
            return canvasLazyChangeHints;
        } finally {
            canvasLazyChangeHintsPromise = null;
        }
    })();

    return canvasLazyChangeHintsPromise;
}

function getCanvasLazyHintForBookmark(node) {
    if (!node || !node.url) return null;
    if (!(currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED)) return null;
    if (!canvasLazyChangeHints || !canvasLazyChangeHints.hasAny) return null;
    const key = buildFingerprintKeyForBookmarkNode(node);
    if (!key) return null;
    if (canvasLazyChangeHints.added.has(key)) return { type: 'added' };
    if (canvasLazyChangeHints.modified.has(key)) return { type: 'modified' };
    if (canvasLazyChangeHints.moved.has(key)) {
        const info = canvasLazyChangeHints.movedInfo.get(key) || {};
        return { type: 'moved', oldPath: info.oldPath || '' };
    }
    return null;
}

function ensureCanvasLazyLegend(treeContainer) {
    if (!(currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED)) return;
    const container = treeContainer || document.getElementById('bookmarkTree');
    if (!container) return;
    const existing = container.querySelector('.tree-legend');
    if (!canvasLazyChangeHints || !canvasLazyChangeHints.hasAny) {
        if (existing) existing.remove();
        return;
    }
    if (existing) return;
    const legend = document.createElement('div');
    legend.className = 'tree-legend';
    legend.innerHTML = `
        <span class="legend-item"><span class="legend-dot added"></span> ${currentLang === 'zh_CN' ? '新增' : 'Added'}</span>
        <span class="legend-item"><span class="legend-dot deleted"></span> ${currentLang === 'zh_CN' ? '删除' : 'Deleted'}</span>
        <span class="legend-item"><span class="legend-dot moved"></span> ${currentLang === 'zh_CN' ? '移动' : 'Moved'}</span>
        <span class="legend-item"><span class="legend-dot modified"></span> ${currentLang === 'zh_CN' ? '修改' : 'Modified'}</span>
    `;
    container.insertBefore(legend, container.firstChild);
}

// 生成书签树指纹（快速哈希）
function getTreeFingerprint(tree) {
    if (!tree || !tree[0]) return '';

    // 只提取关键信息生成指纹
    const extractKey = (node) => {
        const key = {
            i: node.id,
            t: node.title,
            u: node.url,
            p: node.parentId,
            x: node.index
        };
        if (node.children) {
            key.c = node.children.map(extractKey);
        }
        return key;
    };

    return JSON.stringify(extractKey(tree[0]));
}

// 从 background.js 获取书签树快照（优先走缓存，失败再直连 getTree）
async function getBookmarkTreeSnapshot() {
    try {
        if (browserAPI && browserAPI.runtime && typeof browserAPI.runtime.sendMessage === 'function') {
            const resp = await browserAPI.runtime.sendMessage({ action: 'getBookmarkSnapshot' });
            if (resp && resp.success && Array.isArray(resp.tree)) {
                return { tree: resp.tree, version: resp.version ?? null };
            }
        }
    } catch (e) {
        console.warn('[TreeSnapshot] 获取后台快照失败，回退直连:', e);
    }
    const tree = await new Promise(resolve => browserAPI.bookmarks.getTree(resolve));
    return { tree, version: null };
}

// Canvas 永久栏目懒加载：需要依赖 cachedCurrentTree 来按需加载 folder children。
// 若只做 DOM 增量更新但不刷新 cachedCurrentTree，则在“展开/加载更多”时可能被旧快照覆盖，
// 造成“刷新/展开后移动效果消失 / 节点跑回去”的错觉。
let pendingTreeSnapshotRefreshTimer = null;
let treeSnapshotRefreshing = false;
let treeSnapshotRefreshQueued = false;

async function refreshCachedCurrentTreeSnapshot(reason = '') {
    // 只在 Canvas 懒加载模式下需要刷新该快照（tree/canvas 全量渲染会自然更新）
    if (!(currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED)) return;
    if (treeSnapshotRefreshing) {
        treeSnapshotRefreshQueued = true;
        return;
    }
    treeSnapshotRefreshing = true;
    try {
        const snapshot = await getBookmarkTreeSnapshot();
        if (snapshot && Array.isArray(snapshot.tree)) {
            cachedCurrentTree = snapshot.tree;
            cachedCurrentTreeIndex = null;
            if (typeof snapshot.version !== 'undefined') {
                lastTreeSnapshotVersion = snapshot.version;
            }
            console.log('[TreeSnapshot] 已刷新 cachedCurrentTree（Canvas懒加载）', reason || '');
        }
    } catch (e) {
        console.warn('[TreeSnapshot] 刷新 cachedCurrentTree 失败:', e);
    } finally {
        treeSnapshotRefreshing = false;
        if (treeSnapshotRefreshQueued) {
            treeSnapshotRefreshQueued = false;
            refreshCachedCurrentTreeSnapshot('queued').catch(() => { });
        }
    }
}

function scheduleCachedCurrentTreeSnapshotRefresh(reason = '') {
    if (!(currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED)) return;
    if (pendingTreeSnapshotRefreshTimer) clearTimeout(pendingTreeSnapshotRefreshTimer);
    pendingTreeSnapshotRefreshTimer = setTimeout(() => {
        pendingTreeSnapshotRefreshTimer = null;
        refreshCachedCurrentTreeSnapshot(reason).catch(() => { });
    }, 300);
}

function applyIncrementalMoveToCachedCurrentTree(id, moveInfo) {
    try {
        if (!(currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED)) return;
        if (!id || !moveInfo || typeof moveInfo.parentId === 'undefined' || typeof moveInfo.oldParentId === 'undefined') return;
        if (!cachedCurrentTree || !cachedCurrentTree[0]) return;

        const index = getCachedCurrentTreeIndex();
        if (!index) return;

        const keyId = String(id);
        const movedNode = index.get(keyId);
        const oldParent = index.get(String(moveInfo.oldParentId));
        const newParent = index.get(String(moveInfo.parentId));
        if (!movedNode || !oldParent || !newParent) return;

        const oldChildren = Array.isArray(oldParent.children) ? oldParent.children : [];
        oldParent.children = oldChildren.filter(child => String(child?.id) !== keyId);

        const newChildren = Array.isArray(newParent.children) ? newParent.children : [];
        const filteredNew = newChildren.filter(child => String(child?.id) !== keyId);
        const insertIndex = (typeof moveInfo.index === 'number')
            ? Math.max(0, Math.min(moveInfo.index, filteredNew.length))
            : filteredNew.length;
        filteredNew.splice(insertIndex, 0, movedNode);
        newParent.children = filteredNew;

        // 更新节点自身的父信息（供路径/懒加载逻辑使用）
        movedNode.parentId = String(moveInfo.parentId);
        if (typeof moveInfo.index === 'number') movedNode.index = moveInfo.index;
    } catch (_) {
        // 静默失败：最终会由 refreshCachedCurrentTreeSnapshot() 兜底
    }
}

function getCachedCurrentTreeIndex() {
    if (cachedCurrentTreeIndex) return cachedCurrentTreeIndex;
    if (!cachedCurrentTree || !cachedCurrentTree[0]) return null;
    const map = new Map();
    const stack = [cachedCurrentTree[0]];
    while (stack.length) {
        const node = stack.pop();
        if (!node || !node.id) continue;
        map.set(String(node.id), node);
        if (Array.isArray(node.children) && node.children.length) {
            for (let i = node.children.length - 1; i >= 0; i--) {
                stack.push(node.children[i]);
            }
        }
    }
    cachedCurrentTreeIndex = map;
    return cachedCurrentTreeIndex;
}

function loadPermanentFolderChildrenLazy(parentId, childrenContainer, startIndex = 0, triggerBtn = null) {
    try {
        if (!parentId || !childrenContainer) return;
        const index = getCachedCurrentTreeIndex();
        const parent = index ? index.get(String(parentId)) : null;
        if (!parent || !Array.isArray(parent.children) || parent.children.length === 0) {
            const item = document.querySelector(`.tree-item[data-node-id="${CSS.escape(String(parentId))}"]`);
            if (item) {
                item.dataset.childrenLoaded = 'true';
                item.dataset.hasChildren = 'false';
            }
            if (triggerBtn) {
                try { triggerBtn.remove(); } catch (_) { }
            }
            return;
        }

        const item = document.querySelector(`.tree-item[data-node-id="${CSS.escape(String(parentId))}"]`);
        const level = item ? (parseInt(item.dataset.nodeLevel, 10) || 0) : 0;
        const nextLevel = level + 1;

        const slice = parent.children.slice(startIndex, startIndex + CANVAS_PERMANENT_TREE_CHILD_BATCH);
        const visited = new Set([String(parentId)]);
        const html = slice.map(child => renderTreeNodeWithChanges(child, nextLevel, 50, visited)).join('');

        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;

        const frag = document.createDocumentFragment();
        while (tempDiv.firstChild) {
            frag.appendChild(tempDiv.firstChild);
        }

        if (startIndex === 0 && !triggerBtn) {
            childrenContainer.innerHTML = '';
        }

        // 插入到“加载更多”按钮之前（若存在）
        if (triggerBtn && triggerBtn.parentElement === childrenContainer) {
            childrenContainer.insertBefore(frag, triggerBtn);
        } else {
            childrenContainer.appendChild(frag);
        }

        if (item) {
            item.dataset.childrenLoaded = 'true';
            item.dataset.hasChildren = 'true';
        }

        const nextStart = startIndex + slice.length;
        const remaining = parent.children.length - nextStart;

        let loadMoreBtn = triggerBtn;
        if (remaining > 0) {
            if (!loadMoreBtn) {
                loadMoreBtn = document.createElement('button');
                loadMoreBtn.type = 'button';
                loadMoreBtn.className = 'tree-load-more';
                childrenContainer.appendChild(loadMoreBtn);
            }
            loadMoreBtn.dataset.parentId = String(parentId);
            loadMoreBtn.dataset.startIndex = String(nextStart);
            loadMoreBtn.textContent = currentLang === 'zh_CN'
                ? `加载更多（剩余 ${remaining} 项）`
                : `Load more (${remaining} remaining)`;
        } else if (loadMoreBtn) {
            try { loadMoreBtn.remove(); } catch (_) { }
        }

        // 懒加载插入新节点后：补绑定拖拽事件（内部拖拽排序/移动）
        try {
            // 仅对“刚插入的子树”补绑，避免每次懒加载都扫描整棵书签树
            if (typeof attachDragEvents === 'function') {
                attachDragEvents(childrenContainer);
            }
        } catch (_) { }

        // 懒加载完成后：检查新加载的子节点是否有需要恢复展开状态的
        try {
            const savedState = localStorage.getItem('treeExpandedNodeIds');
            if (savedState) {
                const expandedIds = JSON.parse(savedState);
                if (Array.isArray(expandedIds) && expandedIds.length > 0) {
                    const expandedSet = new Set(expandedIds);
                    // 只检查刚加载的子节点
                    childrenContainer.querySelectorAll(':scope > .tree-node > .tree-item[data-node-id]').forEach(item => {
                        if (expandedSet.has(item.dataset.nodeId)) {
                            const node = item.closest('.tree-node');
                            if (!node) return;
                            const children = node.querySelector(':scope > .tree-children');
                            const toggle = item.querySelector('.tree-toggle');
                            const icon = item.querySelector('.tree-icon.fas');
                            if (children && toggle) {
                                children.classList.add('expanded');
                                toggle.classList.add('expanded');
                                if (icon && icon.classList.contains('fa-folder')) {
                                    icon.classList.remove('fa-folder');
                                    icon.classList.add('fa-folder-open');
                                }
                                // 如果这个节点也需要懒加载，递归加载
                                if (item.dataset.childrenLoaded === 'false' && item.dataset.hasChildren === 'true') {
                                    setTimeout(() => {
                                        loadPermanentFolderChildrenLazy(item.dataset.nodeId, children, 0, null);
                                    }, 10);
                                }
                            }
                        }
                    });
                }
            }
        } catch (_) { }
    } catch (e) {
        console.warn('[Canvas Tree Lazy] load children failed:', e);
    }
}
// 导出到全局，供拖拽模块在悬浮展开时调用
window.loadPermanentFolderChildrenLazy = loadPermanentFolderChildrenLazy;


// 计算节点在指定树中的“索引地址路径”（示例：/1/2/3），从根的第一层开始使用 1 基索引
function getIndexAddressPathFromTree(tree, targetId) {
    try {
        if (!tree || !tree[0]) return '';
        // 构建 id -> node 快速索引
        const map = new Map();
        (function build(n) {
            if (!n) return;
            map.set(n.id, n);
            if (n.children) n.children.forEach(build);
        })(tree[0]);

        const target = map.get(targetId);
        if (!target) return '';
        const segments = [];
        let cur = target;
        // 将当前节点的 index+1 放入，逐层向上直到父为 '0' 或无父
        while (cur && typeof cur.index === 'number') {
            segments.push(cur.index + 1);
            const pid = cur.parentId;
            if (!pid || pid === '0') break;
            cur = map.get(pid);
        }
        // 如果父为 '0'，还需要把顶层容器自身的 index+1 也包含（cur 即顶层容器）
        if (cur && typeof cur.parentId !== 'undefined' && cur.parentId === '0' && typeof cur.index === 'number') {
            // 已经在循环中加入了 cur 的 index+1（作为上一轮child），此处不重复
        }
        return segments.length ? ('/' + segments.reverse().join('/')) : '';
    } catch (_) {
        return '';
    }
}

// 计算“旧位置”的索引地址路径：优先从 cachedOldTree 获取；失败返回空串
function getOldIndexAddressForNode(nodeId) {
    if (!nodeId) return '';
    try {
        if (cachedOldTree && cachedOldTree[0]) {
            return getIndexAddressPathFromTree(cachedOldTree, nodeId);
        }
    } catch (_) { }
    return '';
}

// ============ 名称路径（按文件夹名称，不含数字） ============
function getNamedPathFromTree(tree, targetId) {
    try {
        if (!tree || !tree[0]) return '';
        const path = [];
        const dfs = (node, cur) => {
            if (!node) return false;
            if (node.id === String(targetId)) { path.push(...cur, node.title); return true; }
            if (node.children) {
                for (const c of node.children) {
                    if (dfs(c, [...cur, node.title])) return true;
                }
            }
            return false;
        };
        dfs(tree[0], []);
        return path.join(' > ');
    } catch (_) { return ''; }
}

function breadcrumbToSlashFolders(bc) {
    if (!bc) return '';
    const parts = bc.split(' > ').map(s => s.trim()).filter(Boolean);
    if (parts.length === 0) return '';
    // 只取文件夹路径：去掉最后一级（当前节点名）
    if (parts.length > 1) parts.pop(); else return '/';
    return '/' + parts.join('/');
}

function breadcrumbToSlashFull(bc) {
    if (!bc) return '/';
    const parts = bc.split(' > ').map(s => s.trim()).filter(Boolean);
    return parts.length ? ('/' + parts.join('/')) : '/';
}

// 将 "/A/B/C" 转为带矩形片段的 HTML（用于 move tooltip）
function slashPathToChipsHTML(slashPath) {
    try {
        if (!slashPath || typeof slashPath !== 'string') return '<span class="breadcrumb-item">/</span>';
        const parts = slashPath.split('/').filter(Boolean);
        if (parts.length === 0) return '<span class="breadcrumb-item">/</span>';
        const chips = parts.map((p, i) => {
            const safe = escapeHtml(p);
            return `<span class="breadcrumb-item">${safe}</span>`;
        });
        const sep = '<span class="breadcrumb-separator">/</span>';
        return chips.join(sep);
    } catch (_) {
        return '<span class="breadcrumb-item">/</span>';
    }
}

// 基于“旧父ID + 旧index”从当前树推导旧地址（避免必须完整旧树）
function getOldAddressFromParentAndIndex(oldParentId, oldIndex) {
    try {
        if (typeof oldParentId === 'undefined' || oldParentId === null) return '';
        const base = (cachedCurrentTree && cachedCurrentTree[0]) ? cachedCurrentTree : (cachedOldTree && cachedOldTree[0] ? cachedOldTree : null);
        if (!base) return '';
        const parentPath = getIndexAddressPathFromTree(base, String(oldParentId));
        if (!parentPath) return '';
        const childSeg = (typeof oldIndex === 'number') ? ('/' + (oldIndex + 1)) : '';
        return parentPath + childSeg;
    } catch (_) { return ''; }
}

// 防止并发渲染和闪烁的标志
let isRenderingTree = false;
let pendingRenderRequest = null;

// 同步版本的树渲染（真正可 await，用于 Current Changes 预览）
async function renderTreeViewSync() {
    console.log('[renderTreeViewSync] 开始同步渲染...');

    const treeContainer = document.getElementById('bookmarkTree');
    if (!treeContainer) {
        console.error('[renderTreeViewSync] 容器元素未找到');
        return;
    }

    // 清除缓存，确保重新渲染
    cachedTreeData = null;
    lastTreeFingerprint = null;
    lastTreeSnapshotVersion = null;
    cachedCurrentTreeIndex = null;

    try {
        // 并行获取数据
        const [snapshot, storageData] = await Promise.all([
            getBookmarkTreeSnapshot(),
            new Promise(resolve => browserAPI.storage.local.get(['lastBookmarkData'], resolve))
        ]);
        const currentTree = snapshot ? snapshot.tree : null;
        lastTreeSnapshotVersion = snapshot ? snapshot.version : null;

        if (!currentTree || currentTree.length === 0) {
            treeContainer.innerHTML = `<div class="empty-state"><div class="empty-state-icon"><i class="fas fa-sitemap"></i></div><div class="empty-state-title">${i18n.emptyTree[currentLang]}</div></div>`;
            return;
        }

        const oldTree = storageData.lastBookmarkData && storageData.lastBookmarkData.bookmarkTree;
        cachedOldTree = oldTree;
        cachedCurrentTree = currentTree;
        cachedCurrentTreeIndex = null;

        // 检测变动
        if (oldTree && oldTree[0]) {
            treeChangeMap = await detectTreeChangesFast(oldTree, currentTree);
            console.log('[renderTreeViewSync] 检测到变动数量:', treeChangeMap.size);
        } else {
            treeChangeMap = new Map();
        }

        // 合并旧树和新树，显示删除的节点
        let treeToRender = currentTree;
        if (oldTree && oldTree[0] && treeChangeMap && treeChangeMap.size > 0) {
            let hasDeletedNodes = false;
            for (const [, change] of treeChangeMap) {
                if (change.type === 'deleted') {
                    hasDeletedNodes = true;
                    break;
                }
            }
            if (hasDeletedNodes) {
                try {
                    treeToRender = rebuildTreeWithDeleted(oldTree, currentTree, treeChangeMap);
                } catch (error) {
                    console.error('[renderTreeViewSync] 重建树时出错:', error);
                    treeToRender = currentTree;
                }
            }
        }

        // 渲染树
        const fragment = document.createDocumentFragment();

        if (treeChangeMap.size > 0) {
            const legend = document.createElement('div');
            legend.className = 'tree-legend';
            legend.innerHTML = `
                <span class="legend-item"><span class="legend-dot added"></span> ${currentLang === 'zh_CN' ? '新增' : 'Added'}</span>
                <span class="legend-item"><span class="legend-dot deleted"></span> ${currentLang === 'zh_CN' ? '删除' : 'Deleted'}</span>
                <span class="legend-item"><span class="legend-dot modified"></span> ${currentLang === 'zh_CN' ? '修改' : 'Modified'}</span>
                <span class="legend-item"><span class="legend-dot moved"></span> ${currentLang === 'zh_CN' ? '移动' : 'Moved'}</span>
            `;
            fragment.appendChild(legend);
        }

        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = renderTreeNodeWithChanges(treeToRender[0], 0);
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        treeContainer.innerHTML = '';
        treeContainer.appendChild(fragment);
        treeContainer.style.display = 'block';

        // 绑定事件
        attachTreeEvents(treeContainer);

        console.log('[renderTreeViewSync] 渲染完成');

    } catch (error) {
        console.error('[renderTreeViewSync] 渲染失败:', error);
        treeContainer.innerHTML = `<div class="error">${currentLang === 'zh_CN' ? '加载失败' : 'Failed to load'}</div>`;
    }
}

async function renderTreeView(forceRefresh = false) {
    console.log('[renderTreeView] 开始渲染, forceRefresh:', forceRefresh);

    // 如果正在渲染中，合并请求，避免重复渲染导致闪烁
    if (isRenderingTree) {
        console.log('[renderTreeView] 已有渲染进行中，合并请求');
        pendingRenderRequest = forceRefresh;
        return;
    }

    isRenderingTree = true;

    // 记录永久栏目滚动位置，渲染后恢复
    // 优先使用当前滚动位置；如果是0，尝试从 localStorage 读取持久化的值（页面刷新场景）
    const permBody = document.querySelector('.permanent-section-body');
    let permScrollTop = permBody ? permBody.scrollTop : null;
    let permScrollLeft = permBody ? permBody.scrollLeft : 0;

    // 避免“渲染后多次恢复滚动”与用户滚动产生抢夺：一旦检测到用户开始滚动，短时间内停止自动恢复
    const isScrollRestoreBlocked = () => {
        if (!permBody) return false;
        try {
            const until = parseInt(permBody.dataset.scrollRestoreBlockUntil || '0', 10) || 0;
            return until && Date.now() < until;
        } catch (_) {
            return false;
        }
    };
    if (permBody && permBody.dataset.scrollRestoreGuardAttached !== 'true') {
        permBody.dataset.scrollRestoreGuardAttached = 'true';
        const blockMs = 1000;
        const block = () => {
            try {
                permBody.dataset.scrollRestoreBlockUntil = String(Date.now() + blockMs);
            } catch (_) { }
        };
        permBody.addEventListener('wheel', block, { passive: true });
        permBody.addEventListener('touchstart', block, { passive: true });
        permBody.addEventListener('touchmove', block, { passive: true });
        // 仅当直接在滚动容器上按下（如拖动滚动条/空白区域）才算用户滚动意图，避免点击树节点误触发
        permBody.addEventListener('pointerdown', (e) => {
            if (e && e.target === permBody) block();
        }, { passive: true });
    }

    // 页面刷新后，permScrollTop 是 0，需要从 localStorage 恢复
    if (permScrollTop === 0 && currentView === 'canvas') {
        try {
            const persisted = JSON.parse(localStorage.getItem('permanent-section-scroll'));
            if (persisted && typeof persisted.top === 'number') {
                permScrollTop = persisted.top;
                permScrollLeft = persisted.left || 0;
            }
        } catch (_) { }
    }

    const treeContainer = document.getElementById('bookmarkTree');

    if (!treeContainer) {
        console.error('[renderTreeView] 容器元素未找到');
        isRenderingTree = false;
        return;
    }

    // 强制刷新时清除缓存，确保重新渲染
    if (forceRefresh) {
        cachedTreeData = null;
        lastTreeFingerprint = null;
        lastTreeSnapshotVersion = null;
        cachedCurrentTreeIndex = null;
        console.log('[renderTreeView] 强制刷新，已清除缓存');
    }

    // 如果已有缓存且不强制刷新，直接使用（快速路径）
    if (!forceRefresh && cachedTreeData && cachedTreeData.treeFragment) {
        console.log('[renderTreeView] 使用现有缓存（快速显示）');
        if (currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED) {
            await ensureCanvasLazyChangeHints(false);
        }
        // Canvas 视图下尽量避免整树替换，减少“重新加载感”
        if (currentView === 'canvas' && treeContainer.children.length) {
            treeContainer.style.display = 'block';
            ensureCanvasLazyLegend(treeContainer);
        } else {
            treeContainer.innerHTML = '';
            treeContainer.appendChild(cachedTreeData.treeFragment.cloneNode(true));
            treeContainer.style.display = 'block';
            ensureCanvasLazyLegend(treeContainer);
        }

        // 重新绑定事件
        attachTreeEvents(treeContainer);

        console.log('[renderTreeView] 缓存显示完成');
        // 恢复滚动位置（延迟确保展开状态恢复后再恢复滚动位置）
        if (permBody && permScrollTop !== null) {
            const restoreScroll = () => {
                if (isScrollRestoreBlocked()) return;
                permBody.scrollTop = permScrollTop;
                permBody.scrollLeft = permScrollLeft;
            };
            restoreScroll();
            requestAnimationFrame(() => {
                restoreScroll();
                setTimeout(restoreScroll, 50);
                setTimeout(restoreScroll, 150);
                setTimeout(restoreScroll, 300);
                setTimeout(restoreScroll, 500);
            });
        }

        // 【关键修复】即使使用缓存，也要预热内存缓存
        // 因为内存缓存可能在页面刷新后被清空，导致图标显示为五角星
        // 预热完成后会自动更新页面上的图标
        (async () => {
            try {
                if (currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED) {
                    // Canvas 永久栏目首屏多为文件夹，不需要全量预热 favicon（会导致首次进入卡顿）
                    return;
                }
                // 获取当前书签树（优先后台快照）
                const snapshot = await getBookmarkTreeSnapshot();
                const currentTree = snapshot ? snapshot.tree : null;
                if (currentTree && currentTree.length > 0) {
                    // 收集所有书签URL
                    const allBookmarkUrls = [];
                    const collectUrls = (nodes) => {
                        if (!nodes) return;
                        nodes.forEach(node => {
                            if (node.url) allBookmarkUrls.push(node.url);
                            if (node.children) collectUrls(node.children);
                        });
                    };
                    collectUrls(currentTree);

                    if (allBookmarkUrls.length > 0) {
                        await warmupFaviconCache(allBookmarkUrls);

                        // 预热完成后，更新页面上所有使用fallback图标的img标签
                        allBookmarkUrls.forEach(url => {
                            try {
                                const urlObj = new URL(url);
                                const domain = urlObj.hostname;
                                const cachedFavicon = FaviconCache.memoryCache.get(domain);
                                if (cachedFavicon && cachedFavicon !== fallbackIcon) {
                                    updateFaviconImages(url, cachedFavicon);
                                }
                            } catch (e) {
                                // 忽略无效URL
                            }
                        });

                        console.log('[renderTreeView] 快速路径预热完成，已更新图标');
                    }
                }
            } catch (e) {
                console.warn('[renderTreeView] 快速路径预热失败:', e);
            }
        })();

        // 重置渲染标志并处理合并请求
        isRenderingTree = false;
        if (pendingRenderRequest !== null) {
            const pending = pendingRenderRequest;
            pendingRenderRequest = null;
            console.log('[renderTreeView] 处理待处理的渲染请求（快速路径）');
            renderTreeView(pending);
        }
        return;
    }

    // 没有缓存，开始加载数据
    // 注意：不清空容器，保持原有内容，避免闪烁和滚动位置丢失
    // 只有在容器为空时才显示加载状态
    console.log('[renderTreeView] 无缓存，开始加载数据');
    if (!treeContainer.children.length || treeContainer.querySelector('.loading') || treeContainer.querySelector('.empty-state') || treeContainer.querySelector('.error')) {
        treeContainer.innerHTML = `<div class="loading">${i18n.loading[currentLang]}</div>`;
    }
    treeContainer.style.display = 'block';

    // 获取数据并行处理
    Promise.all([
        getBookmarkTreeSnapshot(),
        new Promise(resolve => browserAPI.storage.local.get(['lastBookmarkData'], resolve))
    ]).then(async ([snapshot, storageData]) => {
        const currentTree = snapshot ? snapshot.tree : null;
        const snapshotVersion = snapshot ? snapshot.version : null;
        if (!currentTree || currentTree.length === 0) {
            treeContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i class="fas fa-sitemap"></i></div>
                    <div class="empty-state-title">${i18n.emptyTree[currentLang]}</div>
                </div>
            `;
            isRenderingTree = false;
            if (pendingRenderRequest !== null) {
                const pending = pendingRenderRequest;
                pendingRenderRequest = null;
                renderTreeView(pending);
            }
            return;
        }

        // 版本快路径：优先使用 background 快照版本，避免对整棵树做 JSON 指纹（非常耗时）
        const canUseVersion = snapshotVersion !== null && typeof snapshotVersion !== 'undefined';
        const currentFingerprint = canUseVersion ? null : getTreeFingerprint(currentTree);

        // 如果版本/指纹相同，直接使用缓存（树没有变化）
        if (cachedTreeData && ((canUseVersion && snapshotVersion === lastTreeSnapshotVersion) || (!canUseVersion && currentFingerprint === lastTreeFingerprint))) {
            console.log('[renderTreeView] 使用缓存（书签未变化）');

            // Canvas 视图下，如果已有 DOM，避免整树替换造成"重新加载感"
            if (currentView === 'canvas' && treeContainer.children.length) {
                cachedCurrentTree = currentTree;
                cachedCurrentTreeIndex = null;
                if (currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED) {
                    await ensureCanvasLazyChangeHints(false);
                    ensureCanvasLazyLegend(treeContainer);
                }
                // 恢复滚动位置
                if (permBody && permScrollTop !== null && !isScrollRestoreBlocked()) {
                    permBody.scrollTop = permScrollTop;
                    permBody.scrollLeft = permScrollLeft;
                }
                isRenderingTree = false;
                if (pendingRenderRequest !== null) {
                    const pending = pendingRenderRequest;
                    pendingRenderRequest = null;
                    console.log('[renderTreeView] 处理待处理的渲染请求（Canvas无变化）');
                    renderTreeView(pending);
                }
                return;
            }

            treeContainer.innerHTML = '';
            treeContainer.appendChild(cachedTreeData.treeFragment.cloneNode(true));
            treeContainer.style.display = 'block';
            if (currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED) {
                await ensureCanvasLazyChangeHints(false);
                ensureCanvasLazyLegend(treeContainer);
            }

            // 重新绑定事件
            attachTreeEvents(treeContainer);
            // 恢复滚动位置（延迟确保展开状态恢复后再恢复滚动位置）
            if (permBody && permScrollTop !== null) {
                const restoreScroll = () => {
                    if (isScrollRestoreBlocked()) return;
                    permBody.scrollTop = permScrollTop;
                    permBody.scrollLeft = permScrollLeft;
                };
                restoreScroll();
                requestAnimationFrame(() => {
                    restoreScroll();
                    setTimeout(restoreScroll, 50);
                    setTimeout(restoreScroll, 150);
                    setTimeout(restoreScroll, 300);
                    setTimeout(restoreScroll, 500);
                });
            }

            // 重置渲染标志并处理合并请求
            isRenderingTree = false;
            if (pendingRenderRequest !== null) {
                const pending = pendingRenderRequest;
                pendingRenderRequest = null;
                console.log('[renderTreeView] 处理待处理的渲染请求（指纹一致）');
                renderTreeView(pending);
            }
            return;
        }

        // 树有变化，重新渲染
        console.log('[renderTreeView] 检测到书签变化，重新渲染');

        const oldTree = storageData.lastBookmarkData && storageData.lastBookmarkData.bookmarkTree;
        cachedOldTree = oldTree;
        cachedCurrentTree = currentTree; // 缓存当前树，用于智能路径检测
        cachedCurrentTreeIndex = null;

        // 【关键修复】预热 favicon 缓存 - 从 IndexedDB 批量加载到内存
        // Canvas 永久栏目采用懒加载时，避免首次进入遍历整棵树做预热（代价很高）
        if (!(currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED)) {
            // 收集所有书签URL
            const allBookmarkUrls = [];
            const collectUrls = (nodes) => {
                if (!nodes) return;
                nodes.forEach(node => {
                    if (node.url) {
                        allBookmarkUrls.push(node.url);
                    }
                    if (node.children) {
                        collectUrls(node.children);
                    }
                });
            };
            collectUrls(currentTree);

            // 批量预热缓存（等待完成，确保渲染时缓存已就绪）
            if (allBookmarkUrls.length > 0) {
                try {
                    await warmupFaviconCache(allBookmarkUrls);
                } catch (e) {
                    console.warn('[renderTreeView] favicon缓存预热失败，继续渲染:', e);
                }
            }
        }

        // 快速检测变动（只在有备份数据时才检测）
        console.log('[renderTreeView] oldTree 存在:', !!oldTree);
        console.log('[renderTreeView] oldTree[0] 存在:', !!(oldTree && oldTree[0]));

        if (currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED) {
            // [Modified] In lazy mode, we still need diff detection to show "Add/Reduce/Modify/Move" indicators
            // previously we skipped it for performance, now we keep it but optimize rendering
            // treeChangeMap = new Map(); // Don't skip!
            console.log('[renderTreeView] Canvas lazy mode: executing diff detection to show indicators');
            treeChangeMap = await detectTreeChangesFast(oldTree, currentTree);
        } else if (oldTree && oldTree[0]) {
            console.log('[renderTreeView] 开始检测变动...');
            treeChangeMap = await detectTreeChangesFast(oldTree, currentTree);
            console.log('[renderTreeView] 检测到的变动数量:', treeChangeMap.size);

            // 打印前5个变动
            let count = 0;
            for (const [id, change] of treeChangeMap) {
                if (count++ < 5) {
                    console.log('[renderTreeView] 变动:', id, change);
                }
            }
        } else {
            treeChangeMap = new Map(); // 无备份数据，不显示任何变化标记
            console.log('[renderTreeView] 无上次备份数据，不显示变化标记');
        }

        // Canvas 懒加载：使用轻量变化提示缓存（用于显示四类图例/标识）
        let canvasHints = null;
        if (currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED) {
            canvasHints = await ensureCanvasLazyChangeHints(false);
        }

        // 合并旧树和新树，显示删除的节点
        let treeToRender = currentTree;
        if (oldTree && oldTree[0] && treeChangeMap && treeChangeMap.size > 0) {
            // 检查是否有删除的节点，只有在有删除节点时才重建树
            let hasDeletedNodes = false;
            for (const [, change] of treeChangeMap) {
                if (change.type === 'deleted') {
                    hasDeletedNodes = true;
                    break;
                }
            }
            if (hasDeletedNodes) {
                console.log('[renderTreeView] 检测到删除节点，合并旧树和新树');
                try {
                    treeToRender = rebuildTreeWithDeleted(oldTree, currentTree, treeChangeMap);
                } catch (error) {
                    console.error('[renderTreeView] 重建树时出错:', error);
                    treeToRender = currentTree; // 回退到原始树
                }
            }
        }
        console.log('[renderTreeView] 使用树:', treeToRender === currentTree ? 'currentTree' : 'rebuiltTree');

        // 使用 DocumentFragment 优化渲染
        const fragment = document.createDocumentFragment();

        // 只在有变化时才显示图例（Canvas 懒加载可使用变化提示缓存）
        // 只在有变化时才显示图例（Canvas 懒加载可使用变化提示缓存）
        if (treeChangeMap.size > 0 || (canvasHints && canvasHints.hasAny)) {
            const legend = document.createElement('div');
            legend.className = 'tree-legend';
            const cursorStyle = 'cursor: pointer; user-select: none;';
            legend.innerHTML = `
                <span class="legend-item" data-change-type="added" style="${cursorStyle}" title="${currentLang === 'zh_CN' ? '点击查看新增项' : 'Click to view added items'}"><span class="legend-dot added"></span> ${currentLang === 'zh_CN' ? '新增' : 'Added'}</span>
                <span class="legend-item" data-change-type="deleted" style="${cursorStyle}" title="${currentLang === 'zh_CN' ? '点击查看删除项' : 'Click to view deleted items'}"><span class="legend-dot deleted"></span> ${currentLang === 'zh_CN' ? '删除' : 'Deleted'}</span>
                <span class="legend-item" data-change-type="moved" style="${cursorStyle}" title="${currentLang === 'zh_CN' ? '点击查看移动项' : 'Click to view moved items'}"><span class="legend-dot moved"></span> ${currentLang === 'zh_CN' ? '移动' : 'Moved'}</span>
                <span class="legend-item" data-change-type="modified" style="${cursorStyle}" title="${currentLang === 'zh_CN' ? '点击查看修改项' : 'Click to view modified items'}"><span class="legend-dot modified"></span> ${currentLang === 'zh_CN' ? '修改' : 'Modified'}</span>
            `;
            fragment.appendChild(legend);
        }

        // Canvas 懒加载优化：计算需要强制展开的节点集合（包含变化的节点的路径上所有父节点）
        let forceExpandSet = new Set();
        if (treeChangeMap.size > 0 && currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED) {
            forceExpandSet = computeForceExpandSet(treeToRender, treeChangeMap);
            console.log('[renderTreeView] Force expand nodes count:', forceExpandSet.size);
        }

        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = renderTreeNodeWithChanges(treeToRender[0], 0, 50, new Set(), forceExpandSet);
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        // 更新缓存
        cachedTreeData = {
            treeFragment: fragment.cloneNode(true),
            currentTree: currentTree,
            renderTree: treeToRender
        };
        if (canUseVersion) {
            lastTreeSnapshotVersion = snapshotVersion;
        } else {
            lastTreeFingerprint = currentFingerprint;
        }

        // 使用 requestAnimationFrame 确保 DOM 更新和滚动恢复在同一帧内完成，减少闪烁
        requestAnimationFrame(() => {
            treeContainer.innerHTML = '';
            treeContainer.appendChild(fragment);
            treeContainer.style.display = 'block';

            // 绑定事件
            attachTreeEvents(treeContainer);

            // 恢复滚动位置（延迟确保展开状态和懒加载完成后再恢复滚动位置）
            if (permBody && permScrollTop !== null) {
                const restoreScroll = () => {
                    if (isScrollRestoreBlocked()) return;
                    permBody.scrollTop = permScrollTop;
                    permBody.scrollLeft = permScrollLeft;
                };
                restoreScroll();
                setTimeout(restoreScroll, 50);
                setTimeout(restoreScroll, 150);
                setTimeout(restoreScroll, 300); // 等待懒加载完成
                setTimeout(restoreScroll, 500); // 最终确保
            }

            console.log('[renderTreeView] 渲染完成');
        });

        // 重置渲染标志
        isRenderingTree = false;

        // 如果有待处理的渲染请求，处理它
        if (pendingRenderRequest !== null) {
            const pending = pendingRenderRequest;
            pendingRenderRequest = null;
            console.log('[renderTreeView] 处理待处理的渲染请求');
            renderTreeView(pending);
        }
    }).catch(error => {
        console.error('[renderTreeView] 错误:', error);
        treeContainer.innerHTML = `<div class="error">加载失败: ${escapeHtml(error && error.message ? error.message : String(error))}</div>`;
        treeContainer.style.display = 'block';

        // 重置渲染标志
        isRenderingTree = false;
        pendingRenderRequest = null;
    });
}

// 树事件处理器映射（避免重复绑定）
const treeClickHandlers = new WeakMap();
const treeContextMenuHandlers = new WeakMap();

// 绑定树的展开/折叠事件
function attachTreeEvents(treeContainer) {
    // 移除旧的事件监听器
    const existingHandler = treeClickHandlers.get(treeContainer);
    if (existingHandler) {
        treeContainer.removeEventListener('click', existingHandler);
    }

    // 创建新的事件处理器
    const clickHandler = async (e) => {
        // Canvas 永久栏目懒加载：加载更多
        try {
            const loadMoreBtn = e.target && e.target.closest ? e.target.closest('.tree-load-more') : null;
            if (loadMoreBtn && currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED) {
                e.preventDefault();
                e.stopPropagation();
                const parentId = loadMoreBtn.dataset.parentId;
                const startIndex = parseInt(loadMoreBtn.dataset.startIndex, 10) || 0;
                const childrenContainer = loadMoreBtn.closest('.tree-children');
                loadPermanentFolderChildrenLazy(parentId, childrenContainer, startIndex, loadMoreBtn);
                return;
            }
        } catch (_) { }

        // 处理移动标记的点击
        const moveBadge = e.target.closest('.change-badge.moved');
        if (moveBadge) {
            e.stopPropagation();
            let fromPath = moveBadge.getAttribute('data-move-from') || moveBadge.getAttribute('title');
            if (!fromPath) {
                const tooltipEl = moveBadge.querySelector('.move-tooltip');
                fromPath = tooltipEl ? (tooltipEl.textContent || '').trim() : '';
            }
            if (!fromPath) {
                try {
                    const item = moveBadge.closest('.tree-item');
                    const nodeId = item ? item.getAttribute('data-node-id') : null;
                    if (nodeId && cachedOldTree) {
                        const bc = getNamedPathFromTree(cachedOldTree, nodeId);
                        fromPath = breadcrumbToSlashFolders(bc);
                    }
                } catch (_) { }
            }
            if (!fromPath) fromPath = '/';
            const message = currentLang === 'zh_CN'
                ? `原位置：\n${fromPath}`
                : `Original location:\n${fromPath}`;
            alert(message);
            return;
        }

        // =============================================================================
        // 【重要架构】永久栏目书签左键点击处理器
        // =============================================================================
        // 本处理器是「书签系统」的一部分，与临时栏目的处理逻辑
        // （bookmark_canvas_module.js:tempLinkClickHandler）必须保持同步！
        // 两者都使用 window.defaultOpenMode 变量。
        //
        // ⚠️ 添加新的打开模式时，必须同时修改：
        //   1. 本文件 → attachTreeEvents → clickHandler（永久栏目）
        //   2. bookmark_canvas_module.js → tempLinkClickHandler（临时栏目）
        //   3. bookmark_tree_context_menu.js → 右键菜单action处理
        //
        // 详见：.agent/workflows/link-click-handling.md
        // =============================================================================
        // 左键点击书签标签，根据默认打开方式打开（避免重复绑定多个 click 监听器）
        try {
            const link = e.target && e.target.closest ? e.target.closest('a.tree-bookmark-link') : null;
            if (link && treeContainer.contains(link)) {
                // 尊重系统快捷键：Ctrl/Cmd/Shift 走浏览器默认行为
                if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;

                e.preventDefault();
                const url = link.getAttribute('href');
                const nodeElement = link.closest('.tree-item[data-node-id]');
                const contextInfo = nodeElement ? {
                    treeType: nodeElement.dataset.treeType || 'permanent',
                    sectionId: nodeElement.dataset.sectionId || null,
                    nodeId: nodeElement.dataset.nodeId || null
                } : { treeType: 'permanent' };

                try {
                    if (window.defaultOpenMode === undefined && typeof window.getDefaultOpenMode === 'function') {
                        window.defaultOpenMode = window.getDefaultOpenMode();
                    }
                } catch (_) { }
                const mode = (typeof window !== 'undefined' && window.defaultOpenMode) || (typeof defaultOpenMode !== 'undefined' ? defaultOpenMode : 'new-tab');

                const actionKey = `left-click-${mode}-${url}`;
                if (typeof shouldAllowBookmarkOpen === 'function' && !shouldAllowBookmarkOpen(actionKey)) {
                    return;
                }

                if (mode === 'new-window') {
                    if (typeof openBookmarkNewWindow === 'function') openBookmarkNewWindow(url, false); else window.open(url, '_blank');
                } else if (mode === 'incognito') {
                    if (typeof openBookmarkNewWindow === 'function') openBookmarkNewWindow(url, true); else window.open(url, '_blank');
                } else if (mode === 'specific-window') {
                    if (typeof openInSpecificWindow === 'function') openInSpecificWindow(url); else window.open(url, '_blank');
                } else if (mode === 'specific-group') {
                    if (typeof openInSpecificTabGroup === 'function') openInSpecificTabGroup(url); else window.open(url, '_blank');
                } else if (mode === 'scoped-window') {
                    if (typeof openInScopedWindow === 'function') openInScopedWindow(url, { context: contextInfo }); else window.open(url, '_blank');
                } else if (mode === 'scoped-group') {
                    if (typeof openInScopedTabGroup === 'function') openInScopedTabGroup(url, { context: contextInfo }); else window.open(url, '_blank');
                } else if (mode === 'same-window-specific-group') {
                    if (typeof openInSameWindowSpecificGroup === 'function') openInSameWindowSpecificGroup(url, { context: contextInfo }); else window.open(url, '_blank');
                } else if (mode === 'manual-select') {
                    if (typeof openBookmarkWithManualSelection === 'function') openBookmarkWithManualSelection(url); else window.open(url, '_blank');
                } else {
                    if (typeof openBookmarkNewTab === 'function') openBookmarkNewTab(url); else window.open(url, '_blank');
                }
                return;
            }
        } catch (_) { }

        // 点击整个文件夹行都可以展开
        const treeItem = e.target && e.target.closest ? e.target.closest('.tree-item[data-node-id]') : null;
        if (treeItem) {
            // 找到包含这个tree-item的tree-node
            const node = treeItem.closest('.tree-node');
            if (!node) {
                console.log('[树事件] 未找到tree-node');
                return;
            }

            const children = node.querySelector(':scope > .tree-children');
            const toggle = treeItem.querySelector(':scope > .tree-toggle');

            console.log('[树事件] 点击节点:', {
                hasChildren: !!children,
                hasToggle: !!toggle,
                nodeHTML: node.outerHTML.substring(0, 200)
            });

            if (children && toggle) {
                e.stopPropagation();
                children.classList.toggle('expanded');
                toggle.classList.toggle('expanded');

                console.log('[树事件] 切换展开状态:', toggle.classList.contains('expanded'));

                // 保存展开状态
                saveTreeExpandState(treeContainer);

                // Canvas 永久栏目懒加载：展开时按需加载子节点
                try {
                    const expanded = children.classList.contains('expanded');
                    if (expanded &&
                        currentView === 'canvas' &&
                        CANVAS_PERMANENT_TREE_LAZY_ENABLED &&
                        treeItem.dataset.nodeType === 'folder' &&
                        treeItem.dataset.childrenLoaded === 'false' &&
                        treeItem.dataset.hasChildren === 'true') {
                        loadPermanentFolderChildrenLazy(treeItem.dataset.nodeId, children, 0, null);
                    }
                } catch (_) { }
            }
        }
    };

    // 绑定新的事件监听器
    treeContainer.addEventListener('click', clickHandler);
    treeClickHandlers.set(treeContainer, clickHandler);

    // 绑定右键菜单事件（事件委托，避免反复给每个节点绑监听器）
    const existingContextHandler = treeContextMenuHandlers.get(treeContainer);
    if (existingContextHandler) {
        treeContainer.removeEventListener('contextmenu', existingContextHandler);
    }
    const contextHandler = (e) => {
        const item = e && e.target && e.target.closest ? e.target.closest('.tree-item[data-node-id]') : null;
        if (!item || !treeContainer.contains(item)) return;
        if (typeof showContextMenu === 'function') {
            showContextMenu(e, item);
        }
    };
    treeContainer.addEventListener('contextmenu', contextHandler);
    treeContextMenuHandlers.set(treeContainer, contextHandler);

    // 绑定拖拽事件
    if (typeof attachDragEvents === 'function') {
        attachDragEvents(treeContainer);
    }

    // 绑定指针拖拽事件（支持滚轮滚动）
    if (typeof attachPointerDragEvents === 'function') {
        attachPointerDragEvents(treeContainer);
        console.log('[树事件] 指针拖拽事件已绑定');
    }

    // 如果在Canvas视图，重新绑定Canvas拖出功能
    if (currentView === 'canvas' && window.CanvasModule && window.CanvasModule.enhance) {
        console.log('[树事件] 当前在Canvas视图，重新绑定Canvas拖出功能');
        window.CanvasModule.enhance();
    }

    console.log('[树事件] 事件绑定完成');

    // 恢复展开状态
    restoreTreeExpandState(treeContainer);

    // 绑定Permanent Section图例点击事件
    setupLegendClickHandlers(treeContainer);
}

// 绑定图例点击导航功能
function setupLegendClickHandlers(container) {
    const legends = container.querySelectorAll('.tree-legend .legend-item[data-change-type]');
    legends.forEach(item => {
        item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const type = item.getAttribute('data-change-type');
            if (type) {
                jumpToNextChangeType(type, container);
            }
        });
    });
}

// 导航到下一个指定类型的变动节点
// 维护每个类型的当前索引，实现循环跳转
const _changeTypeIndices = { added: -1, deleted: -1, modified: -1, moved: -1 };
async function jumpToNextChangeType(type, container) {
    if (!treeChangeMap || treeChangeMap.size === 0) {
        const msg = currentLang === 'zh_CN' ? '当前没有变动' : 'No changes detected';
        // 使用简单的提示，或者 custom toast
        console.log(msg);
        return;
    }

    // 收集所有符合类型的节点ID
    let targetIds = [];
    const candidates = new Set();
    for (const [id, change] of treeChangeMap.entries()) {
        let match = false;
        if (type === 'added' && change.type === 'added') match = true;
        else if (type === 'deleted' && change.type === 'deleted') match = true;
        else if (type === 'modified' && change.type.includes('modified')) match = true;
        else if (type === 'moved' && change.type.includes('moved')) match = true;

        if (match) candidates.add(id);
    }

    // 还有显式移动的
    if (type === 'moved' && explicitMovedIds) {
        const now = Date.now();
        for (const [id, expiry] of explicitMovedIds.entries()) {
            if (expiry > now) {
                candidates.add(id);
            }
        }
    }

    // [New] 按照树的视觉顺序（从上到下）排序 targetIds
    if (candidates.size > 0) {
        if (cachedTreeData && cachedTreeData.renderTree) {
            const sorted = [];
            const traverse = (nodes) => {
                if (!nodes || !Array.isArray(nodes)) return;
                for (const node of nodes) {
                    if (candidates.has(node.id)) {
                        sorted.push(node.id);
                    }
                    if (node.children && node.children.length > 0) {
                        traverse(node.children);
                    }
                }
            };
            // 根节点通常是虚拟的或者就是 treeToRender[0]
            traverse(cachedTreeData.renderTree);
            targetIds = sorted;

            // 兜底：如果有遗漏（理论上不应该，除非 renderTree 不全），把剩下的追加在后面
            if (sorted.length < candidates.size) {
                candidates.forEach(id => {
                    if (!sorted.includes(id)) targetIds.push(id);
                });
            }
        } else {
            // 降级：无树结构缓存，使用默认 Map 顺序
            targetIds = Array.from(candidates);
        }
    }



    if (targetIds.length === 0) {
        const typeLabels = {
            added: currentLang === 'zh_CN' ? '新增' : 'Added',
            deleted: currentLang === 'zh_CN' ? '删除' : 'Deleted',
            modified: currentLang === 'zh_CN' ? '修改' : 'Modified',
            moved: currentLang === 'zh_CN' ? '移动' : 'Moved'
        };
        const msg = currentLang === 'zh_CN'
            ? `没有找到"${typeLabels[type]}"类型的变动`
            : `No items found for "${typeLabels[type]}"`;
        alert(msg);
        return;
    }

    // 循环索引
    _changeTypeIndices[type]++;
    if (_changeTypeIndices[type] >= targetIds.length) {
        _changeTypeIndices[type] = 0;
    }
    const targetId = targetIds[_changeTypeIndices[type]];

    console.log(`[JumpToChange] Type: ${type}, Index: ${_changeTypeIndices[type]}/${targetIds.length}, ID: ${targetId}`);

    // 如果节点未渲染（在懒加载的折叠文件夹中），需要先展开父级
    // 我们复用 computeForceExpandSet 的逻辑思想，但这里针对单个节点
    // 1. 找到该节点的所有父ID
    // 2. 强制展开这些父ID
    // 3. 滚动到该节点

    // 获取路径
    // 由于我们可能是在 collapsed 的文件夹里，DOM里可能没有这个元素
    let targetItem = container.querySelector(`.tree-item[data-node-id="${targetId}"]`);

    if (!targetItem) {
        // 尝试在 cachedTreeData.currentTree (或者 rebuilding logic) 中找路径
        // 但最简单的是：触发一次带 forceExpand 的渲染，但这比较重
        // 替代方案：根据 treeChangeMap 里的 info (detectTreeChangesFast 里有 parentId) 
        // 但 fast map里存的结构可能不全。
        // 可靠方案：如果 treeChangeMap 存在，说明我们有完整树数据。
        // 我们利用 search 的 jumpToResult 逻辑（如果它通用），或者简单地：
        // 强制把这个 targetId 加入 forceExpandSet（如果能传进去），然后重绘? 
        // 不，重绘太慢。

        // 更好的方式：利用 loadPermanentFolderChildrenLazy 递归加载/展开路径
        // 但我们需要知道路径。
        // 如果我们有 cachedOldTree 和 cachedCurrentTree (treeToRender)，我们可以遍历找到路径。

        // 这里简化处理：如果找不到DOM，提示用户展开文件夹，或者尝试触发一次“定位重绘”
        // 实际上，我们之前的 forceExpandSet 逻辑应该已经保证了“有变动的节点”是渲染了的（除非是“此文件夹下有变化”的深层节点）
        // 等等，之前的 forceExpandSet 是把**所有**变动节点都强制展开了吗？
        // 是的：computeForceExpandSet 递归检查，如果子节点有变动，父节点加入set。
        // 此时 renderTreeView 会使用 set 来决定是否截断懒加载。
        // 所以，如果 renderTreeView 已经运行过且正确，target element 应该已经在 DOM 中了！
        // 除非 target element 本身是折叠状态（但 forceExpandSet 也会展开它？不，forceExpandSet 是让它*被渲染*，是否 `expanded` 取决于 `expanded` class）

        // 检查 renderTreeNodeWithChanges:
        // const shouldForceExpand = forceExpandSet && forceExpandSet.has(node.id);
        // <span class="tree-children ${level === 0 || shouldForceExpand ? 'expanded' : ''}">
        // 所以，如果有变动，父文件夹应该是 expanded 的。
        // 唯一的例外是：如果是 lazy rendering 初次加载，可能还在进行中？或者 forceExpandSet 被漏了？
        // 前面的修复确保了 Canvas 模式下总是计算 forceExpandSet。

        // 所以理论上 targetItem 应该存在。如果不存在，可能是：
        // 1. 这是一个删除的节点，且父节点被折叠 (?)
        // 2. 这是一个“移动”的节点，在 lazy load 区域 (?)
    }

    if (targetItem) {
        // 确保父级视觉上展开 (css check)
        let parent = targetItem.closest('.tree-children');
        let expandedAny = false;
        while (parent && parent !== container) {
            if (!parent.classList.contains('expanded')) {
                parent.classList.add('expanded');
                expandedAny = true;
                const pNode = parent.closest('.tree-node');
                if (pNode) {
                    const toggle = pNode.querySelector('.tree-toggle');
                    if (toggle) toggle.classList.add('expanded');
                    const icon = pNode.querySelector('.tree-icon.fas.fa-folder');
                    if (icon) {
                        icon.classList.remove('fa-folder');
                        icon.classList.add('fa-folder-open');
                    }
                }
            }
            parent = parent.parentElement ? parent.parentElement.closest('.tree-children') : null;
        }

        // 如果展开了任何文件夹，保存展开状态以实现持久化
        if (expandedAny) {
            saveTreeExpandState(container);
        }

        // 滚动并高亮
        targetItem.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // 移除旧的高亮
        container.querySelectorAll('.highlight-target').forEach(el => {
            el.classList.remove('highlight-target');
            el.style.animation = 'none';
        });

        // 高亮所有该类型的节点 (Added matches Added, Modified matches Modifed, etc)
        // 从 targetIds 列表里找，只要 DOM 里存在的都高亮
        let highlightCount = 0;
        targetIds.forEach(id => {
            const item = container.querySelector(`.tree-item[data-node-id="${id}"]`);
            if (item) {
                // 确保样式类存在并触发重绘
                item.classList.add('highlight-target');
                item.style.animation = 'none';
                item.offsetHeight; /* trigger reflow */
                // 强制应用动画（以防 CSS 优先级或未生效）
                item.style.animation = 'highlightPulse 2s ease-out infinite';
                highlightCount++;

                // 3秒后移除动画
                setTimeout(() => {
                    // 检查是否还在 DOM 中（防止已经被重新渲染替换）
                    if (item.isConnected) {
                        item.style.animation = '';
                        item.classList.remove('highlight-target');
                    }
                }, 3000);
            }
        });

        console.log(`[JumpToChange] Scrolled to ${targetId}, Highlighted ${highlightCount} items`);
    } else {
        console.warn(`[JumpToChange] Element ${targetId} not found in DOM even after force expand check.`);
        // fallback?
    }
}

// 保存JSON滚动位置
function saveJSONScrollPosition(jsonContainer) {
    try {
        const content = jsonContainer.querySelector('.json-diff-content');
        if (content) {
            const scrollTop = content.scrollTop;
            localStorage.setItem('jsonScrollPosition', scrollTop.toString());
            console.log('[JSON状态] 保存滚动位置:', scrollTop);
        }
    } catch (e) {
        console.error('[JSON状态] 保存滚动位置失败:', e);
    }
}

// 恢复JSON滚动位置
function restoreJSONScrollPosition(jsonContainer) {
    try {
        const savedPosition = localStorage.getItem('jsonScrollPosition');
        if (savedPosition) {
            const content = jsonContainer.querySelector('.json-diff-content');
            if (content) {
                content.scrollTop = parseInt(savedPosition, 10);
                console.log('[JSON状态] 恢复滚动位置:', savedPosition);
            }
        }
    } catch (e) {
        console.error('[JSON状态] 恢复滚动位置失败:', e);
    }
}

// 保存树的展开状态（使用节点 ID，更可靠）
let _saveTreeExpandStateTimer = null;
let _saveTreeExpandStateLastContainer = null;
function saveTreeExpandState(treeContainer) {
    try {
        _saveTreeExpandStateLastContainer = treeContainer;
        if (_saveTreeExpandStateTimer) {
            clearTimeout(_saveTreeExpandStateTimer);
        }
        _saveTreeExpandStateTimer = setTimeout(() => {
            _saveTreeExpandStateTimer = null;
            const container = _saveTreeExpandStateLastContainer;
            if (!container) return;
            try {
                const expandedIds = [];
                container.querySelectorAll('.tree-children.expanded').forEach(children => {
                    const node = children.closest('.tree-node');
                    const item = node ? node.querySelector('.tree-item[data-node-id]') : null;
                    if (item && item.dataset.nodeId) {
                        expandedIds.push(item.dataset.nodeId);
                    }
                });
                localStorage.setItem('treeExpandedNodeIds', JSON.stringify(expandedIds));
                console.log('[树状态] 保存展开节点:', expandedIds.length);
            } catch (e) {
                console.error('[树状态] 保存失败:', e);
            }
        }, 250);
    } catch (e) {
        console.error('[树状态] 保存失败:', e);
    }
}

// 恢复树的展开状态（使用节点 ID，更可靠）
function restoreTreeExpandState(treeContainer) {
    try {
        const savedState = localStorage.getItem('treeExpandedNodeIds');
        if (!savedState) return;

        const expandedIds = JSON.parse(savedState);
        if (!Array.isArray(expandedIds) || expandedIds.length === 0) return;

        const expandedSet = new Set(expandedIds);
        const nodesToLazyLoad = []; // Canvas 懒加载模式下需要加载子节点的文件夹

        treeContainer.querySelectorAll('.tree-item[data-node-id]').forEach(item => {
            if (expandedSet.has(item.dataset.nodeId)) {
                const node = item.closest('.tree-node');
                if (!node) return;
                const children = node.querySelector(':scope > .tree-children');
                const toggle = item.querySelector('.tree-toggle');
                const icon = item.querySelector('.tree-icon.fas');
                if (children && toggle) {
                    children.classList.add('expanded');
                    toggle.classList.add('expanded');
                    // 更新文件夹图标
                    if (icon && icon.classList.contains('fa-folder')) {
                        icon.classList.remove('fa-folder');
                        icon.classList.add('fa-folder-open');
                    }
                    // Canvas 懒加载模式：如果子节点未加载，记录下来稍后加载
                    if (currentView === 'canvas' &&
                        CANVAS_PERMANENT_TREE_LAZY_ENABLED &&
                        item.dataset.childrenLoaded === 'false' &&
                        item.dataset.hasChildren === 'true') {
                        nodesToLazyLoad.push({ parentId: item.dataset.nodeId, children });
                    }
                }
            }
        });

        // Canvas 懒加载模式：批量加载需要展开的文件夹的子节点
        if (nodesToLazyLoad.length > 0) {
            console.log('[树状态] Canvas懒加载：需要加载', nodesToLazyLoad.length, '个文件夹的子节点');
            // 延迟加载，避免阻塞渲染
            setTimeout(() => {
                nodesToLazyLoad.forEach(({ parentId, children }) => {
                    try {
                        loadPermanentFolderChildrenLazy(parentId, children, 0, null);
                    } catch (e) {
                        console.warn('[树状态] 懒加载子节点失败:', parentId, e);
                    }
                });
            }, 50);
        }

        console.log('[树状态] 恢复展开节点:', expandedIds.length);
    } catch (e) {
        console.error('[树状态] 恢复失败:', e);
    }
}

// 快速检测书签树变动（性能优化版 + 智能移动检测）
// options:
// - useGlobalExplicitMovedIds: 是否使用全局 explicitMovedIds（默认 true，用于 Current Changes / Canvas）
// - explicitMovedIdSet: 指定一个 Set/Array 的 moved ids（用于备份历史按“当次提交”复现），传 null 表示禁用显式 moved
async function detectTreeChangesFast(oldTree, newTree, options = {}) {
    const changes = new Map();
    if (!oldTree || !newTree) return changes;

    const now = Date.now();

    const useGlobalExplicitMovedIds = options.useGlobalExplicitMovedIds !== false;
    let explicitMovedIdSet = null;
    if (options && typeof options === 'object' && 'explicitMovedIdSet' in options) {
        const src = options.explicitMovedIdSet;
        if (src instanceof Set) {
            explicitMovedIdSet = new Set(Array.from(src).map(v => String(v)));
        } else if (Array.isArray(src)) {
            explicitMovedIdSet = new Set(src.map(v => String(v)));
        } else if (src === null) {
            explicitMovedIdSet = null;
        }
    } else if (useGlobalExplicitMovedIds && explicitMovedIds instanceof Map) {
        explicitMovedIdSet = new Set();
        for (const [id, expiry] of explicitMovedIds.entries()) {
            if (typeof expiry !== 'number' || expiry > now) {
                explicitMovedIdSet.add(String(id));
            }
        }
    }
    const hasExplicitMovedInfo = explicitMovedIdSet instanceof Set && explicitMovedIdSet.size > 0;

    const oldNodes = new Map();
    const newNodes = new Map();
    const oldByParent = new Map(); // parentId -> [{id,index}]
    const newByParent = new Map();

    const traverse = (node, map, byParent, parentId = null) => {
        if (node && node.id) {
            const record = {
                title: node.title,
                url: node.url,
                parentId: node.parentId || parentId,
                index: node.index
            };
            map.set(node.id, record);
            if (record.parentId) {
                if (!byParent.has(record.parentId)) byParent.set(record.parentId, []);
                byParent.get(record.parentId).push({ id: node.id, index: record.index });
            }
        }
        if (node && node.children) node.children.forEach(child => traverse(child, map, byParent, node.id));
    };

    if (oldTree[0]) traverse(oldTree[0], oldNodes, oldByParent, null);
    if (newTree[0]) traverse(newTree[0], newNodes, newByParent, null);

    const getNodePath = (tree, targetId) => {
        const path = [];
        const dfs = (node, cur) => {
            if (!node) return false;
            if (node.id === targetId) { path.push(...cur, node.title); return true; }
            if (node.children) {
                for (const c of node.children) { if (dfs(c, [...cur, node.title])) return true; }
            }
            return false;
        };
        if (tree[0]) dfs(tree[0], []);
        return path.join(' > ');
    };

    // 新增 / 修改 / 跨级移动
    newNodes.forEach((n, id) => {
        const o = oldNodes.get(id);
        if (!o) { changes.set(id, { type: 'added' }); return; }
        const modified = (o.title !== n.title) || (o.url !== n.url);
        const crossMove = o.parentId !== n.parentId;
        if (modified || crossMove) {
            const types = [];
            const detail = {};
            if (modified) types.push('modified');
            if (crossMove) {
                types.push('moved');
                detail.moved = {
                    oldPath: getNodePath(oldTree, id),
                    newPath: getNodePath(newTree, id),
                    oldParentId: o.parentId,
                    oldIndex: o.index,
                    newParentId: n.parentId,
                    newIndex: n.index
                };
            }
            changes.set(id, { type: types.join('+'), ...detail });
        }
    });

    // 删除
    oldNodes.forEach((_, id) => { if (!newNodes.has(id)) changes.set(id, { type: 'deleted' }); });

    // 建立“子节点集合发生变化”的父级集合：
    // - add/delete 会导致同级 index 被动变化（不应被当成 moved）
    // - 跨级移动会改变源/目标父级的 children 集合（同样不应误标同级为 moved）
    const parentsWithChildSetChange = new Set();
    changes.forEach((change, id) => {
        if (!change || !change.type) return;

        if (change.type.includes('added') || change.type.includes('deleted')) {
            const node = change.type.includes('added') ? newNodes.get(id) : oldNodes.get(id);
            if (node && node.parentId) parentsWithChildSetChange.add(node.parentId);
        }

        // 跨级移动：把 old/new parent 都加入（避免同级被动位移误标）
        if (change.type.includes('moved') && change.moved && change.moved.oldParentId !== change.moved.newParentId) {
            if (change.moved.oldParentId) parentsWithChildSetChange.add(change.moved.oldParentId);
            if (change.moved.newParentId) parentsWithChildSetChange.add(change.moved.newParentId);
        }
    });

    const markMoved = (id) => {
        const existing = changes.get(id);
        const types = existing && existing.type ? new Set(existing.type.split('+')) : new Set();
        types.add('moved');
        const movedDetail = { oldPath: getNodePath(oldTree, id), newPath: getNodePath(newTree, id) };
        changes.set(id, { type: Array.from(types).join('+'), moved: movedDetail });
    };

    // 同级移动（重要：只标记“被拖动”的对象；不标记因为插入/删除/跨级移动导致的同级被动位移）
    // - 有显式 moved IDs（onMoved）时：只按显式集合打标（即使该父级也发生了 add/delete 或跨级移动）
    // - 无显式 moved IDs 时：仅在该父级 children 集合未变化时，用 LIS 推导最小 moved 集合
    const commonPosCache = new Map(); // parentId -> { oldPosById, newPosById } （仅针对 common ids）
    const getCommonPositions = (parentId) => {
        if (commonPosCache.has(parentId)) return commonPosCache.get(parentId);

        const oldList = oldByParent.get(parentId) || [];
        const newList = newByParent.get(parentId) || [];
        const newIdSet = new Set(newList.map(x => String(x.id)));

        const oldPosById = new Map();
        let oldPos = 0;
        for (const item of oldList) {
            const sid = String(item.id);
            if (newIdSet.has(sid)) {
                oldPosById.set(sid, oldPos++);
            }
        }

        const newPosById = new Map();
        let newPos = 0;
        for (const item of newList) {
            const sid = String(item.id);
            if (oldPosById.has(sid)) {
                newPosById.set(sid, newPos++);
            }
        }

        const entry = { oldPosById, newPosById };
        commonPosCache.set(parentId, entry);
        return entry;
    };

    if (hasExplicitMovedInfo) {
        for (const id of explicitMovedIdSet) {
            const o = oldNodes.get(id);
            const n = newNodes.get(id);
            if (!o || !n) continue; // added/deleted: Git 口径不算 moved
            if (!o.parentId || !n.parentId) continue;
            if (o.parentId !== n.parentId) continue; // 跨级 moved 已在上方标记

            const parentId = n.parentId;
            const { oldPosById, newPosById } = getCommonPositions(parentId);
            const oldPos = oldPosById.get(id);
            const newPos = newPosById.get(id);
            if (typeof oldPos === 'number' && typeof newPos === 'number' && oldPos !== newPos) {
                markMoved(id);
            }
        }
    } else {
        // 无显式 moved：对“children 集合未变化”的父级做最小 moved 推导
        newByParent.forEach((newList, parentId) => {
            if (parentsWithChildSetChange.has(parentId)) return;

            const oldList = oldByParent.get(parentId) || [];
            if (oldList.length === 0 || newList.length === 0) return;
            if (oldList.length !== newList.length) return;

            // 先快速判等（完全一致则不必做 LIS）
            let sameOrder = true;
            for (let i = 0; i < oldList.length; i++) {
                if (String(oldList[i].id) !== String(newList[i].id)) {
                    sameOrder = false;
                    break;
                }
            }
            if (sameOrder) return;

            const oldPosById = new Map();
            for (let i = 0; i < oldList.length; i++) {
                oldPosById.set(String(oldList[i].id), i);
            }

            const seq = [];
            for (let i = 0; i < newList.length; i++) {
                const id = String(newList[i].id);
                const oldPos = oldPosById.get(id);
                if (typeof oldPos !== 'number') return; // children 集合变化（保险兜底）
                seq.push({ id, oldPos });
            }

            // 计算 LIS（基于 oldPos，得到最大稳定子序列），其余视为 moved
            const tails = [];
            const tailsIdx = [];
            const prevIdx = new Array(seq.length).fill(-1);

            for (let i = 0; i < seq.length; i++) {
                const v = seq[i].oldPos;
                let lo = 0;
                let hi = tails.length;
                while (lo < hi) {
                    const mid = (lo + hi) >> 1;
                    if (tails[mid] < v) lo = mid + 1;
                    else hi = mid;
                }
                const pos = lo;
                if (pos > 0) prevIdx[i] = tailsIdx[pos - 1];
                if (pos === tails.length) {
                    tails.push(v);
                    tailsIdx.push(i);
                } else {
                    tails[pos] = v;
                    tailsIdx[pos] = i;
                }
            }

            const stableIds = new Set();
            let k = tailsIdx.length ? tailsIdx[tailsIdx.length - 1] : -1;
            while (k >= 0) {
                stableIds.add(seq[k].id);
                k = prevIdx[k];
            }

            for (const item of seq) {
                if (!stableIds.has(item.id)) {
                    markMoved(item.id);
                }
            }
        });
    }

    return changes;
}

// 渲染JSON Diff（延迟加载优化）
let jsonDiffRendered = false;
function renderJSONDiff(container, oldTree, newTree) {
    // 只显示加载提示，真正渲染延迟到切换时
    if (!jsonDiffRendered) {
        container.innerHTML = `
            <div class="json-header">
                <button class="json-copy-btn" data-action="copyJSONDiff">
                    <i class="fas fa-copy"></i> ${currentLang === 'zh_CN' ? '复制Diff' : 'Copy Diff'}
                </button>
            </div>
            <div class="json-diff-content">
                <div class="loading" style="padding: 40px; text-align: center; color: var(--text-tertiary);">
                    ${currentLang === 'zh_CN' ? '切换到JSON视图时自动加载' : 'Loading when switched to JSON view'}
                </div>
            </div>
        `;
        return;
    }

    // 真正渲染Diff（使用 requestIdleCallback 分批渲染）
    const oldJSON = oldTree ? JSON.stringify(oldTree, null, 2) : '';
    const newJSON = newTree ? JSON.stringify(newTree, null, 2) : '';

    const oldLines = oldJSON.split('\n');
    const newLines = newJSON.split('\n');

    // 使用更快的diff算法
    const diff = fastLineDiff(oldLines, newLines);

    // 分批渲染
    const header = `
        <div class="json-header">
            <button class="json-copy-btn" data-action="copyJSONDiff">
                <i class="fas fa-copy"></i> ${currentLang === 'zh_CN' ? '复制Diff' : 'Copy Diff'}
            </button>
        </div>
        <div class="json-diff-content" id="jsonDiffContent">
    `;

    container.innerHTML = header + '</div>';
    const content = container.querySelector('#jsonDiffContent');

    // 分批渲染（每批100行）
    const batchSize = 100;
    let currentBatch = 0;

    const renderBatch = () => {
        const start = currentBatch * batchSize;
        const end = Math.min(start + batchSize, diff.length);
        const fragment = document.createDocumentFragment();

        for (let idx = start; idx < end; idx++) {
            const line = diff[idx];
            const lineClass = line.type === 'added' ? 'added' : line.type === 'deleted' ? 'deleted' : 'same';
            const prefix = line.type === 'added' ? '+' : line.type === 'deleted' ? '-' : ' ';

            const div = document.createElement('div');
            div.className = `json-diff-line ${lineClass}`;
            div.innerHTML = `
                <span class="json-line-num old">${line.oldNum || ''}</span>
                <span class="json-line-num new">${line.newNum || ''}</span>
                <span class="json-prefix">${prefix}</span>
                <span class="json-line-text">${escapeHtml(line.line)}</span>
            `;
            fragment.appendChild(div);
        }

        content.appendChild(fragment);

        currentBatch++;
        if (end < diff.length) {
            requestIdleCallback ? requestIdleCallback(renderBatch) : setTimeout(renderBatch, 0);
        } else {
            // 渲染完成，尝试恢复滚动位置或定位到第一个diff
            requestAnimationFrame(() => {
                const savedPosition = localStorage.getItem('jsonScrollPosition');
                if (savedPosition) {
                    // 恢复上次的滚动位置
                    content.scrollTop = parseInt(savedPosition, 10);
                    console.log('[JSON渲染] 恢复滚动位置:', savedPosition);
                } else {
                    // 没有保存的位置，自动定位到第一个diff
                    const firstDiff = content.querySelector('.json-diff-line.added, .json-diff-line.deleted');
                    if (firstDiff) {
                        const offset = firstDiff.offsetTop - content.offsetTop - 100;
                        content.scrollTop = Math.max(0, offset);
                    }
                }
            });
        }
    };

    renderBatch();
}

// 快速行级diff算法
function fastLineDiff(oldLines, newLines) {
    const diff = [];
    const oldSet = new Set(oldLines);
    const newSet = new Set(newLines);

    let i = 0, j = 0;

    while (i < oldLines.length || j < newLines.length) {
        if (i < oldLines.length && j < newLines.length && oldLines[i] === newLines[j]) {
            diff.push({ type: 'same', line: oldLines[i], oldNum: i + 1, newNum: j + 1 });
            i++;
            j++;
        } else if (i < oldLines.length && !newSet.has(oldLines[i])) {
            diff.push({ type: 'deleted', line: oldLines[i], oldNum: i + 1, newNum: null });
            i++;
        } else if (j < newLines.length && !oldSet.has(newLines[j])) {
            diff.push({ type: 'added', line: newLines[j], oldNum: null, newNum: j + 1 });
            j++;
        } else if (i < oldLines.length) {
            diff.push({ type: 'deleted', line: oldLines[i], oldNum: i + 1, newNum: null });
            i++;
        } else {
            diff.push({ type: 'added', line: newLines[j], oldNum: null, newNum: j + 1 });
            j++;
        }
    }

    return diff;
}

// 复制JSON Diff
window.copyJSONDiff = function () {
    const lines = document.querySelectorAll('.json-diff-line');
    let text = '';
    lines.forEach(line => {
        const prefix = line.querySelector('.json-prefix').textContent;
        const content = line.querySelector('.json-line-text').textContent;
        text += prefix + content + '\n';
    });

    navigator.clipboard.writeText(text).then(() => {
        alert(currentLang === 'zh_CN' ? 'Diff已复制到剪贴板' : 'Diff copied to clipboard');
    }).catch(err => {
        console.error('复制失败:', err);
    });
}

// 生成面包屑式的路径显示（用于移动tooltip）
// 支持显示单个路径或双路径（原始+当前）
function generateBreadcrumbForTooltip(pathInfo) {
    // 兼容旧的字符串参数
    if (typeof pathInfo === 'string') {
        return generateSinglePathBreadcrumb(pathInfo, currentLang === 'zh_CN' ? '从' : 'From');
    }

    // 新的对象参数：{ originalPath, currentPath, hasChanges }
    if (!pathInfo || !pathInfo.originalPath) return '';

    let html = '';

    if (pathInfo.hasChanges && pathInfo.currentPath) {
        // 显示两个路径：原始路径 + 当前路径
        const originalLabel = currentLang === 'zh_CN' ? '原位置' : 'Original';
        const currentLabel = currentLang === 'zh_CN' ? '现在位置' : 'Current';

        html += generateSinglePathBreadcrumb(pathInfo.originalPath, originalLabel);
        html += '<div class="path-separator"></div>'; // 分隔线
        html += generateSinglePathBreadcrumb(pathInfo.currentPath, currentLabel);
    } else {
        // 只显示一个路径
        const prefix = currentLang === 'zh_CN' ? '从' : 'From';
        html += generateSinglePathBreadcrumb(pathInfo.originalPath, prefix);
    }

    return html;
}

// 生成单个路径的面包屑
function generateSinglePathBreadcrumb(path, label) {
    if (!path) return '';

    const parts = path.split(' > ');

    let html = `<span class="move-tooltip-label">${label}:</span>`;

    parts.forEach((part, index) => {
        const isRoot = index === 0;
        const iconClass = isRoot ? 'fa-home' : 'fa-folder';
        const itemClass = isRoot ? 'root' : '';

        html += `<span class="breadcrumb-item ${itemClass}">
            <i class="fas ${iconClass}"></i>
            <span class="breadcrumb-text">${escapeHtml(part)}</span>
        </span>`;

        if (index < parts.length - 1) {
            html += '<span class="breadcrumb-separator"><i class="fas fa-chevron-right"></i></span>';
        }
    });

    return html;
}

// 合并旧树和新树，显示所有节点（包括删除的）
function mergeTreesForDisplay(oldTree, newTree) {
    const allNodes = new Map();

    // 遍历新树
    function traverseNew(nodes, parentPath = '') {
        if (!nodes) return;
        nodes.forEach(node => {
            const currentPath = parentPath ? `${parentPath}/${node.title}` : node.title;
            allNodes.set(node.id, { node, status: 'current', path: currentPath });
            if (node.children) {
                traverseNew(node.children, currentPath);
            }
        });
    }

    // 遍历旧树，找出已删除的节点
    function traverseOld(nodes, parentPath = '') {
        if (!nodes) return;
        nodes.forEach(node => {
            const currentPath = parentPath ? `${parentPath}/${node.title}` : node.title;
            if (!allNodes.has(node.id)) {
                allNodes.set(node.id, { node, status: 'deleted', path: currentPath });
            }
            if (node.children) {
                traverseOld(node.children, currentPath);
            }
        });
    }

    if (newTree && newTree[0]) traverseNew(newTree[0].children);
    if (oldTree && oldTree[0]) traverseOld(oldTree[0].children);

    return allNodes;
}

// 重建树结构，包含删除的节点（保持原始位置）
function rebuildTreeWithDeleted(oldTree, newTree, changeMap) {
    console.log('[树重建] 开始重建树结构');

    if (!oldTree || !oldTree[0] || !newTree || !newTree[0]) {
        console.log('[树重建] 缺少树数据，返回新树');
        return newTree;
    }

    // 防止循环引用的集合
    const visitedIds = new Set();
    const MAX_DEPTH = 50;

    // 基于旧树重建，添加新节点和保留删除节点
    function rebuildNode(oldNode, newNodes, depth = 0) {
        // 安全检查
        if (!oldNode || typeof oldNode.id === 'undefined') {
            console.log('[树重建] 跳过无效节点:', oldNode);
            return null;
        }

        // 深度限制
        if (depth > MAX_DEPTH) {
            console.warn('[树重建] 超过最大深度限制:', depth);
            return null;
        }

        // 循环引用检测
        if (visitedIds.has(oldNode.id)) {
            console.warn('[树重建] 检测到循环引用:', oldNode.id);
            return null;
        }
        visitedIds.add(oldNode.id);

        // 在新树中查找对应的节点
        const newNode = newNodes ? newNodes.find(n => n && n.id === oldNode.id) : null;
        const change = changeMap ? changeMap.get(oldNode.id) : null;

        if (change && change.type === 'deleted') {
            // 节点被删除，保留但标记
            console.log('[树重建] 保留删除节点:', oldNode.title);
            const deletedNodeCopy = JSON.parse(JSON.stringify(oldNode));

            // 递归处理子节点
            if (oldNode.children && oldNode.children.length > 0) {
                deletedNodeCopy.children = oldNode.children.map(child => rebuildNode(child, null, depth + 1)).filter(n => n !== null);
            }

            return deletedNodeCopy;
        } else if (newNode) {
            // 节点存在于新树中
            const nodeCopy = JSON.parse(JSON.stringify(newNode));

            // 处理子节点：合并新旧子节点
            if (oldNode.children || newNode.children) {
                const childrenMap = new Map();

                // 先添加旧的子节点
                if (oldNode.children) {
                    oldNode.children.forEach((child, index) => {
                        childrenMap.set(child.id, { node: child, index, source: 'old' });
                    });
                }

                // 更新或添加新的子节点
                if (newNode.children) {
                    newNode.children.forEach((child, index) => {
                        childrenMap.set(child.id, { node: child, index, source: 'new' });
                    });
                }

                // 重建子节点列表，保持原始顺序
                const rebuiltChildren = [];

                // 按照旧树的顺序遍历
                if (oldNode.children) {
                    oldNode.children.forEach(oldChild => {
                        if (!oldChild) return; // 跳过null/undefined子节点

                        const childInfo = childrenMap.get(oldChild.id);
                        if (childInfo) {
                            const rebuiltChild = rebuildNode(oldChild, newNode.children, depth + 1);
                            if (rebuiltChild) {
                                rebuiltChildren.push(rebuiltChild);
                            }
                        }
                    });
                }

                // 添加新增的子节点
                if (newNode.children) {
                    newNode.children.forEach(newChild => {
                        if (!newChild) return; // 跳过null/undefined子节点

                        if (!oldNode.children || !oldNode.children.find(c => c && c.id === newChild.id)) {
                            // 这是新增的节点
                            console.log('[树重建] 添加新节点:', newChild.title);
                            rebuiltChildren.push(newChild);
                        }
                    });
                }

                nodeCopy.children = rebuiltChildren;
            }

            return nodeCopy;
        } else if (newNodes === null && change && change.type === 'deleted') {
            // 父节点已删除，这个子节点也视为删除，保留但标记
            console.log('[树重建] 保留已删除节点的子节点:', oldNode.title);
            const deletedNodeCopy = JSON.parse(JSON.stringify(oldNode));

            // 递归处理子节点
            if (oldNode.children && oldNode.children.length > 0) {
                deletedNodeCopy.children = oldNode.children.map(child => rebuildNode(child, null, depth + 1)).filter(n => n !== null);
            }

            return deletedNodeCopy;
        } else {
            // 节点在新树中不存在，不是删除，跳过它
            console.log('[树重建] 节点在新树中不存在，跳过:', oldNode.title);
            return null;
        }
    }

    // 重建根节点
    const rebuiltRoot = rebuildNode(oldTree[0], [newTree[0]]);

    console.log('[树重建] 重建完成');
    return [rebuiltRoot];
}

// 从完整路径中提取父文件夹路径（去掉最后一级）
function getParentFolderPath(fullPath, lang = 'zh_CN') {
    if (!fullPath) return lang === 'zh_CN' ? '未知位置' : 'Unknown';

    // 分割路径（使用 ' > ' 作为分隔符）
    const parts = fullPath.split(' > ').filter(p => p.trim());

    // 如果只有一级（根目录），直接返回
    if (parts.length <= 1) {
        return lang === 'zh_CN' ? '根目录' : 'Root';
    }

    // 去掉最后一级（书签/文件夹自己的名称），保留父文件夹路径
    parts.pop();
    return parts.join(' > ');
}

// 智能检测父路径是否发生变化（重命名、移动、删除等）
// 返回 { originalPath, currentPath, hasChanges }
function detectParentPathChanges(fullOldPath, oldTree, newTree, lang = 'zh_CN') {
    const parentPath = getParentFolderPath(fullOldPath, lang);

    // 如果是根目录，不需要检测
    if (parentPath === '根目录' || parentPath === 'Root') {
        return {
            originalPath: parentPath,
            currentPath: null,
            hasChanges: false
        };
    }

    // 分解父路径中的文件夹名称
    const folderNames = parentPath.split(' > ').filter(p => p.trim());

    if (folderNames.length === 0) {
        return {
            originalPath: parentPath,
            currentPath: null,
            hasChanges: false
        };
    }

    // 在旧树中找到这些文件夹对应的ID
    const folderIds = findFolderIdsByPath(oldTree, folderNames);

    if (folderIds.length === 0) {
        return {
            originalPath: parentPath,
            currentPath: null,
            hasChanges: false
        };
    }

    // 检查这些文件夹在新树中的路径
    let hasChanges = false;
    const currentPaths = [];

    folderIds.forEach(folderId => {
        if (treeChangeMap && treeChangeMap.has(folderId)) {
            const change = treeChangeMap.get(folderId);
            // 如果文件夹被移动、重命名或删除
            if (change.type === 'moved' || change.type === 'modified' || change.type === 'deleted' ||
                change.type.includes('moved') || change.type.includes('modified')) {
                hasChanges = true;
            }
        }
    });

    // 如果有变化，构建当前路径
    let currentPath = null;
    if (hasChanges && newTree) {
        // 尝试在新树中找到最后一个文件夹（最深层的父文件夹）
        const lastFolderId = folderIds[folderIds.length - 1];
        currentPath = findNodePathInTree(newTree, lastFolderId);

        if (currentPath) {
            // 去掉最后一级（这是找到的文件夹自己）
            currentPath = getParentFolderPath(currentPath + ' > dummy', lang);
        }
    }

    return {
        originalPath: parentPath,
        currentPath: currentPath,
        hasChanges: hasChanges && currentPath && currentPath !== parentPath
    };
}

// 根据路径中的文件夹名称找到对应的ID
function findFolderIdsByPath(tree, folderNames) {
    const ids = [];

    if (!tree || !tree[0] || folderNames.length === 0) {
        return ids;
    }

    let currentNodes = [tree[0]];

    for (const folderName of folderNames) {
        let found = false;

        for (const node of currentNodes) {
            if (node.children) {
                const folder = node.children.find(child =>
                    child.title === folderName && !child.url
                );

                if (folder) {
                    ids.push(folder.id);
                    currentNodes = [folder];
                    found = true;
                    break;
                }
            }
        }

        if (!found) break;
    }

    return ids;
}

// 在树中根据ID找到节点的完整路径
function findNodePathInTree(tree, nodeId) {
    if (!tree || !tree[0]) return null;

    const path = [];

    function traverse(node, currentPath) {
        if (node.id === nodeId) {
            path.push(...currentPath, node.title);
            return true;
        }

        if (node.children) {
            for (const child of node.children) {
                if (traverse(child, [...currentPath, node.title])) {
                    return true;
                }
            }
        }

        return false;
    }

    if (traverse(tree[0], [])) {
        return path.join(' > ');
    }

    return null;
}

// 渲染带变动标记的树节点
// Helper to identify nodes that must be expanded because they contain changes
function computeForceExpandSet(nodes, changeMap) {
    const set = new Set();
    if (!nodes || !changeMap || changeMap.size === 0) return set;

    // Recursive check. Returns true if node or descendants have changes.
    const check = (node) => {
        if (!node) return false;
        let hasChange = changeMap.has(node.id);

        if (node.children) {
            node.children.forEach(child => {
                if (check(child)) {
                    hasChange = true;
                }
            });
        }

        // If this node or any child has changes, this node must be expanded/rendered
        // Note: we might want to distinguish between "render children" and "expand visually".
        // Here we put it in the set, meaning "override lazy loading stop".
        if (hasChange) {
            set.add(node.id);
        }
        return hasChange;
    };

    if (Array.isArray(nodes)) {
        nodes.forEach(node => check(node));
    } else {
        check(nodes);
    }
    return set;
}

function renderTreeNodeWithChanges(node, level = 0, maxDepth = 50, visitedIds = new Set(), forceExpandSet = null) {
    // 防止无限递归的保护机制
    const MAX_DEPTH = maxDepth;
    const MAX_NODES = 10000;

    if (!node) return '';
    if (level > MAX_DEPTH) {
        console.warn('[renderTreeNodeWithChanges] 超过最大深度限制:', level);
        return '';
    }

    // 检测循环引用
    if (visitedIds.has(node.id)) {
        console.warn('[renderTreeNodeWithChanges] 检测到循环引用:', node.id);
        return '';
    }
    visitedIds.add(node.id);

    if (visitedIds.size > MAX_NODES) {
        console.warn('[renderTreeNodeWithChanges] 超过最大节点限制');
        return '';
    }

    const change = treeChangeMap ? treeChangeMap.get(node.id) : null;
    let statusIcon = '';
    let changeClass = '';

    if (node.url) {
        // 叶子（书签）
        if (node.url) {
            const isExplicitMovedOnly = explicitMovedIds.has(node.id) && explicitMovedIds.get(node.id) > Date.now();
            const lazyHint = getCanvasLazyHintForBookmark(node);
            if (change) {
                if (change.type === 'added') {
                    changeClass = 'tree-change-added';
                    statusIcon = '<span class="change-badge added">+</span>';
                } else if (change.type === 'deleted') {
                    changeClass = 'tree-change-deleted';
                    statusIcon = '<span class="change-badge deleted">-</span>';
                } else {
                    const types = change.type.split('+');
                    const hasModified = types.includes('modified');
                    const isMoved = types.includes('moved');
                    const isExplicitMoved = isExplicitMovedOnly;

                    if (hasModified) {
                        changeClass = 'tree-change-modified';
                        statusIcon += '<span class="change-badge modified">~</span>';
                    }

                    // 移动标记：检测到 moved 类型就显示，不仅限于显式拖动
                    // isMoved 为 true 表示 detectTreeChangesFast 检测到了跨级移动
                    if (isMoved) {
                        // 如果既有modified又有moved，添加mixed类
                        if (hasModified) {
                            changeClass = 'tree-change-mixed';
                        } else {
                            changeClass = 'tree-change-moved';
                        }
                        {
                            let slash = '';
                            if (change.moved && change.moved.oldPath) {
                                slash = breadcrumbToSlashFolders(change.moved.oldPath);
                            }
                            if (!slash && cachedOldTree) {
                                const bc = getNamedPathFromTree(cachedOldTree, node.id);
                                slash = breadcrumbToSlashFolders(bc);
                            }
                            statusIcon += `<span class="change-badge moved" data-move-from="${escapeHtml(slash)}" title="${escapeHtml(slash)}"><i class="fas fa-arrows-alt"></i><span class="move-tooltip">${slashPathToChipsHTML(slash)}</span></span>`;
                        }
                    }
                }
            } else if (lazyHint) {
                if (lazyHint.type === 'added') {
                    changeClass = 'tree-change-added';
                    statusIcon = '<span class="change-badge added">+</span>';
                } else if (lazyHint.type === 'modified') {
                    changeClass = 'tree-change-modified';
                    statusIcon += '<span class="change-badge modified">~</span>';
                } else if (lazyHint.type === 'moved') {
                    changeClass = 'tree-change-moved';
                    const slash = formatFingerprintPathToSlash(lazyHint.oldPath || '');
                    statusIcon += `<span class="change-badge moved" data-move-from="${escapeHtml(slash)}" title="${escapeHtml(slash)}"><i class="fas fa-arrows-alt"></i><span class="move-tooltip">${slashPathToChipsHTML(slash)}</span></span>`;
                }
            } else if (isExplicitMovedOnly) {
                // 无 diff 记录但存在显式移动标识：也显示蓝色移动徽标
                changeClass = 'tree-change-moved';
                let slash = '';
                if (cachedOldTree) {
                    const bc = getNamedPathFromTree(cachedOldTree, node.id);
                    slash = breadcrumbToSlashFolders(bc);
                }
                statusIcon += `<span class="change-badge moved" data-move-from="${escapeHtml(slash)}" title="${escapeHtml(slash)}"><i class="fas fa-arrows-alt"></i><span class="move-tooltip">${slashPathToChipsHTML(slash)}</span></span>`;
            }
            const favicon = getFaviconUrl(node.url);
            return `
                <div class="tree-node">
                    <div class="tree-item ${changeClass}" data-node-id="${node.id}" data-node-title="${escapeHtml(node.title)}" data-node-url="${escapeHtml(node.url || '')}" data-node-type="bookmark" data-node-level="${level}" data-node-index="${typeof node.index === 'number' ? node.index : ''}">
                        <span class="tree-toggle" style="opacity: 0"></span>
                        ${favicon ? `<img class="tree-icon" src="${favicon}" alt="">` : `<i class="tree-icon fas fa-bookmark"></i>`}
                        <a href="${escapeHtml(node.url)}" target="_blank" class="tree-label tree-bookmark-link" rel="noopener noreferrer">${escapeHtml(node.title)}</a>
                        <span class="change-badges">${statusIcon}</span>
                    </div>
                </div>
            `;
        }
    }

    // 文件夹
    const __isExplicitMovedOnlyFolder = explicitMovedIds.has(node.id) && explicitMovedIds.get(node.id) > Date.now();
    if (change) {
        if (change.type === 'added') {
            changeClass = 'tree-change-added';
            statusIcon = '<span class="change-badge added">+</span>';
        } else if (change.type === 'deleted') {
            changeClass = 'tree-change-deleted';
            statusIcon = '<span class="change-badge deleted">-</span>';
        } else {
            const types = change.type.split('+');
            const hasModified = types.includes('modified');
            const isMoved = types.includes('moved');
            const isExplicitMoved = explicitMovedIds.has(node.id) && explicitMovedIds.get(node.id) > Date.now();

            if (hasModified) {
                changeClass = 'tree-change-modified';
                statusIcon += '<span class="change-badge modified">~</span>';
            }

            // 移动标记：检测到 moved 类型就显示，不仅限于显式拖动
            // isMoved 为 true 表示 detectTreeChangesFast 检测到了跨级移动
            if (isMoved) {
                // 如果既有modified又有moved，添加mixed类
                if (hasModified) {
                    changeClass = 'tree-change-mixed';
                } else {
                    changeClass = 'tree-change-moved';
                }
                {
                    let slash = '';
                    if (change.moved && change.moved.oldPath) {
                        slash = breadcrumbToSlashFolders(change.moved.oldPath);
                    }
                    if (!slash && cachedOldTree) {
                        const bc = getNamedPathFromTree(cachedOldTree, node.id);
                        slash = breadcrumbToSlashFolders(bc);
                    }
                    statusIcon += `<span class="change-badge moved" data-move-from="${escapeHtml(slash)}" title="${escapeHtml(slash)}"><i class="fas fa-arrows-alt"></i><span class="move-tooltip">${slashPathToChipsHTML(slash)}</span></span>`;
                }
            }
        }
    } else if (__isExplicitMovedOnlyFolder) {
        // 无 diff 记录但存在显式移动标识：也显示蓝色移动徽标
        changeClass = 'tree-change-moved';
        let slash = '';
        if (cachedOldTree) {
            const bc = getNamedPathFromTree(cachedOldTree, node.id);
            slash = breadcrumbToSlashFolders(bc);
        }
        statusIcon += `<span class="change-badge moved" data-move-from="${escapeHtml(slash)}" title="${escapeHtml(slash)}"><i class="fas fa-arrows-alt"></i><span class="move-tooltip">${slashPathToChipsHTML(slash)}</span></span>`;
    }

    // Canvas 视图性能：永久栏目采用懒加载，避免首次进入遍历/渲染整棵书签树
    // [Modified] If node is in forceExpandSet, we override lazy loading to show changes
    const shouldForceExpand = forceExpandSet && forceExpandSet.has(node.id);
    const isLazyStop = !shouldForceExpand && CANVAS_PERMANENT_TREE_LAZY_ENABLED && currentView === 'canvas' && level > 0;

    if (isLazyStop) {
        const childCount = Array.isArray(node.children) ? node.children.length : 0;
        const hasChildren = childCount > 0;
        return `
            <div class="tree-node">
                <div class="tree-item ${changeClass}" data-node-id="${node.id}" data-node-title="${escapeHtml(node.title)}" data-node-type="folder" data-node-level="${level}" data-has-children="${hasChildren ? 'true' : 'false'}" data-children-loaded="${hasChildren ? 'false' : 'true'}" data-node-index="${typeof node.index === 'number' ? node.index : ''}">
                    <span class="tree-toggle"><i class="fas fa-chevron-right"></i></span>
                    <i class="tree-icon fas fa-folder"></i>
                    <span class="tree-label">${escapeHtml(node.title)}</span>
                    <span class="change-badges">${statusIcon}</span>
                </div>
                <div class="tree-children"></div>
            </div>
        `;
    }

    // 若文件夹本身无变化，但其子树存在变化，追加灰色“指引”标识
    // 注意：Canvas 永久栏目懒加载模式下，禁止做整棵子树扫描（会导致首次进入严重卡顿）
    // [Modified] If we computed forceExpandSet, we already know about descendants, so we can allow logic (or use forceExpandSet check)
    // Actually, if we are here (not lazy stopped), we are either rendering recursively OR we are at root.
    // If we rely on hasDescendantChangesFast, it iterates immediate children. It is safe.
    // The previous check blocked it globally for Canvas. We allow it now if we are tracking changes.
    if (!change && (!CANVAS_PERMANENT_TREE_LAZY_ENABLED || currentView !== 'canvas' || treeChangeMap.size > 0)) {
        try {
            const hasDescendant = (function hasDescendantChangesFast(n) {
                if (!n || !Array.isArray(n.children) || n.children.length === 0) return false;
                const now = Date.now();
                const stack = [...n.children];
                while (stack.length) {
                    const cur = stack.pop();
                    if (!cur) continue;
                    if ((treeChangeMap && treeChangeMap.has(cur.id)) || (explicitMovedIds && explicitMovedIds.has(cur.id) && explicitMovedIds.get(cur.id) > now)) {
                        return true;
                    }
                    if (Array.isArray(cur.children) && cur.children.length) stack.push(...cur.children);
                }
                return false;
            })(node);
            if (hasDescendant) {
                const title = currentLang === 'zh_CN' ? '此文件夹下有变化' : 'Contains changes';
                statusIcon += `<span class=\"change-badge has-changes\" title=\"${escapeHtml(title)}\">•</span>`;
            }
        } catch (_) { /* ignore */ }
    }

    // 对子节点排序：
    // - 优先显示当前存在的节点（非 deleted），严格按 Chrome 的 index 升序
    // - 被标记为 deleted 的旧节点排在最后，按其旧 index 升序
    // - 缺少 index 的节点保持原始 children 数组中的相对顺序（稳定）
    const children = Array.isArray(node.children) ? node.children : [];
    const originalPos = new Map();
    for (let i = 0; i < children.length; i++) originalPos.set(children[i]?.id, i);

    const isDeleted = (n) => {
        if (!treeChangeMap) return false;
        const ch = treeChangeMap.get(n?.id);
        return !!(ch && ch.type === 'deleted');
    };

    const cmpStable = (a, b) => {
        const ia = (typeof a?.index === 'number') ? a.index : Number.POSITIVE_INFINITY;
        const ib = (typeof b?.index === 'number') ? b.index : Number.POSITIVE_INFINITY;
        if (ia !== ib) return ia - ib;
        // 稳定性：当 index 相同或缺失，按原始出现顺序
        const pa = originalPos.get(a?.id) ?? 0;
        const pb = originalPos.get(b?.id) ?? 0;
        return pa - pb;
    };

    // 保持删除标识在原位置显示：
    // rebuildTreeWithDeleted 已经按照旧树的顺序构建了children数组，
    // 删除的节点在数据层面不占位（不影响浏览器书签库），
    // 但在视觉层面保持原有位置
    const sortedChildren = children.slice().sort((a, b) => {
        const pa = originalPos.get(a?.id) ?? Number.POSITIVE_INFINITY;
        const pb = originalPos.get(b?.id) ?? Number.POSITIVE_INFINITY;
        return pa - pb;
    });

    return `
        <div class="tree-node">
            <div class="tree-item ${changeClass}" data-node-id="${node.id}" data-node-title="${escapeHtml(node.title)}" data-node-type="folder" data-node-level="${level}" data-has-children="${Array.isArray(node.children) && node.children.length ? 'true' : 'false'}" data-children-loaded="true" data-node-index="${typeof node.index === 'number' ? node.index : ''}">
                <span class="tree-toggle ${level === 0 ? 'expanded' : ''}"><i class="fas fa-chevron-right"></i></span>
                <i class="tree-icon fas fa-folder${level === 0 ? '-open' : ''}"></i>
                <span class="tree-label">${escapeHtml(node.title)}</span>
                <span class="change-badges">${statusIcon}</span>
            </div>
            <div class="tree-children ${level === 0 ? 'expanded' : ''}">
                ${sortedChildren.map(child => renderTreeNodeWithChanges(child, level + 1, maxDepth, visitedIds, forceExpandSet)).join('')}
            </div>
        </div>
    `;
}

// ===== 辅助函数：确保图例存在 =====
// 在增量更新时，如果图例不存在，则创建并插入到书签树顶部
function ensureTreeLegendExists(container) {
    if (!container) return;

    // 检查图例是否已存在
    const existingLegend = container.querySelector('.tree-legend');
    if (existingLegend) return; // 已存在，无需创建

    // 创建图例
    const legend = document.createElement('div');
    legend.className = 'tree-legend';
    const cursorStyle = 'cursor: pointer; user-select: none;';
    legend.innerHTML = `
        <span class="legend-item" data-change-type="added" style="${cursorStyle}" title="${currentLang === 'zh_CN' ? '点击查看新增项' : 'Click to view added items'}"><span class="legend-dot added"></span> ${currentLang === 'zh_CN' ? '新增' : 'Added'}</span>
        <span class="legend-item" data-change-type="deleted" style="${cursorStyle}" title="${currentLang === 'zh_CN' ? '点击查看删除项' : 'Click to view deleted items'}"><span class="legend-dot deleted"></span> ${currentLang === 'zh_CN' ? '删除' : 'Deleted'}</span>
        <span class="legend-item" data-change-type="moved" style="${cursorStyle}" title="${currentLang === 'zh_CN' ? '点击查看移动项' : 'Click to view moved items'}"><span class="legend-dot moved"></span> ${currentLang === 'zh_CN' ? '移动' : 'Moved'}</span>
        <span class="legend-item" data-change-type="modified" style="${cursorStyle}" title="${currentLang === 'zh_CN' ? '点击查看修改项' : 'Click to view modified items'}"><span class="legend-dot modified"></span> ${currentLang === 'zh_CN' ? '修改' : 'Modified'}</span>
    `;

    // 插入到容器顶部
    container.insertBefore(legend, container.firstChild);

    // 绑定点击事件
    setupLegendClickHandlers(container);

    console.log('[增量更新] 图例已创建');
}

// ===== 增量更新：创建 =====
async function applyIncrementalCreateToTree(id, bookmark) {
    const permBody = document.querySelector('.permanent-section-body');
    const permScrollTop = permBody ? permBody.scrollTop : null;
    const container = document.getElementById('bookmarkTree');
    if (!container) return;
    // 获取父节点 DOM
    const parentId = bookmark.parentId;
    if (!parentItem) {
        // 如果找不到父节点，说明父节点可能未渲染（懒加载），此时必须触发完整渲染
        // 以便 detectTreeChangesFast 能检测到变化并强制展开路径
        await renderTreeView(true);
        return;
    }
    if (!parentNode) {
        // 找不到子容器，触发重绘
        await renderTreeView(true);
        return;
    }
    // 生成新节点 HTML（添加绿色变更标记）
    const favicon = getFaviconUrl(bookmark.url || '');
    const labelColor = 'color: #28a745;'; // 绿色
    const labelFontWeight = 'font-weight: 500;';
    const html = `
        <div class="tree-node">
            <div class="tree-item tree-change-added" data-node-id="${id}" data-node-title="${escapeHtml(bookmark.title || '')}" data-node-url="${escapeHtml(bookmark.url || '')}" data-node-type="${bookmark.url ? 'bookmark' : 'folder'}">
                <span class="tree-toggle" style="opacity: 0"></span>
                ${bookmark.url ? (favicon ? `<img class="tree-icon" src="${favicon}" alt="">` : `<i class="tree-icon fas fa-bookmark"></i>`) : `<i class="tree-icon fas fa-folder"></i>`}
                ${bookmark.url ? `<a href="${escapeHtml(bookmark.url)}" target="_blank" class="tree-label tree-bookmark-link" rel="noopener noreferrer" style="${labelColor} ${labelFontWeight}">${escapeHtml(bookmark.title || '')}</a>` : `<span class="tree-label" style="${labelColor} ${labelFontWeight}">${escapeHtml(bookmark.title || '')}</span>`}
                <span class="change-badges"><span class="change-badge added">+</span></span>
            </div>
            ${bookmark.url ? '' : '<div class="tree-children"></div>'}
        </div>
    `;
    // 插入到正确的 index 位置（忽略已删除的占位项）
    const wrapper = document.createElement('div');
    wrapper.innerHTML = html;
    const newNodeEl = wrapper.firstElementChild; // .tree-node

    // 计算锚点：仅统计未被标记为删除的同级节点
    const siblingsAll = Array.from(parentNode.querySelectorAll(':scope > .tree-node'));
    const presentSiblings = siblingsAll.filter(n => {
        const item = n.querySelector(':scope > .tree-item');
        return !(item && item.classList.contains('tree-change-deleted'));
    });

    const targetIndex = (typeof bookmark.index === 'number' && bookmark.index >= 0)
        ? bookmark.index : presentSiblings.length;

    const anchor = presentSiblings[targetIndex] || null;
    if (anchor) {
        parentNode.insertBefore(newNodeEl, anchor);
    } else {
        // 末尾插入：尽量插在第一个已删除节点之前，避免落到删除分组之后
        const firstDeleted = siblingsAll.find(n => n.querySelector(':scope > .tree-item')?.classList.contains('tree-change-deleted'));
        if (firstDeleted) parentNode.insertBefore(newNodeEl, firstDeleted); else parentNode.appendChild(newNodeEl);
    }

    // 为新创建的节点绑定事件
    const newItem = newNodeEl?.querySelector('.tree-item');
    if (newItem) {
        // 绑定右键菜单
        newItem.addEventListener('contextmenu', (e) => {
            if (typeof showContextMenu === 'function') {
                showContextMenu(e, newItem);
            }
        });

        // 绑定拖拽事件
        if (typeof attachDragEvents === 'function') {
            attachDragEvents(container);
        }

        // 如果在Canvas视图，绑定Canvas拖出功能
        if (currentView === 'canvas' && window.CanvasModule && window.CanvasModule.enhance) {
            window.CanvasModule.enhance();
        }
    }
    // 确保图例存在
    ensureTreeLegendExists(container);
    // 恢复滚动位置
    if (permBody && permScrollTop !== null) permBody.scrollTop = permScrollTop;
}

// ===== 增量更新：删除 =====
function applyIncrementalRemoveFromTree(id) {
    const permBody = document.querySelector('.permanent-section-body');
    const permScrollTop = permBody ? permBody.scrollTop : null;
    const container = document.getElementById('bookmarkTree');
    if (!container) return;
    const item = container.querySelector(`.tree-item[data-node-id="${id}"]`);
    if (!item) {
        // 如果找不到节点（可能是Canvas懒加载隐藏的），强制刷新以更新父级状态
        renderTreeView(true).catch(e => console.error(e));
        return;
    }

    // 先添加红色标识和删除类
    item.classList.add('tree-change-deleted');

    // 直接设置标签的红色样式
    const labelLink = item.querySelector('.tree-bookmark-link');
    const labelSpan = item.querySelector('.tree-label');
    if (labelLink) {
        labelLink.style.color = '#dc3545';
        labelLink.style.fontWeight = '500';
        labelLink.style.textDecoration = 'line-through';
        labelLink.style.opacity = '0.7';
    }
    if (labelSpan) {
        labelSpan.style.color = '#dc3545';
        labelSpan.style.fontWeight = '500';
        labelSpan.style.textDecoration = 'line-through';
        labelSpan.style.opacity = '0.7';
    }

    // 添加红色标识
    const badges = item.querySelector('.change-badges');
    if (badges) {
        badges.innerHTML = '<span class="change-badge deleted">-</span>';
    } else {
        item.insertAdjacentHTML('beforeend', '<span class="change-badges"><span class="change-badge deleted">-</span></span>');
    }

    // 保持删除标识在原位显示，不自动移除节点
    // 用户可以通过"清理变动标识"功能来清除这些已删除的项目
    // 确保图例存在
    ensureTreeLegendExists(container);
    // 恢复滚动位置
    if (permBody && permScrollTop !== null) permBody.scrollTop = permScrollTop;
}

// ===== 增量更新：修改 =====
async function applyIncrementalChangeToTree(id, changeInfo) {
    const permBody = document.querySelector('.permanent-section-body');
    const permScrollTop = permBody ? permBody.scrollTop : null;
    const container = document.getElementById('bookmarkTree');
    if (!container) return;
    const item = container.querySelector(`.tree-item[data-node-id="${id}"]`);
    if (!item) {
        // 找不到节点（懒加载），触发重绘以确保变化可见
        await renderTreeView(true);
        return;
    }

    console.log('[applyIncrementalChangeToTree] 修改书签:', id, changeInfo);

    // 添加修改类
    if (!item.classList.contains('tree-change-modified')) {
        item.classList.add('tree-change-modified');
    }

    // 总是确保橙色样式被应用（即使已经修改过）- 使用!important强制应用
    const labelLink = item.querySelector('.tree-bookmark-link');
    const labelSpan = item.querySelector('.tree-label');

    console.log('[applyIncrementalChangeToTree] labelLink:', !!labelLink, 'labelSpan:', !!labelSpan);

    if (labelLink) {
        labelLink.style.setProperty('color', '#fd7e14', 'important');
        labelLink.style.setProperty('font-weight', '500', 'important');
        console.log('[applyIncrementalChangeToTree] 已设置labelLink样式');
    }
    if (labelSpan) {
        labelSpan.style.setProperty('color', '#fd7e14', 'important');
        labelSpan.style.setProperty('font-weight', '500', 'important');
        console.log('[applyIncrementalChangeToTree] 已设置labelSpan样式');
    }

    // 修改内容
    if (changeInfo.title) {
        if (labelLink) labelLink.textContent = changeInfo.title;
        if (labelSpan) labelSpan.textContent = changeInfo.title;
        item.setAttribute('data-node-title', escapeHtml(changeInfo.title));
        console.log('[applyIncrementalChangeToTree] 已修改标题:', changeInfo.title);
    }
    if (changeInfo.url !== undefined) {
        const link = item.querySelector('.tree-bookmark-link');
        if (link) link.href = changeInfo.url || '';
        const icon = item.querySelector('img.tree-icon');
        if (icon) {
            const fav = getFaviconUrl(changeInfo.url || '');
            if (fav) icon.src = fav;
        }
        item.setAttribute('data-node-url', escapeHtml(changeInfo.url || ''));
    }

    // 给该节点增加"modified"标识
    const badges = item.querySelector('.change-badges');
    if (badges && !badges.querySelector('.modified')) {
        badges.insertAdjacentHTML('beforeend', '<span class="change-badge modified">~</span>');
    }
    // 确保图例存在
    ensureTreeLegendExists(container);
    // 恢复滚动位置
    if (permBody && permScrollTop !== null) permBody.scrollTop = permScrollTop;
}

// ===== 增量更新：移动 =====
async function applyIncrementalMoveToTree(id, moveInfo) {
    console.log('[增量移动] 开始处理:', id, moveInfo);

    const permBody = document.querySelector('.permanent-section-body');
    const permScrollTop = permBody ? permBody.scrollTop : null;
    const container = document.getElementById('bookmarkTree');
    if (!container) return;
    const item = container.querySelector(`.tree-item[data-node-id="${id}"]`);
    if (!item) {
        // 在 Canvas 懒加载模式下，节点可能未渲染，需要触发刷新以显示变化标识
        // 只有在拖拽操作不是由本地 dragMoveHandled 集合处理时才触发刷新
        const isDragHandled = window.__dragMoveHandled && window.__dragMoveHandled.has(id);
        if (!isDragHandled) {
            // 检查是否是 Canvas 懒加载模式
            const isCanvasLazyMode = currentView === 'canvas' && CANVAS_PERMANENT_TREE_LAZY_ENABLED;
            if (isCanvasLazyMode) {
                // 懒加载模式下节点未渲染，需要刷新以显示标识（使用 log 级别避免报错干扰）
                console.log('[增量移动] Canvas懒加载模式，节点未渲染，触发刷新以显示标识:', id);
            } else {
                // 非懒加载模式下找不到节点
                console.log('[增量移动] 找不到节点，触发刷新以更新视图');
            }
            renderTreeView(true).catch(e => console.error(e));
        }
        return;
    }
    const node = item.closest('.tree-node');
    const oldParentItem = container.querySelector(`.tree-item[data-node-id="${moveInfo.oldParentId}"]`);
    const newParentItem = container.querySelector(`.tree-item[data-node-id="${moveInfo.parentId}"]`);
    const newParentChildren = newParentItem && newParentItem.nextElementSibling && newParentItem.nextElementSibling.classList.contains('tree-children')
        ? newParentItem.nextElementSibling : null;

    if (!newParentChildren) {
        // 如果找不到新父容器但节点有移动标记，说明即时更新已处理，只需添加徽标
        if (item.classList.contains('tree-change-moved')) {
            console.log('[增量移动] 节点已有移动标记，跳过DOM操作');
            if (permBody && permScrollTop !== null) permBody.scrollTop = permScrollTop;
            return;
        }
        console.warn('[增量移动] 找不到新父容器，跳过');
        return;
    }

    // 关键修复：同一父级内的“排序移动”时，node 仍在 newParentChildren 里，但位置需要更新。
    // 之前的 alreadyInPlace 逻辑会直接跳过，导致移动后视觉不跟随（只能依赖全量 renderTreeView 修正）。
    if (!node) {
        console.warn('[增量移动] 找不到tree-node容器，跳过');
        return;
    }
    // 从旧位置移除并插入新父下（即使同父级也需要重排）
    try {
        if (node.parentNode) node.parentNode.removeChild(node);
    } catch (_) { /* ignore */ }

    // 按目标 index 插入更准确（忽略已删除的同级节点）
    const targetIndex = (moveInfo && typeof moveInfo.index === 'number') ? moveInfo.index : null;
    const siblingsAll = Array.from(newParentChildren.querySelectorAll(':scope > .tree-node'));
    const presentSiblings = siblingsAll.filter(n => !n.querySelector(':scope > .tree-item')?.classList.contains('tree-change-deleted'));

    if (targetIndex === null) {
        // 尽量插在第一个已删除节点之前
        const firstDeleted = siblingsAll.find(n => n.querySelector(':scope > .tree-item')?.classList.contains('tree-change-deleted'));
        if (firstDeleted) newParentChildren.insertBefore(node, firstDeleted);
        else newParentChildren.appendChild(node);
    } else {
        const safeIndex = Math.max(0, targetIndex);
        const anchor = presentSiblings[safeIndex] || null;
        if (anchor) newParentChildren.insertBefore(node, anchor);
        else {
            const firstDeleted = siblingsAll.find(n => n.querySelector(':scope > .tree-item')?.classList.contains('tree-change-deleted'));
            if (firstDeleted) newParentChildren.insertBefore(node, firstDeleted);
            else newParentChildren.appendChild(node);
        }
    }

    // 注意：缩进由 DOM 结构（.tree-children 的 margin-left）自动决定。
    // 这里不要给 .tree-node 设 padding-left，否则会导致“放手瞬间层级不对齐”的视觉问题。
    // 清理历史遗留的 padding-left（旧版本曾写入），避免刷新前后出现“对齐忽然变正常/又异常”的错觉。
    try {
        if (node && node.style) node.style.paddingLeft = '';
        // 仅清理确实带有 padding-left 的节点，避免无谓遍历
        node.querySelectorAll('.tree-node[style*="padding-left"]').forEach(n => {
            try { n.style.paddingLeft = ''; } catch (_) { }
        });
    } catch (_) { /* ignore */ }

    // 如果已经有移动标记（由即时更新处理），跳过徽标添加
    if (item.classList.contains('tree-change-moved') && item.querySelector('.change-badge.moved')) {
        console.log('[增量移动] 节点已有移动徽标，跳过');
        if (permBody && permScrollTop !== null) permBody.scrollTop = permScrollTop;
        return;
    }

    // 关键：仅对这个被拖拽的节点标记为蓝色"moved"
    // 其他由于这次移动而位置改变的兄弟节点不标记，因为我们只标识用户直接操作的对象
    let badges = item.querySelector('.change-badges');
    if (!badges) {
        item.insertAdjacentHTML('beforeend', '<span class="change-badges"></span>');
        badges = item.querySelector('.change-badges');
    }
    if (badges) {
        const existing = badges.querySelector('.change-badge.moved');
        if (existing) existing.remove();
        // 计算旧位置（名称路径）：优先用旧父ID从旧树取父路径；回退为旧树中该节点路径的父级
        let tip = '';
        if (cachedOldTree && moveInfo && typeof moveInfo.oldParentId !== 'undefined') {
            const bcParent = getNamedPathFromTree(cachedOldTree, String(moveInfo.oldParentId));
            if (bcParent) tip = breadcrumbToSlashFull(bcParent);
        }
        if (!tip && cachedOldTree) {
            const bcSelf = getNamedPathFromTree(cachedOldTree, id);
            if (bcSelf) tip = breadcrumbToSlashFolders(bcSelf);
        }
        if (!tip) tip = '/';
        badges.insertAdjacentHTML('beforeend', `<span class="change-badge moved" data-move-from="${escapeHtml(tip)}" title="${escapeHtml(tip)}"><i class="fas fa-arrows-alt"></i><span class="move-tooltip">${slashPathToChipsHTML(tip)}</span></span>`);
        item.classList.add('tree-change-moved');

        // 设置蓝色样式
        const labelLink = item.querySelector('.tree-bookmark-link');
        const labelSpan = item.querySelector('.tree-label');
        if (labelLink) {
            labelLink.style.setProperty('color', '#007bff', 'important');
            labelLink.style.setProperty('font-weight', '500', 'important');
        }
        if (labelSpan) {
            labelSpan.style.setProperty('color', '#007bff', 'important');
            labelSpan.style.setProperty('font-weight', '500', 'important');
        }
    }
    // 确保图例存在
    ensureTreeLegendExists(container);
    // 恢复滚动位置
    if (permBody && permScrollTop !== null) permBody.scrollTop = permScrollTop;
}



// =============================================================================
// 详情弹窗
// =============================================================================

/**
 * 获取指定记录的视图模式
 * @param {string} recordTime - 记录时间戳
 * @returns {string} 'simple' 或 'detailed'
 */
function getRecordDetailMode(recordTime) {
    if (!recordTime) return historyDetailMode || 'simple';
    // 从统一存储对象中读取
    if (historyViewSettings && historyViewSettings.recordModes) {
        const mode = historyViewSettings.recordModes[String(recordTime)];
        if (mode) return mode;
    }
    return historyDetailMode || 'simple';
}

/**
 * 设置指定记录的视图模式（异步保存到 chrome.storage.local）
 * @param {string} recordTime - 记录时间戳
 * @param {string} mode - 'simple' 或 'detailed'
 */
function setRecordDetailMode(recordTime, mode) {
    if (!recordTime || !mode) return;
    // 确保 historyViewSettings 已初始化
    if (!historyViewSettings) {
        historyViewSettings = { defaultMode: 'simple', recordModes: {}, recordExpandedStates: {} };
    }
    historyViewSettings.recordModes[String(recordTime)] = mode;
    // 异步保存（带防抖）
    saveHistoryViewSettings();
}

/**
 * 检查指定记录是否有保存的展开状态
 * @param {string} recordTime - 记录时间戳
 * @returns {boolean}
 */
function hasRecordExpandedState(recordTime) {
    if (!recordTime) return false;
    if (historyViewSettings && historyViewSettings.recordExpandedStates) {
        return historyViewSettings.recordExpandedStates[String(recordTime)] != null;
    }
    return false;
}

/**
 * 获取指定记录的展开状态
 * @param {string} recordTime - 记录时间戳
 * @returns {Set<string>} 展开的节点 ID 集合
 */
function getRecordExpandedState(recordTime) {
    if (!recordTime) return new Set();
    if (historyViewSettings && historyViewSettings.recordExpandedStates) {
        const ids = historyViewSettings.recordExpandedStates[String(recordTime)];
        if (Array.isArray(ids)) {
            return new Set(ids.map(id => String(id)));
        }
    }
    return new Set();
}

/**
 * 保存单个节点的展开状态变化（WYSIWYG）
 * @param {string} recordTime - 记录时间戳
 * @param {string} nodeId - 节点 ID
 * @param {boolean} isExpanded - 是否展开
 */
function saveRecordExpandedState(recordTime, nodeId, isExpanded) {
    if (!recordTime || !nodeId) return;
    // 确保 historyViewSettings 已初始化
    if (!historyViewSettings) {
        historyViewSettings = { defaultMode: 'simple', recordModes: {}, recordExpandedStates: {} };
    }
    if (!historyViewSettings.recordExpandedStates) {
        historyViewSettings.recordExpandedStates = {};
    }

    const timeKey = String(recordTime);
    const currentIds = historyViewSettings.recordExpandedStates[timeKey] || [];
    const ids = new Set(Array.isArray(currentIds) ? currentIds.map(id => String(id)) : []);
    const idStr = String(nodeId);

    if (isExpanded) {
        ids.add(idStr);
    } else {
        ids.delete(idStr);
    }

    historyViewSettings.recordExpandedStates[timeKey] = Array.from(ids);
    // 异步保存（带防抖）
    saveHistoryViewSettings();
}

/**
 * 捕获当前树容器的展开状态并保存（WYSIWYG）
 * @param {string} recordTime - 记录时间戳
 * @param {HTMLElement} treeContainer - 树容器元素
 */
function captureRecordExpandedState(recordTime, treeContainer) {
    if (!recordTime || !treeContainer) return;
    // 确保 historyViewSettings 已初始化
    if (!historyViewSettings) {
        historyViewSettings = { defaultMode: 'simple', recordModes: {}, recordExpandedStates: {} };
    }
    if (!historyViewSettings.recordExpandedStates) {
        historyViewSettings.recordExpandedStates = {};
    }

    const expandedIds = [];
    treeContainer.querySelectorAll('.tree-item[data-node-id]').forEach(item => {
        const nodeId = item.getAttribute('data-node-id');
        if (!nodeId) return;
        const treeNode = item.closest('.tree-node');
        const children = treeNode?.querySelector(':scope > .tree-children');
        if (children && children.classList.contains('expanded')) {
            expandedIds.push(String(nodeId));
        }
    });

    historyViewSettings.recordExpandedStates[String(recordTime)] = expandedIds;
    // 异步保存（带防抖）
    saveHistoryViewSettings();
}

function applyRecordExpandedState(recordTime, treeContainer) {
    if (!recordTime || !treeContainer) return;
    const expandedIds = getRecordExpandedState(recordTime);
    if (!expandedIds.size) return;

    // 重置所有展开状态
    treeContainer.querySelectorAll('.tree-children').forEach(children => {
        children.classList.remove('expanded');
    });
    treeContainer.querySelectorAll('.tree-toggle').forEach(toggle => {
        toggle.classList.remove('expanded');
    });
    treeContainer.querySelectorAll('.tree-item[data-node-type="folder"] .tree-icon.fa-folder-open').forEach(icon => {
        icon.classList.remove('fa-folder-open');
        icon.classList.add('fa-folder');
    });

    const expandItem = (item) => {
        const treeNode = item?.closest('.tree-node');
        const children = treeNode?.querySelector(':scope > .tree-children');
        const toggle = item?.querySelector('.tree-toggle:not([style*="opacity: 0"])');
        if (children && toggle) {
            children.classList.add('expanded');
            toggle.classList.add('expanded');
            const folderIcon = item.querySelector('.tree-icon.fa-folder, .tree-icon.fa-folder-open');
            if (folderIcon) {
                folderIcon.classList.remove('fa-folder');
                folderIcon.classList.add('fa-folder-open');
            }
        }
    };

    const expandParents = (item) => {
        let parent = item?.closest('.tree-children');
        while (parent) {
            parent.classList.add('expanded');
            const parentItem = parent.previousElementSibling;
            if (parentItem && parentItem.classList.contains('tree-item')) {
                const parentToggle = parentItem.querySelector('.tree-toggle');
                if (parentToggle) parentToggle.classList.add('expanded');
                const parentIcon = parentItem.querySelector('.tree-icon.fa-folder, .tree-icon.fa-folder-open');
                if (parentIcon) {
                    parentIcon.classList.remove('fa-folder');
                    parentIcon.classList.add('fa-folder-open');
                }
            }
            parent = parent.parentElement ? parent.parentElement.closest('.tree-children') : null;
        }
    };

    treeContainer.querySelectorAll('.tree-item[data-node-id]').forEach(item => {
        const nodeId = item.getAttribute('data-node-id');
        if (!nodeId || !expandedIds.has(String(nodeId))) return;
        expandParents(item);
        expandItem(item);
    });
}

function updateDetailModalToggleUI(mode) {
    const simpleBtn = document.getElementById('historyDetailModeSimpleModal');
    const detailedBtn = document.getElementById('historyDetailModeDetailedModal');
    if (!simpleBtn || !detailedBtn) return;

    if (mode === 'detailed') {
        simpleBtn.classList.remove('active');
        detailedBtn.classList.add('active');
    } else {
        simpleBtn.classList.add('active');
        detailedBtn.classList.remove('active');
    }
}


function updateHistoryListItemMode(recordTime, mode) {
    const item = document.querySelector(`.commit-item[data-record-time="${recordTime}"]`);
    if (!item) return;

    const tooltip = item.querySelector('.action-btn.detail-btn .btn-tooltip');
    if (!tooltip) return;
    tooltip.textContent = mode === 'simple'
        ? (currentLang === 'zh_CN' ? '简略' : 'Simple')
        : (currentLang === 'zh_CN' ? '详细' : 'Detailed');
}

function initDetailModalActions() {
    const simpleBtn = document.getElementById('historyDetailModeSimpleModal');
    const detailedBtn = document.getElementById('historyDetailModeDetailedModal');
    const exportBtn = document.getElementById('detailExportChangesBtn');

    if (simpleBtn && !simpleBtn.hasAttribute('data-listener-attached')) {
        simpleBtn.addEventListener('click', () => {
            if (!currentDetailRecordTime) return;
            if (currentDetailRecordMode === 'simple') return;
            currentDetailRecordMode = 'simple';
            setRecordDetailMode(currentDetailRecordTime, 'simple');
            updateDetailModalToggleUI('simple');
            updateHistoryListItemMode(currentDetailRecordTime, 'simple');
            if (currentDetailRecord) renderDetailModalContent(currentDetailRecord, 'simple');
        });
        simpleBtn.setAttribute('data-listener-attached', 'true');
    }

    if (detailedBtn && !detailedBtn.hasAttribute('data-listener-attached')) {
        detailedBtn.addEventListener('click', () => {
            if (!currentDetailRecordTime) return;
            if (currentDetailRecordMode === 'detailed') return;
            currentDetailRecordMode = 'detailed';
            setRecordDetailMode(currentDetailRecordTime, 'detailed');
            updateDetailModalToggleUI('detailed');
            updateHistoryListItemMode(currentDetailRecordTime, 'detailed');
            if (currentDetailRecord) renderDetailModalContent(currentDetailRecord, 'detailed');
        });
        detailedBtn.setAttribute('data-listener-attached', 'true');
    }

    if (exportBtn && !exportBtn.hasAttribute('data-listener-attached')) {
        exportBtn.addEventListener('click', () => {
            if (!currentDetailRecord) return;
            const treeContainer = document.querySelector('#modalBody .history-tree-container');
            showHistoryExportChangesModal(currentDetailRecord.time, {
                preferredMode: currentDetailRecordMode || getRecordDetailMode(currentDetailRecord.time),
                useDomTreeContainer: true,
                treeContainer
            });
        });
        exportBtn.setAttribute('data-listener-attached', 'true');
    }
}

function renderDetailModalContent(record, mode) {
    const body = document.getElementById('modalBody');
    if (!body) return;

    body.innerHTML = `<div class="loading">${i18n.loading[currentLang]}</div>`;

    generateDetailContent(record, mode).then(html => {
        body.innerHTML = html;

        setTimeout(() => {
            initDetailModalActions();
            updateDetailModalToggleUI(mode);
            const treeContainer = body.querySelector('.history-tree-container');
            if (treeContainer) {
                if (mode === 'detailed') {
                    if (hasRecordExpandedState(record.time)) {
                        applyRecordExpandedState(record.time, treeContainer);
                    } else {
                        captureRecordExpandedState(record.time, treeContainer);
                    }
                }

                treeContainer.addEventListener('click', (e) => {
                    const treeItem = e.target.closest('.tree-item');
                    if (!treeItem) return;

                    // 允许链接点击
                    if (e.target.closest('a')) return;

                    // 展开/折叠
                    const treeNode = treeItem.closest('.tree-node');
                    const children = treeNode?.querySelector('.tree-children');
                    const toggle = treeItem.querySelector('.tree-toggle:not([style*="opacity: 0"])');

                    if (children && toggle) {
                        const isExpanding = !children.classList.contains('expanded');
                        toggle.classList.toggle('expanded');
                        children.classList.toggle('expanded');

                        // 更新文件夹图标
                        const folderIcon = treeItem.querySelector('.tree-icon.fa-folder, .tree-icon.fa-folder-open');
                        if (folderIcon) {
                            if (isExpanding) {
                                folderIcon.classList.remove('fa-folder');
                                folderIcon.classList.add('fa-folder-open');
                            } else {
                                folderIcon.classList.remove('fa-folder-open');
                                folderIcon.classList.add('fa-folder');
                            }
                        }

                        if (mode === 'detailed') {
                            const nodeId = treeItem.getAttribute('data-node-id');
                            if (nodeId) saveRecordExpandedState(record.time, nodeId, isExpanding);
                        }
                    }
                });
            }

            // 兼容旧的 hunk 折叠事件监听
            body.querySelectorAll('.diff-hunk-header.collapsible').forEach(header => {
                const hunkId = header.getAttribute('data-hunk-id');
                if (hunkId) {
                    header.addEventListener('click', function () {
                        toggleHunk(hunkId);
                    });
                }
            });

            body.querySelectorAll('.commit-note-edit-btn').forEach(btn => {
                if (btn.hasAttribute('data-listener-attached')) return;
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    await editCommitNote(record.time);
                    const updatedRecord = syncHistory.find(r => r.time === record.time);
                    if (updatedRecord) {
                        currentDetailRecord = updatedRecord;
                        renderDetailModalContent(updatedRecord, currentDetailRecordMode || getRecordDetailMode(record.time));
                    }
                });
                btn.setAttribute('data-listener-attached', 'true');
            });
        }, 0);
    }).catch(error => {
        console.error('[详情弹窗] 生成失败:', error);
        body.innerHTML = `<div class="detail-empty"><i class="fas fa-exclamation-circle"></i>加载失败: ${escapeHtml(error && error.message ? error.message : String(error))}</div>`;
    });
}

function showDetailModal(record) {
    const modal = document.getElementById('detailModal');

    // 保存当前打开的记录时间，用于关闭时滚动
    currentDetailRecordTime = record.time;
    currentDetailRecord = record;
    currentDetailRecordMode = getRecordDetailMode(record.time);

    updateDetailModalToggleUI(currentDetailRecordMode);

    const exportBtn = document.getElementById('detailExportChangesBtn');
    if (exportBtn) {
        exportBtn.title = currentLang === 'zh_CN' ? '导出变化' : 'Export Changes';
    }

    modal.classList.add('show');

    renderDetailModalContent(record, currentDetailRecordMode);
}

function closeModal() {
    document.getElementById('detailModal').classList.remove('show');

    // 关闭时，如果有打开的记录，滚动到该记录并使其居中，并闪烁突出显示
    if (currentDetailRecordTime) {
        // 延迟执行以确保DOM已更新
        setTimeout(() => {
            const recordElement = document.querySelector(`[data-record-time="${currentDetailRecordTime}"]`);
            if (recordElement) {
                // 滚动到该元素并使其在视口中央
                recordElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // 添加呼吸效果的蓝色闪烁（1次）
                const originalBackground = recordElement.style.backgroundColor;

                // 设置缓慢平滑的过渡
                recordElement.style.transition = 'background-color 0.8s ease-in-out, box-shadow 0.8s ease-in-out';

                // 显示蓝色框（呼吸效果 - 淡入）
                recordElement.style.backgroundColor = 'rgba(0, 122, 255, 0.25)';
                recordElement.style.boxShadow = '0 0 0 2px #007AFF inset';

                // 1秒后开始淡出
                setTimeout(() => {
                    recordElement.style.backgroundColor = originalBackground;
                    recordElement.style.boxShadow = 'none';

                    // 淡出完成后重置transition
                    setTimeout(() => {
                        recordElement.style.transition = '';
                    }, 800);
                }, 1200);
            }
            currentDetailRecordTime = null;
            currentDetailRecord = null;
            currentDetailRecordMode = null;
        }, 100);
    }
}

// =============================================================================
// 书签恢复功能
// =============================================================================

let currentRestoreRecord = null; // 当前要恢复的记录

/**
 * 计算节点统计信息 (书签数和文件夹数)
 */
function calculateNodeStats(nodes) {
    let stats = { bookmarks: 0, folders: 0 };
    if (!nodes) return stats;

    // Check if it's an array (root) or single node
    const list = Array.isArray(nodes) ? nodes : [nodes];

    for (const node of list) {
        if (node.children) {
            // Include root node and system folders to match background.js counting logic
            // (background.js countAllFolders counts any node with children and no url)
            stats.folders++;
            const childStats = calculateNodeStats(node.children);
            stats.bookmarks += childStats.bookmarks;
            stats.folders += childStats.folders;
        } else {
            // It's a bookmark
            stats.bookmarks++;
        }
    }
    return stats;
}

/**
 * 显示恢复确认模态框
 * @param {Object} record - 要恢复的备份记录
 */
// =============================================================================
// 书签 Diff 辅助函数 (移植自 background.js)
// =============================================================================

function buildTreeIndexForDiff(tree) {
    const nodes = new Map();
    const byParent = new Map();

    const traverse = (node, parentId = null) => {
        if (!node || !node.id) return;

        const record = {
            id: node.id,
            title: node.title || '',
            url: node.url,
            parentId: node.parentId || parentId,
            index: typeof node.index === 'number' ? node.index : null
        };

        nodes.set(record.id, record);

        if (record.parentId) {
            if (!byParent.has(record.parentId)) byParent.set(record.parentId, []);
            byParent.get(record.parentId).push({ id: record.id, index: record.index });
        }

        if (Array.isArray(node.children)) {
            for (const child of node.children) {
                traverse(child, node.id);
            }
        }
    };

    if (Array.isArray(tree) && tree[0]) {
        traverse(tree[0], null);
    }

    // 保证同父级列表按 index 排序（稳定对比）
    for (const list of byParent.values()) {
        list.sort((a, b) => {
            const ai = typeof a.index === 'number' ? a.index : 0;
            const bi = typeof b.index === 'number' ? b.index : 0;
            return ai - bi;
        });
    }

    return { nodes, byParent };
}

function computeBookmarkGitDiffSummary(oldTree, newTree, options = {}) {
    const explicitMovedIds = options.explicitMovedIds instanceof Set ? options.explicitMovedIds : null;

    const summary = {
        bookmarkAdded: 0,
        bookmarkDeleted: 0,
        folderAdded: 0,
        folderDeleted: 0,
        movedCount: 0,
        modifiedCount: 0,
        movedBookmarkCount: 0,
        movedFolderCount: 0,
        modifiedBookmarkCount: 0,
        modifiedFolderCount: 0,
        bookmarkMoved: false,
        folderMoved: false,
        bookmarkModified: false,
        folderModified: false
    };

    if (!Array.isArray(oldTree) || !Array.isArray(newTree) || !oldTree[0] || !newTree[0]) {
        return summary;
    }

    const oldIndex = buildTreeIndexForDiff(oldTree);
    const newIndex = buildTreeIndexForDiff(newTree);

    const addedIds = new Set();
    const deletedIds = new Set();
    const modifiedIds = new Set();
    const movedIds = new Set();
    const crossParentMovedIds = new Set();

    // 新增 / 修改 / 跨级移动
    for (const [id, n] of newIndex.nodes.entries()) {
        const o = oldIndex.nodes.get(id);
        if (!o) {
            addedIds.add(id);
            continue;
        }

        const isFolder = !n.url;
        const isModified = isFolder ? (o.title !== n.title) : (o.title !== n.title || o.url !== n.url);
        if (isModified) modifiedIds.add(id);

        const crossMove = o.parentId !== n.parentId;
        if (crossMove) {
            movedIds.add(id);
            crossParentMovedIds.add(id);
        }
    }

    // 删除
    for (const id of oldIndex.nodes.keys()) {
        if (!newIndex.nodes.has(id)) deletedIds.add(id);
    }

    // =========================================================================
    // 智能修正：基于内容（URL）的节点匹配
    // 解决因 Re-import 或 Sync 导致 ID 变更，从而被误判为“全部删除+全部新增”的问题
    // =========================================================================
    const urlToDeletedId = new Map();
    for (const id of deletedIds) {
        const node = oldIndex.nodes.get(id);
        if (node && node.url) { // 仅匹配书签，文件夹重名概率太高
            urlToDeletedId.set(node.url, id);
        }
    }

    const reconciledAddedIds = new Set();

    for (const id of addedIds) {
        const newNode = newIndex.nodes.get(id);
        if (!newNode || !newNode.url) continue;

        const oldId = urlToDeletedId.get(newNode.url);
        if (oldId) {
            // 找到 URL 相同的“已删除”节点 -> 视为同一节点
            const oldNode = oldIndex.nodes.get(oldId);

            // 1. 它是匹配节点，不再是新增/删除
            reconciledAddedIds.add(id);
            deletedIds.delete(oldId);
            // 注意：此时还需要从 addedIds 中移除（循环后处理）

            // 既然匹配了，我们还需要修正“跨级移动”判定
            // 原有逻辑是基于 ID 相同的。现在 ID 不同，我们需要用新 ID 重新判定 Modify 和 Move

            // 2. 检测修改 (Title)
            if (oldNode.title !== newNode.title) {
                modifiedIds.add(id);
            }

            // 3. 检测移动 (Parent)
            // 由于 ID 体系可能完全不同，我们不能简单比较 parentId
            // 策略：比较 Parent 的 Title。如果 Parent Title 相同，视为未移动。
            // (这只是一个启发式策略，但在 Restore 预览场景下足够有效)
            const oldParent = oldIndex.nodes.get(oldNode.parentId);
            const newParent = newIndex.nodes.get(newNode.parentId);

            // 如果父节点都存在，且标题不同，则视为移动
            // 如果父节点标题相同，视为原地没动 (忽略 ID 变化)
            if (oldParent && newParent && oldParent.title !== newParent.title) {
                movedIds.add(id);
                // 既然是移动，也可能涉及跨级，为了兼容性我们也标记一下（虽然本函数后半部分主要用 movedIds）
                crossParentMovedIds.add(id);
            }

            // 从 map 中移除，避免多对一匹配
            urlToDeletedId.delete(newNode.url);
        }
    }

    // 移除已修正的 Added ID
    for (const id of reconciledAddedIds) {
        addedIds.delete(id);
    }
    // =========================================================================


    // 建立“子节点集合发生变化”的父级集合（避免因为 add/delete / 跨级移动导致的被动位移被误判为 moved）
    const parentsWithChildSetChange = new Set();
    for (const id of addedIds) {
        const node = newIndex.nodes.get(id);
        if (node && node.parentId) parentsWithChildSetChange.add(node.parentId);
    }
    for (const id of deletedIds) {
        const node = oldIndex.nodes.get(id);
        if (node && node.parentId) parentsWithChildSetChange.add(node.parentId);
    }
    for (const id of crossParentMovedIds) {
        //此处 crossParentMovedIds 混合了 ID 匹配的和 URL 匹配的(使用新ID)
        //对于 URL 匹配的新 ID，它在 newIndex 里有，在 oldIndex 里没有直接对应 ID
        //所以要小心获取 o

        // 尝试获取旧节点：如果是 ID 匹配的，直接取；如果是 URL 匹配的，我们已经在上面处理了逻辑，
        // 但这里主要是为了标记父级 Dirty。
        // 对于 URL 匹配的情况，id 是新 ID。oldIndex.nodes.get(id) 是 undefined。
        // 这会导致 o 为空。

        const n = newIndex.nodes.get(id);
        let o = oldIndex.nodes.get(id);

        // 如果是 URL 匹配产生的 Move，我们需要找到它对应的 Old ID 才能找到 Old Parent
        // 但我们在循环里没有保存映射。不过，只要我们将 New Parent 标记为 Dirty 即可。
        // 至于 Old Parent 的 Dirty 标记，主要影响的是 Old Parent 列表的 LIS 计算。
        // 如果我们不标记 Old Parent Dirty，可能会导致误判。
        // 但鉴于这只是 UI 展示，且 ID 全变的情况下 LIS 计算本身就很难匹配（因为 ID 都不一样）。
        // 所以这里只要保证代码不报错即可。

        if (o && o.parentId) parentsWithChildSetChange.add(o.parentId);
        if (n && n.parentId) parentsWithChildSetChange.add(n.parentId);
    }

    const hasExplicitMovedInfo = explicitMovedIds && explicitMovedIds.size > 0;

    // 同级排序移动
    if (hasExplicitMovedInfo) {
        // ... (省略显式移动逻辑，因为 Restore Modal 中可能无法获取显式移动 IDs，这里简化处理)
        // 注意：Restore对比时，我们通常没有“显式移动操作”的上下文，所以只能做全量diff。
        // background.js 中的逻辑依赖 recentMovedIds。
        // 在这里我们无法获取 recentMovedIds (除非从 storage 读取，但那是相对于上次备份的)。
        // Restore 对比的是 Current vs BackupRecord，这两者之间没有任何"操作记录"。
        // 所以在这里只能退化为仅检测跨级移动，或者全量检测 LIS 移动。
        // 下面的 else 分支就是全量检测 LIS 移动的逻辑。
    }

    // 强制进入全量检测逻辑 (因为我们没有 Recent Moved Context)
    // 或者我们保留原有逻辑结构，但 hasExplicitMovedInfo 始终为 false
    {
        for (const [parentId, newList] of newIndex.byParent.entries()) {
            if (parentsWithChildSetChange.has(parentId)) continue;

            const oldList = oldIndex.byParent.get(parentId) || [];
            if (oldList.length === 0 || newList.length === 0) continue;
            if (oldList.length !== newList.length) continue;

            // 快速判等
            let sameOrder = true;
            for (let i = 0; i < oldList.length; i++) {
                if (oldList[i].id !== newList[i].id) {
                    sameOrder = false;
                    break;
                }
            }
            if (sameOrder) continue;

            const oldPosById = new Map();
            for (let i = 0; i < oldList.length; i++) {
                oldPosById.set(oldList[i].id, i);
            }

            const seq = [];
            for (const item of newList) {
                const oldPos = oldPosById.get(item.id);
                if (typeof oldPos !== 'number') {
                    seq.length = 0;
                    break;
                }
                seq.push({ id: item.id, oldPos });
            }
            if (seq.length === 0) continue;

            // 计算 LIS
            const tails = [];
            const tailsIdx = [];
            const prevIdx = new Array(seq.length).fill(-1);

            for (let i = 0; i < seq.length; i++) {
                const v = seq[i].oldPos;
                let lo = 0;
                let hi = tails.length;
                while (lo < hi) {
                    const mid = (lo + hi) >> 1;
                    if (tails[mid] < v) lo = mid + 1;
                    else hi = mid;
                }
                const pos = lo;
                if (pos > 0) prevIdx[i] = tailsIdx[pos - 1];
                if (pos === tails.length) {
                    tails.push(v);
                    tailsIdx.push(i);
                } else {
                    tails[pos] = v;
                    tailsIdx[pos] = i;
                }
            }

            const stableIds = new Set();
            let k = tailsIdx.length ? tailsIdx[tailsIdx.length - 1] : -1;
            while (k >= 0) {
                stableIds.add(seq[k].id);
                k = prevIdx[k];
            }

            for (const item of seq) {
                if (!stableIds.has(item.id)) {
                    movedIds.add(item.id);
                }
            }
        }
    }

    // Git 风格：新增的东西不算“移动/修改”
    for (const id of addedIds) {
        movedIds.delete(id);
        modifiedIds.delete(id);
    }

    const isBookmark = (node) => !!(node && node.url);

    for (const id of addedIds) {
        const node = newIndex.nodes.get(id);
        if (isBookmark(node)) summary.bookmarkAdded++;
        else summary.folderAdded++;
    }

    for (const id of deletedIds) {
        const node = oldIndex.nodes.get(id);
        if (isBookmark(node)) summary.bookmarkDeleted++;
        else summary.folderDeleted++;
    }

    for (const id of movedIds) {
        const node = newIndex.nodes.get(id);
        if (isBookmark(node)) summary.movedBookmarkCount++;
        else summary.movedFolderCount++;
    }

    for (const id of modifiedIds) {
        const node = newIndex.nodes.get(id);
        if (isBookmark(node)) summary.modifiedBookmarkCount++;
        else summary.modifiedFolderCount++;
    }

    summary.movedCount = summary.movedBookmarkCount + summary.movedFolderCount;
    summary.modifiedCount = summary.modifiedBookmarkCount + summary.modifiedFolderCount;
    summary.bookmarkMoved = summary.movedBookmarkCount > 0;
    summary.folderMoved = summary.movedFolderCount > 0;
    summary.bookmarkModified = summary.modifiedBookmarkCount > 0;
    summary.folderModified = summary.modifiedFolderCount > 0;

    return summary;
}

/**
 * 惰性加载备份数据
 * @param {string|number} recordTime 
 * @returns {Promise<Object>} bookmarkTree
 */
async function getBackupDataLazy(recordTime) {
    return new Promise(resolve => {
        browserAPI.runtime.sendMessage({
            action: 'getBackupData',
            time: recordTime
        }, response => {
            if (response && response.success) {
                resolve(response.bookmarkTree);
            } else {
                console.warn('[getBackupDataLazy] Failed or data missing:', response?.error);
                resolve(null);
            }
        });
    });
}

async function showRestoreModal(record, displayTitle) {
    if (!record) {
        console.error('[showRestoreModal] 无效的记录');
        return;
    }

    // 检查是否有书签树数据
    if (!record.bookmarkTree) {
        // 尝试从新存储加载 (Index vs Data 架构)
        if (record.hasData || record.status === 'success') {
            const loadingToast = showToast(currentLang === 'zh_CN' ? '正在加载备份数据...' : 'Loading data...', 'info');
            try {
                const tree = await getBackupDataLazy(record.time);
                if (tree) {
                    record.bookmarkTree = tree; // Cache for this session
                    // Remove loading toast if possible, or let it timeout
                } else {
                    showToast(currentLang === 'zh_CN'
                        ? '数据加载失败'
                        : 'Failed to load data', 'error');
                    return;
                }
            } catch (e) {
                showToast(currentLang === 'zh_CN' ? '数据加载出错' : 'Error loading data', 'error');
                return;
            }
        } else {
            showToast(currentLang === 'zh_CN'
                ? '此记录不包含书签树数据，无法恢复'
                : 'This record does not contain bookmark tree data', 'error');
            return;
        }
    }

    currentRestoreRecord = record;

    const modal = document.getElementById('restoreModal');
    if (!modal) {
        console.error('[showRestoreModal] 找不到恢复模态框');
        return;
    }

    // --- START: 统计对比逻辑 ---
    // 重置显示
    document.getElementById('restoreCurrentCount').textContent = '--';
    document.getElementById('restoreCurrentFolders').textContent = '--';

    // [Modified] 重置视图状态 (简单切换模式)
    const mainView = document.getElementById('restoreMainView');
    const previewView = document.getElementById('restorePreviewView');
    const previewContent = document.getElementById('restorePreviewContent');

    if (mainView) mainView.style.display = 'block';
    if (previewView) previewView.style.display = 'none';
    if (previewContent) previewContent.removeAttribute('data-loaded'); // 每次重新打开都重新加载

    // 重置关闭按钮为标准关闭行为
    const closeBtn = document.getElementById('restoreModalClose');
    if (closeBtn) {
        const newCloseBtn = closeBtn.cloneNode(true);
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
        newCloseBtn.addEventListener('click', () => {
            document.getElementById('restoreModal').classList.remove('show');
        });
    }

    const title = document.getElementById('restoreModalTitle');
    if (title) title.textContent = currentLang === 'zh_CN' ? '恢复书签' : 'Restore Bookmarks';

    document.getElementById('restoreBackupCount').textContent = '--';
    document.getElementById('restoreBackupFolders').textContent = '--';
    const diffContainer = document.getElementById('restoreDiffSummary');
    if (diffContainer) diffContainer.textContent = currentLang === 'zh_CN' ? '正在计算差异...' : 'Calculating differences...';

    // 1. 获取当前浏览器书签统计
    // 1. 获取当前浏览器书签统计
    chrome.bookmarks.getTree(async (currentTree) => {
        const currentStats = calculateNodeStats(currentTree);
        document.getElementById('restoreCurrentCount').textContent = currentStats.bookmarks;
        document.getElementById('restoreCurrentFolders').textContent = currentStats.folders;

        // --- 智能 ID 匹配 (Fuzzy Matching) ---
        // 用户反馈：恢复预览时，如果名字和URL相同，应该视为同一个书签，而不是一删一增。
        // 因此我们需要克隆并"标准化"备份记录的树：如果 ID 不同但在当前树中找到相同内容，则修改备份树的 ID 以匹配当前树。
        let targetTree = record.bookmarkTree;
        try {
            // 深拷贝以避免修改原始记录
            targetTree = JSON.parse(JSON.stringify(record.bookmarkTree));
            normalizeTreeIds(targetTree, currentTree);
            console.log('[恢复] 已执行智能 ID 匹配');
        } catch (e) {
            console.error('[恢复] ID 匹配失败，将使用原始树:', e);
            targetTree = record.bookmarkTree;
        }

        // 2. 获取备份记录统计 (使用原始树或标准化后的树? 统计本身不受 ID 影响，但为了一致性使用 targetTree)
        const backupStats = calculateNodeStats(targetTree);
        document.getElementById('restoreBackupCount').textContent = backupStats.bookmarks;
        document.getElementById('restoreBackupFolders').textContent = backupStats.folders;

        // 3. 计算完整差异 (使用 Git Diff 逻辑: Current -> Target)
        // 注意：现在使用的是标准化后的树，所以内容相同的节点 ID 也相同，会被识别为 Unchanged
        const diffSummary = computeBookmarkGitDiffSummary(currentTree, targetTree);

        // 构造 changes 对象供 renderCommitStatsInline 使用
        const changes = {
            bookmarkAdded: diffSummary.bookmarkAdded,
            bookmarkDeleted: diffSummary.bookmarkDeleted,
            folderAdded: diffSummary.folderAdded,
            folderDeleted: diffSummary.folderDeleted,
            bookmarkMoved: diffSummary.bookmarkMoved,
            folderMoved: diffSummary.folderMoved,
            bookmarkModified: diffSummary.bookmarkModified,
            folderModified: diffSummary.folderModified,

            // Allow renderCommitStatsInline to show counts for Structure changes
            bookmarkMovedCount: diffSummary.movedBookmarkCount,
            folderMovedCount: diffSummary.movedFolderCount,
            bookmarkModifiedCount: diffSummary.modifiedBookmarkCount,
            folderModifiedCount: diffSummary.modifiedFolderCount,

            hasNumericalChange: (diffSummary.bookmarkAdded > 0 || diffSummary.bookmarkDeleted > 0 || diffSummary.folderAdded > 0 || diffSummary.folderDeleted > 0),
            hasStructuralChange: (diffSummary.bookmarkMoved || diffSummary.folderMoved || diffSummary.bookmarkModified || diffSummary.folderModified),
            hasNoChange: false,
            isRestoreHiddenStats: false,
            isFirst: false
        };
        changes.hasNoChange = !changes.hasNumericalChange && !changes.hasStructuralChange;

        if (diffContainer) {
            const prefix = currentLang === 'zh_CN' ? '相较当前: ' : 'Different from current: ';
            const html = renderCommitStatsInline(changes);

            // 如果无变化，显示特定的无变化 UI
            if (changes.hasNoChange) {
                diffContainer.innerHTML = `<span style="color: var(--text-tertiary);"><i class="fas fa-check-circle"></i> ${currentLang === 'zh_CN' ? '数量与结构一致' : 'Identical quantity & structure'}</span>`;
            } else {
                // 将 renderCommitStatsInline 的结果稍微包装一下
                diffContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: flex-start; gap: 8px; flex-wrap: wrap;">
                        <span style="font-size: 13px; color: var(--text-secondary);">${prefix}</span>
                        ${html}
                    </div>
                `;
            }
        }

        // --- 4. 设置预览按钮 (三级UI) ---
        const previewBtn = document.getElementById('restorePreviewBtn');
        if (previewBtn) {
            previewBtn.style.display = 'block';
            const btnText = document.getElementById('restorePreviewBtnText');
            if (btnText) btnText.textContent = currentLang === 'zh_CN' ? '预览' : 'Preview';

            // Unbind old listeners by cloning
            const newBtn = previewBtn.cloneNode(true);
            previewBtn.parentNode.replaceChild(newBtn, previewBtn);

            newBtn.addEventListener('click', () => {
                switchToRestorePreview(currentTree, targetTree);
            });
        }
    });
    // --- END: 统计对比逻辑 ---

    // 构建预览条目 (完全复用列表样式)
    const isRestore = record.type === 'restore';
    const seqNumber = record.seqNumber || '-';
    // 强制使用相同的样式类
    const titleClass = isRestore ? 'commit-title restore-title' : 'commit-title';
    const seqClass = isRestore ? 'commit-seq-badge restore-seq' : 'commit-seq-badge';
    // 如果没有传入 displayTitle，就用默认 note
    const titleToUse = displayTitle || record.note || formatTime(record.time);

    const itemHtml = `
        <div style="margin-bottom: 10px; font-size: 13px; color: var(--text-secondary); text-align: left;">${currentLang === 'zh_CN' ? '即将恢复到以下版本:' : 'Restore to the following version:'}</div>
        <div class="commit-item" style="cursor: default; pointer-events: none; border: 1px solid var(--accent-primary); box-shadow: none; background: var(--bg-secondary); margin: 0; padding: 12px; display: flex;">
            <div class="commit-header" style="margin-bottom: 0; width: 100%;">
                <div class="commit-title-group" style="max-width: 100%;">
                    <span class="${seqClass}">#${seqNumber}</span>
                    <div class="${titleClass}" style="font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 260px;">${escapeHtml(titleToUse)}</div>
                </div>
                <div class="commit-time" style="margin-left: auto; font-size: 12px; white-space: nowrap;">
                     ${formatTime(record.time)}
                </div>
            </div>
        </div>
    `;

    const infoContainer = document.getElementById('restoreVersionInfo');
    if (infoContainer) {
        infoContainer.innerHTML = itemHtml;
        // 重置容器样式，移除之前的 padding/border
        infoContainer.style.background = 'transparent';
        infoContainer.style.border = 'none';
        infoContainer.style.padding = '0';
        infoContainer.style.textAlign = 'left';
    }

    // 重置进度区域
    document.getElementById('restoreProgressSection').style.display = 'none';
    document.getElementById('restoreProgressBar').style.width = '0%';
    document.getElementById('restoreProgressPercent').textContent = '0%';
    document.getElementById('restoreProgressText').textContent = currentLang === 'zh_CN' ? '准备中...' : 'Preparing...';

    // 重置按钮状态
    const confirmBtn = document.getElementById('restoreConfirmBtn');
    if (confirmBtn) {
        confirmBtn.disabled = false;
        confirmBtn.textContent = currentLang === 'zh_CN' ? '恢复书签' : 'Restore Bookmarks';
    }
    document.getElementById('restoreCancelBtn').disabled = false;

    // 更新多语言文本 (仅部分)
    updateRestoreModalI18n();

    // [New] 更新备份记录标签为 Hash 值 (Fingerprint)
    const backupLabel = document.getElementById('restoreBackupLabel');
    if (backupLabel && record && record.fingerprint) {
        backupLabel.textContent = record.fingerprint;
        backupLabel.title = record.fingerprint; // 鼠标悬停显示完整指纹
        backupLabel.style.fontFamily = 'SF Mono, Monaco, Consolas, monospace';
        backupLabel.style.fontSize = '11px';
        backupLabel.style.letterSpacing = '-0.5px'; // 稍微紧凑一点以适应长Hash
    }

    // 显示模态框
    modal.classList.add('show');
}

/**
 * 打开恢复后预览模态框 (三级UI)
 */
/**
 * 切换到恢复后预览视图 (二代UI：同模态框内平滑切换)
 */
async function switchToRestorePreview(currentTree, targetTree) {
    const mainView = document.getElementById('restoreMainView');
    const previewView = document.getElementById('restorePreviewView');
    const title = document.getElementById('restoreModalTitle');
    const previewContent = document.getElementById('restorePreviewContent');

    if (!mainView || !previewView) return;

    // 1. 切换视图状态 (简单显隐，保持 Small Window)
    mainView.style.display = 'none';
    previewView.style.display = 'flex'; // 使用 flex 布局以支持内部滚动

    // 2. [Removed] 不需要调整模态框宽度/高度，保持原有紧凑尺寸

    // 3. 更新头部
    // Hijack Close Button to act as "Back"
    const closeBtn = document.getElementById('restoreModalClose');
    if (closeBtn) {
        // Clone to strip existing "Close Modal" listeners
        const newCloseBtn = closeBtn.cloneNode(true);
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

        // Define Back Handler
        const handleBack = () => {
            // Switch UI back
            mainView.style.display = 'block';
            previewView.style.display = 'none';

            if (title) title.textContent = currentLang === 'zh_CN' ? '恢复书签' : 'Restore Bookmarks';

            // Restore "Close Modal" behavior
            const finalCloseBtn = newCloseBtn.cloneNode(true);
            newCloseBtn.parentNode.replaceChild(finalCloseBtn, newCloseBtn);

            finalCloseBtn.addEventListener('click', () => {
                document.getElementById('restoreModal').classList.remove('show');
            });

            // Clean up preview data if needed (optional)
            if (previewContent) {
                previewContent.innerHTML = '';
                previewContent.removeAttribute('data-loaded');
            }
        };

        newCloseBtn.addEventListener('click', handleBack);
    }

    if (title) title.textContent = currentLang === 'zh_CN' ? '预览' : 'Preview';

    // 4. 加载内容 (如果尚未加载)
    if (!previewContent.hasAttribute('data-loaded')) {
        previewContent.innerHTML = `<div class="loading" style="padding: 40px; color: var(--text-secondary); text-align: center;">
            <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 20px; opacity: 0.5;"></i><br>
            ${currentLang === 'zh_CN' ? '正在生成详细预览...' : 'Generating detailed preview...'}
        </div>`;

        // 异步生成树
        setTimeout(async () => {
            try {
                const changeMap = await detectTreeChangesFast(currentTree, targetTree, {
                    useGlobalExplicitMovedIds: false
                });

                let treeToRender = targetTree;
                let hasDeleted = false;
                for (const [, change] of changeMap) {
                    if (change.type && change.type.includes('deleted')) {
                        hasDeleted = true;
                        break;
                    }
                }

                if (hasDeleted) {
                    try {
                        treeToRender = rebuildTreeWithDeleted(currentTree, targetTree, changeMap);
                    } catch (e) {
                        console.error('[恢复预览] 重建树失败:', e);
                    }
                }

                const treeHtml = generateHistoryTreeHtml(treeToRender, changeMap, 'detailed', {
                    maxDepth: 2,
                    customTitle: currentLang === 'zh_CN' ? '恢复后的书签树（临时缓存）' : 'Restored Bookmark Tree (Temporary Cache)'
                });

                previewContent.innerHTML = treeHtml || `<div style="padding: 20px; color: var(--text-tertiary); text-align: center;">No Data</div>`;
                previewContent.setAttribute('data-loaded', 'true');

                // 绑定折叠事件
                previewContent.querySelectorAll('.tree-toggle').forEach(toggle => {
                    toggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const children = e.target.closest('.tree-node').querySelector('.tree-children');
                        if (children) {
                            children.classList.toggle('expanded');
                            toggle.classList.toggle('expanded');
                            const icon = e.target.closest('.tree-item').querySelector('.tree-icon.fa-folder, .tree-icon.fa-folder-open');
                            if (icon) {
                                icon.classList.toggle('fa-folder');
                                icon.classList.toggle('fa-folder-open');
                            }
                        }
                    });
                });

            } catch (err) {
                previewContent.innerHTML = `<div style="padding: 20px; color: var(--warning);">Error: ${err.message}</div>`;
            }
        }, 100);
    }
}

// 确保在 updateRestoreModalI18n 中也更新按钮文本
function updateRestoreModalI18n() {
    const isZh = currentLang === 'zh_CN';

    const texts = {
        restoreModalTitle: isZh ? '恢复书签' : 'Restore Bookmarks',
        restoreVersionLabel: isZh ? '即将恢复到以下版本:' : 'Restore to the following version:',
        restoreWarningTitle: isZh ? '警告' : 'Warning',
        restoreWarningText: isZh
            ? '此操作将【覆盖】当前浏览器的所有书签。恢复完成后会自动创建一条新的备份记录。'
            : 'This operation will [OVERWRITE] all current browser bookmarks. A new backup record will be created automatically.',
        restoreProgressLabel: isZh ? '正在恢复...' : 'Restoring...',
        restoreConfirmBtnText: isZh ? '确认恢复' : 'Confirm Restore',
        restoreCancelBtn: isZh ? '取消' : 'Cancel',
        // New Comparison Labels
        restoreCurrentLabel: isZh ? '当前浏览器' : 'Current Browser',
        restoreCurrentBookmarksLabel: isZh ? '书签' : 'Bookmarks',
        restoreCurrentFoldersLabel: isZh ? '文件夹' : 'Folders',
        restoreBackupLabel: isZh ? '备份记录' : 'Backup Record',
        restoreBackupBookmarksLabel: isZh ? '书签' : 'Bookmarks',
        restoreBackupFoldersLabel: isZh ? '文件夹' : 'Folders',
        restorePreviewBtnText: isZh ? '预览' : 'Preview'
    };

    Object.entries(texts).forEach(([id, text]) => {
        const el = document.getElementById(id);
        if (el) el.textContent = text;
    });
}

/**
 * 关闭恢复模态框
 */
function closeRestoreModal() {
    const modal = document.getElementById('restoreModal');
    if (modal) {
        modal.classList.remove('show');
    }
    currentRestoreRecord = null;
}

/**
 * 执行恢复操作
 */
async function executeRestore() {
    if (!currentRestoreRecord) {
        showToast(currentLang === 'zh_CN' ? '没有可恢复的记录' : 'No record to restore', 'error');
        return;
    }

    const bookmarkTree = currentRestoreRecord.bookmarkTree;
    if (!bookmarkTree) {
        showToast(currentLang === 'zh_CN' ? '此记录不包含书签树数据' : 'This record does not contain bookmark tree data', 'error');
        return;
    }

    const strategy = 'overwrite';

    // 禁用按钮
    document.getElementById('restoreConfirmBtn').disabled = true;
    document.getElementById('restoreCancelBtn').disabled = true;

    // 显示进度区域
    document.getElementById('restoreProgressSection').style.display = 'block';
    updateRestoreProgress(0, currentLang === 'zh_CN' ? '正在准备恢复...' : 'Preparing to restore...');

    try {
        // 1. 设置恢复标志（暂停书签监听）
        await browserAPI.runtime.sendMessage({ action: 'setBookmarkRestoringFlag', value: true });
        updateRestoreProgress(5, currentLang === 'zh_CN' ? '已暂停书签监听...' : 'Bookmark listening paused...');

        let result;
        if (strategy === 'overwrite') {
            result = await executeOverwriteRestore(bookmarkTree);
        } else {
            result = await executeMergeRestore(bookmarkTree);
        }

        // 2. 重置恢复标志
        await browserAPI.runtime.sendMessage({ action: 'setBookmarkRestoringFlag', value: false });

        updateRestoreProgress(90, currentLang === 'zh_CN' ? '正在创建恢复记录...' : 'Creating restore record...');

        // 3. 触发一次备份（作为恢复记录）
        const restoreNote = currentLang === 'zh_CN'
            ? `恢复至 #${currentRestoreRecord.seqNumber} (${formatTime(currentRestoreRecord.time)})`
            : `Restored to #${currentRestoreRecord.seqNumber} (${formatTime(currentRestoreRecord.time)})`;

        await browserAPI.runtime.sendMessage({
            action: 'triggerRestoreBackup',
            note: restoreNote,
            sourceSeqNumber: currentRestoreRecord.seqNumber,
            sourceTime: currentRestoreRecord.time,
            sourceNote: currentRestoreRecord.note || '',
            sourceFingerprint: currentRestoreRecord.fingerprint || '',
            strategy: strategy
        });

        updateRestoreProgress(100, currentLang === 'zh_CN' ? '恢复完成！' : 'Restore completed!');

        // 显示成功提示
        const successMsg = currentLang === 'zh_CN'
            ? `恢复成功！${strategy === 'overwrite' ? `创建 ${result.created} 个节点` : `添加 ${result.added} 个书签`}`
            : `Restore successful! ${strategy === 'overwrite' ? `Created ${result.created} nodes` : `Added ${result.added} bookmarks`}`;
        showToast(successMsg, 'success');

        // 延迟关闭模态框并刷新数据
        setTimeout(async () => {
            closeRestoreModal();

            // 刷新备份历史数据
            await loadAllData({ skipRender: true });
            renderHistoryView();
        }, 1500);

    } catch (error) {
        console.error('[executeRestore] 恢复失败:', error);

        // 重置恢复标志
        try {
            await browserAPI.runtime.sendMessage({ action: 'setBookmarkRestoringFlag', value: false });
        } catch (_) { }

        // 恢复按钮状态
        document.getElementById('restoreConfirmBtn').disabled = false;
        document.getElementById('restoreCancelBtn').disabled = false;
        document.getElementById('restoreProgressSection').style.display = 'none';

        showToast(currentLang === 'zh_CN'
            ? `恢复失败: ${error.message}`
            : `Restore failed: ${error.message}`, 'error');
    }
}

/**
 * 覆盖模式恢复
 */
async function executeOverwriteRestore(bookmarkTree) {
    updateRestoreProgress(10, currentLang === 'zh_CN' ? '正在清空当前书签...' : 'Clearing current bookmarks...');

    // 1. 获取根节点
    const [root] = await browserAPI.bookmarks.getTree();

    // 查找书签栏和其他书签（兼容 Chrome 和 Firefox）
    // Chrome: id='1' (书签栏), id='2' (其他书签)
    // Firefox: 可能使用不同的 id
    let bookmarkBar = root.children?.find(c => c.id === '1');
    let otherBookmarks = root.children?.find(c => c.id === '2');

    // 如果找不到，尝试通过标题查找
    if (!bookmarkBar) {
        bookmarkBar = root.children?.find(c =>
            c.title === '书签栏' ||
            c.title === 'Bookmarks Bar' ||
            c.title === 'Bookmarks bar' ||
            c.title === 'toolbar_____'
        );
    }
    if (!otherBookmarks) {
        otherBookmarks = root.children?.find(c =>
            c.title === '其他书签' ||
            c.title === 'Other Bookmarks' ||
            c.title === 'Other bookmarks' ||
            c.title === 'menu________' ||
            c.title === 'unfiled_____'
        );
    }

    // 如果仍然找不到，使用第一个和第二个子节点
    if (!bookmarkBar && root.children?.length > 0) {
        bookmarkBar = root.children[0];
    }
    if (!otherBookmarks && root.children?.length > 1) {
        otherBookmarks = root.children[1];
    }

    console.log('[executeOverwriteRestore] bookmarkBar:', bookmarkBar?.id, bookmarkBar?.title);
    console.log('[executeOverwriteRestore] otherBookmarks:', otherBookmarks?.id, otherBookmarks?.title);

    // 2. 清空书签栏和其他书签下的所有内容
    let deletedCount = 0;
    for (const container of [bookmarkBar, otherBookmarks]) {
        if (container && container.children) {
            for (const child of [...container.children]) {
                try {
                    await browserAPI.bookmarks.removeTree(child.id);
                    deletedCount++;
                } catch (e) {
                    console.warn('[executeOverwriteRestore] 删除节点失败:', child.id, e);
                }
            }
        }
    }

    updateRestoreProgress(40, currentLang === 'zh_CN' ? `已清空 ${deletedCount} 个节点，正在重建...` : `Cleared ${deletedCount} nodes, rebuilding...`);

    // 3. 从备份树重建书签
    let createdCount = 0;
    const nodes = Array.isArray(bookmarkTree) ? bookmarkTree : [bookmarkTree];

    for (const node of nodes) {
        if (node.children) {
            for (const topFolder of node.children) {
                // 确定目标容器（书签栏或其他书签）
                const isBookmarkBarFolder = topFolder.id === '1' ||
                    topFolder.title === '书签栏' ||
                    topFolder.title === 'Bookmarks Bar' ||
                    topFolder.title === 'Bookmarks bar' ||
                    topFolder.title === 'toolbar_____';

                // 确保目标容器存在
                const targetContainer = isBookmarkBarFolder ? bookmarkBar : otherBookmarks;
                if (!targetContainer) {
                    console.warn('[executeOverwriteRestore] 目标容器不存在，跳过:', topFolder.title);
                    continue;
                }
                const targetId = targetContainer.id;

                for (const child of topFolder.children || []) {
                    try {
                        createdCount += await createNodeRecursive(child, targetId);
                        updateRestoreProgress(40 + Math.min(45, (createdCount / 100) * 45),
                            currentLang === 'zh_CN' ? `已创建 ${createdCount} 个节点...` : `Created ${createdCount} nodes...`);
                    } catch (e) {
                        console.warn('[executeOverwriteRestore] 创建节点失败:', child, e);
                    }
                }
            }
        }
    }

    return { success: true, created: createdCount, deleted: deletedCount };
}

/**
 * 合并模式恢复
 */
async function executeMergeRestore(bookmarkTree) {
    updateRestoreProgress(10, currentLang === 'zh_CN' ? '正在分析当前书签...' : 'Analyzing current bookmarks...');

    // 1. 获取当前书签的 URL 集合
    const [root] = await browserAPI.bookmarks.getTree();
    const existingUrls = new Set();

    function collectUrls(node) {
        if (node.url) existingUrls.add(node.url);
        if (node.children) node.children.forEach(collectUrls);
    }
    root.children?.forEach(collectUrls);

    updateRestoreProgress(30, currentLang === 'zh_CN' ? `发现 ${existingUrls.size} 个现有书签...` : `Found ${existingUrls.size} existing bookmarks...`);

    // 2. 遍历备份树，添加不存在的书签
    let addedCount = 0;
    let skippedCount = 0;

    // 获取"其他书签"作为默认添加位置（兼容多浏览器）
    let otherBookmarks = root.children?.find(c => c.id === '2');
    if (!otherBookmarks) {
        otherBookmarks = root.children?.find(c =>
            c.title === '其他书签' ||
            c.title === 'Other Bookmarks' ||
            c.title === 'Other bookmarks'
        );
    }
    if (!otherBookmarks && root.children?.length > 1) {
        otherBookmarks = root.children[1];
    }
    if (!otherBookmarks && root.children?.length > 0) {
        otherBookmarks = root.children[0];
    }

    if (!otherBookmarks) {
        throw new Error(currentLang === 'zh_CN' ? '找不到书签根目录' : 'Cannot find bookmark root folder');
    }

    console.log('[executeMergeRestore] otherBookmarks:', otherBookmarks?.id, otherBookmarks?.title);

    async function addMissingBookmarks(node, parentId) {
        if (node.url) {
            if (!existingUrls.has(node.url)) {
                try {
                    await browserAPI.bookmarks.create({
                        parentId,
                        title: node.title || '',
                        url: node.url
                    });
                    addedCount++;
                    if (addedCount % 10 === 0) {
                        updateRestoreProgress(30 + Math.min(55, (addedCount / 100) * 55),
                            currentLang === 'zh_CN' ? `已添加 ${addedCount} 个书签...` : `Added ${addedCount} bookmarks...`);
                    }
                } catch (e) {
                    console.warn('[executeMergeRestore] 添加书签失败:', node, e);
                }
            } else {
                skippedCount++;
            }
        }
        if (node.children) {
            for (const child of node.children) {
                await addMissingBookmarks(child, parentId);
            }
        }
    }

    const nodes = Array.isArray(bookmarkTree) ? bookmarkTree : [bookmarkTree];
    for (const node of nodes) {
        if (node.children) {
            for (const topFolder of node.children) {
                if (topFolder.children) {
                    for (const child of topFolder.children) {
                        await addMissingBookmarks(child, otherBookmarks.id);
                    }
                }
            }
        }
    }

    return { success: true, added: addedCount, skipped: skippedCount };
}

/**
 * 递归创建书签/文件夹
 */
async function createNodeRecursive(node, parentId) {
    let count = 0;

    try {
        if (node.url) {
            // 创建书签
            await browserAPI.bookmarks.create({
                parentId,
                title: node.title || '',
                url: node.url
            });
            count = 1;
        } else if (node.children !== undefined) {
            // 创建文件夹
            const folder = await browserAPI.bookmarks.create({
                parentId,
                title: node.title || ''
            });
            count = 1;

            // 递归创建子节点
            for (const child of node.children || []) {
                count += await createNodeRecursive(child, folder.id);
            }
        }
    } catch (e) {
        console.warn('[createNodeRecursive] 创建节点失败:', node, e);
    }

    return count;
}

/**
 * 更新恢复进度
 */
function updateRestoreProgress(percent, text) {
    const progressBar = document.getElementById('restoreProgressBar');
    const progressPercent = document.getElementById('restoreProgressPercent');
    const progressText = document.getElementById('restoreProgressText');

    if (progressBar) progressBar.style.width = `${percent}%`;
    if (progressPercent) progressPercent.textContent = `${Math.round(percent)}%`;
    if (progressText) progressText.textContent = text;
}

/**
 * 初始化恢复模态框事件
 */
function initRestoreModal() {
    const modal = document.getElementById('restoreModal');
    const closeBtn = document.getElementById('restoreModalClose');
    const cancelBtn = document.getElementById('restoreCancelBtn');
    const confirmBtn = document.getElementById('restoreConfirmBtn');

    if (closeBtn) {
        closeBtn.addEventListener('click', closeRestoreModal);
    }

    if (cancelBtn) {
        cancelBtn.addEventListener('click', closeRestoreModal);
    }

    if (confirmBtn) {
        confirmBtn.addEventListener('click', executeRestore);
    }

    // 点击模态框外部关闭
    if (modal) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeRestoreModal();
            }
        });
    }
}


// =============================================================================
// 备份历史详情模式切换
// =============================================================================

// 初始化备份历史详情模式切换按钮
function initHistoryDetailModeToggle() {
    const simpleBtn = document.getElementById('historyDetailModeSimple');
    const detailedBtn = document.getElementById('historyDetailModeDetailed');

    if (!simpleBtn || !detailedBtn) return;

    // 恢复保存的模式状态
    if (historyDetailMode === 'detailed') {
        simpleBtn.classList.remove('active');
        detailedBtn.classList.add('active');
    } else {
        simpleBtn.classList.add('active');
        detailedBtn.classList.remove('active');
    }

    // 点击事件
    simpleBtn.addEventListener('click', () => {
        if (historyDetailMode === 'simple') return;
        historyDetailMode = 'simple';
        // 更新统一存储
        if (historyViewSettings) {
            historyViewSettings.defaultMode = 'simple';
            saveHistoryViewSettings();
        }
        simpleBtn.classList.add('active');
        detailedBtn.classList.remove('active');
        // 全局覆盖：同步更新每条记录的持久化模式
        try {
            (syncHistory || []).forEach(r => setRecordDetailMode(r?.time, 'simple'));
        } catch (_) { }
        // 立即刷新列表（未保存单条模式的记录会跟随全局模式）
        try { renderHistoryView(); } catch (_) { }
    });

    detailedBtn.addEventListener('click', () => {
        if (historyDetailMode === 'detailed') return;
        historyDetailMode = 'detailed';
        // 更新统一存储
        if (historyViewSettings) {
            historyViewSettings.defaultMode = 'detailed';
            saveHistoryViewSettings();
        }
        detailedBtn.classList.add('active');
        simpleBtn.classList.remove('active');
        // 全局覆盖：同步更新每条记录的持久化模式
        try {
            (syncHistory || []).forEach(r => setRecordDetailMode(r?.time, 'detailed'));
        } catch (_) { }
        // 立即刷新列表（未保存单条模式的记录会跟随全局模式）
        try { renderHistoryView(); } catch (_) { }
    });
}

// 生成详情内容（异步）
async function generateDetailContent(record, mode) {
    const stats = record.bookmarkStats || {};
    const detailMode = mode || getRecordDetailMode(record.time);

    let html = '';

    const seqMap = buildSequenceMapFromHistory(syncHistory);
    const seqNumber = seqMap.get(String(record.time));
    const seqText = Number.isFinite(seqNumber) ? String(seqNumber) : '-';

    const noteText = (record.note && record.note.trim())
        ? record.note
        : (currentLang === 'zh_CN' ? '（无备注）' : '(No note)');
    html += `
        <div class="detail-section">
            <div class="detail-note-row">
                <span class="commit-seq-badge" title="${currentLang === 'zh_CN' ? '序号' : 'No.'}">${seqText}</span>
                <span class="detail-note-label">${currentLang === 'zh_CN' ? '备注：' : 'Note:'}</span>
                <span class="detail-note-text-wrapper">
                    <span class="detail-note-text">${escapeHtml(noteText)}</span>
                    <button class="commit-note-edit-btn detail-note-edit-btn" data-time="${record.time}" title="${currentLang === 'zh_CN' ? '编辑备注' : 'Edit Note'}">
                        <i class="fas fa-edit"></i>
                    </button>
                </span>
                <div class="detail-actions-right">
                    <button id="detailExportChangesBtn" class="action-btn compact" title="${currentLang === 'zh_CN' ? '导出变化' : 'Export Changes'}">
                        <i class="fas fa-file-export"></i>
                    </button>
                    <div class="toggle-btn-group" id="historyDetailModeToggleModal">
                        <button id="historyDetailModeSimpleModal" class="toggle-btn ${detailMode === 'simple' ? 'active' : ''}" data-mode="simple" title="${currentLang === 'zh_CN' ? '简略模式' : 'Simple mode'}">
                            <svg class="icon-compact" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="4" y1="9" x2="20" y2="9" />
                                <line x1="4" y1="15" x2="20" y2="15" />
                                <circle cx="2" cy="9" r="1.5" fill="currentColor" stroke="none" />
                                <circle cx="2" cy="15" r="1.5" fill="currentColor" stroke="none" />
                            </svg>
                            <span id="historyDetailModeSimpleModalText">${currentLang === 'zh_CN' ? '简略' : 'Simple'}</span>
                        </button>
                        <button id="historyDetailModeDetailedModal" class="toggle-btn ${detailMode === 'detailed' ? 'active' : ''}" data-mode="detailed" title="${currentLang === 'zh_CN' ? '详细模式' : 'Detailed mode'}">
                            <svg class="icon-detail" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="4" y1="6" x2="20" y2="6" />
                                <line x1="4" y1="10" x2="20" y2="10" />
                                <line x1="4" y1="14" x2="20" y2="14" />
                                <line x1="4" y1="18" x2="20" y2="18" />
                            </svg>
                            <span id="historyDetailModeDetailedModalText">${currentLang === 'zh_CN' ? '详细' : 'Detailed'}</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;

    // 尝试获取详细变化 - 使用树形视图
    try {
        const treeHtml = await generateTreeBasedChanges(record, detailMode);
        if (treeHtml) {
            html += treeHtml;
        } else {
            html += `
                <div class="detail-section">
                    <div class="detail-empty">
                        <i class="fas fa-info-circle"></i>
                        ${currentLang === 'zh_CN'
                    ? '无详细变化记录（该记录可能来自旧版本）'
                    : 'No detailed changes available (this record may be from an older version)'}
                    </div>
                </div>
            `;
        }
    } catch (error) {
        console.error('[详情内容] 生成变化失败:', error);
        html += `
            <div class="detail-section">
                <div class="detail-empty">
                    <i class="fas fa-exclamation-circle"></i>
                    ${currentLang === 'zh_CN' ? '加载变化详情失败' : 'Failed to load change details'}
                </div>
            </div>
        `;
    }

    return html;
}

// 生成树形视图的变化详情
async function generateTreeBasedChanges(record, mode) {
    console.log('[树形视图] ========== 开始生成详细变化 ==========');
    console.log('[树形视图] 记录时间:', record.time);
    console.log('[树形视图] 显示模式:', mode);

    // 检查当前记录是否有 bookmarkTree
    if (!record.bookmarkTree) {
        console.log('[树形视图] ❌ 当前记录没有 bookmarkTree（可能是旧记录或保存失败）');
        return null;
    }

    // 找到上一条记录进行对比
    const recordIndex = syncHistory.findIndex(r => r.time === record.time);
    console.log('[树形视图] 记录索引:', recordIndex);

    let previousRecord = null;
    if (recordIndex > 0) {
        for (let i = recordIndex - 1; i >= 0; i--) {
            if (syncHistory[i].status === 'success' && syncHistory[i].bookmarkTree) {
                previousRecord = syncHistory[i];
                break;
            }
        }
    }

    // 如果找不到上一条记录，尝试从 cachedRecordAfterClear 获取（清空历史后的第一条记录）
    if (!previousRecord && recordIndex === 0) {
        try {
            const cachedData = await new Promise(resolve => {
                browserAPI.storage.local.get('cachedRecordAfterClear', result => {
                    resolve(result.cachedRecordAfterClear);
                });
            });
            if (cachedData && cachedData.bookmarkTree) {
                console.log('[树形视图] 使用 cachedRecordAfterClear 作为对比基准');
                previousRecord = cachedData;
            }
        } catch (e) {
            console.warn('[树形视图] 获取 cachedRecordAfterClear 失败:', e);
        }
    }

    // 使用与「当前变化」相同的 detectTreeChangesFast 函数计算变化
    let changeMap = new Map();
    let treeToRender = record.bookmarkTree;

    if (previousRecord && previousRecord.bookmarkTree) {
        console.log('[树形视图] 找到上一条记录:', previousRecord.time);
        changeMap = await detectTreeChangesFast(previousRecord.bookmarkTree, record.bookmarkTree, {
            useGlobalExplicitMovedIds: false,
            explicitMovedIdSet: (record && record.bookmarkStats && Array.isArray(record.bookmarkStats.explicitMovedIds))
                ? record.bookmarkStats.explicitMovedIds
                : null
        });

        // 关键：如果有删除的节点，需要重建树结构（与"当前变化"一致）
        let hasDeleted = false;
        for (const [, change] of changeMap) {
            if (change.type && change.type.includes('deleted')) {
                hasDeleted = true;
                break;
            }
        }
        if (hasDeleted) {
            try {
                treeToRender = rebuildTreeWithDeleted(previousRecord.bookmarkTree, record.bookmarkTree, changeMap);
                console.log('[树形视图] 已重建包含删除节点的树');
            } catch (error) {
                console.error('[树形视图] 重建树失败:', error);
                treeToRender = record.bookmarkTree;
            }
        }
    } else if (record.isFirstBackup) {
        console.log('[树形视图] 第一次备份，所有书签都是新增');
        // 第一次备份，所有书签都是新增
        const allNodes = flattenBookmarkTree(record.bookmarkTree);
        allNodes.forEach(item => {
            if (item.id) changeMap.set(item.id, { type: 'added' });
        });
    } else {
        // 例如：用户清空了备份历史后，这条记录变成"第一条记录"，但它并不是"首次备份"，也没有缓存可对比
        return `
            <div class="detail-section">
                <div class="detail-empty">
                    <i class="fas fa-info-circle"></i>
                    ${currentLang === 'zh_CN'
                ? '无法计算变化：缺少上一条可对比的备份记录（上一条记录可能来自旧版本，或你刚清空了备份历史）'
                : 'Cannot compute changes: no previous backup record to compare (the previous record may be from an older version, or you may have just cleared the backup history).'}
                </div>
            </div>
        `;
    }

    console.log('[树形视图] 变化统计: changeMap.size =', changeMap.size);

    if (changeMap.size === 0) {
        return `
            <div class="detail-section">
                <div class="detail-empty">
                    <i class="fas fa-check-circle"></i>
                    ${currentLang === 'zh_CN' ? '无变化' : 'No changes'}
                </div>
            </div>
        `;
    }

    // 生成树形 HTML（使用重建后的树）
    return generateHistoryTreeHtml(treeToRender, changeMap, mode);
}

// 计算两个书签树之间的变化
function computeBookmarkChanges(oldTree, newTree) {
    const oldMap = buildBookmarkMap(oldTree);
    const newMap = buildBookmarkMap(newTree);

    const added = [];
    const deleted = [];
    const modified = [];
    const moved = [];

    // 检测新增和修改/移动
    for (const [id, newItem] of newMap) {
        const oldItem = oldMap.get(id);
        if (!oldItem) {
            // 新增
            added.push(newItem);
        } else {
            // 检测修改
            if (oldItem.title !== newItem.title || oldItem.url !== newItem.url) {
                modified.push({ ...newItem, oldTitle: oldItem.title, oldUrl: oldItem.url });
            }
            // 检测移动
            if (oldItem.parentId !== newItem.parentId || oldItem.index !== newItem.index) {
                moved.push({ ...newItem, oldParentId: oldItem.parentId, oldIndex: oldItem.index });
            }
        }
    }

    // 检测删除
    for (const [id, oldItem] of oldMap) {
        if (!newMap.has(id)) {
            deleted.push(oldItem);
        }
    }

    return { added, deleted, modified, moved };
}

// 构建书签ID映射
function buildBookmarkMap(tree, map = new Map(), parentId = '0') {
    if (!tree) return map;

    const nodes = Array.isArray(tree) ? tree : [tree];
    nodes.forEach((node, index) => {
        if (node.id) {
            map.set(node.id, {
                id: node.id,
                title: node.title || '',
                url: node.url || '',
                parentId: parentId,
                index: node.index !== undefined ? node.index : index,
                isFolder: !node.url && node.children
            });
        }
        if (node.children) {
            buildBookmarkMap(node.children, map, node.id);
        }
    });

    return map;
}

// 展平书签树为数组
function flattenBookmarkTree(tree, result = []) {
    if (!tree) return result;

    const nodes = Array.isArray(tree) ? tree : [tree];
    nodes.forEach(node => {
        if (node.id && (node.title || node.url)) {
            result.push({
                id: node.id,
                title: node.title || '',
                url: node.url || '',
                isFolder: !node.url && node.children
            });
        }
        if (node.children) {
            flattenBookmarkTree(node.children, result);
        }
    });

    return result;
}

/**
 * 标准化书签树 ID (用于恢复预览时的 Smart/Fuzzy Matching)
 * 策略：让备份树(Target)尽可能对齐参考树(Reference/Current)，以减少"误报"的变化。
 * 优先级：
 * 1. ID 精确匹配 (ID Persistence)
 * 2. 结构位置匹配 (Same Parent + Same Title/URL)
 * 3. 全局内容匹配 (Same URL for Bookmarks)
 * 
 * @param {Array} targetTree 要修改的树 (通常是备份记录的深拷贝)
 * @param {Array} referenceTree 参考树 (通常是当前浏览器书签树)
 */
function normalizeTreeIds(targetTree, referenceTree) {
    if (!targetTree || !referenceTree) return;

    // --- 0. 准备工作：建立参考树索引 ---
    const refPool = {
        ids: new Set(),         // 已存在的 ID 集合
        claimedIds: new Set(),  // 已被 Target 匹配领用的 ID 集合 (1-to-1 Mapping)
        nodeMap: new Map(),     // ID -> Node
        urlMap: new Map(),      // URL -> Set<Node> (仅书签)
    };

    const indexRef = (nodes) => {
        if (!nodes) return;
        const list = Array.isArray(nodes) ? nodes : [nodes];
        list.forEach(node => {
            if (node.id) {
                refPool.ids.add(String(node.id));
                refPool.nodeMap.set(String(node.id), node);

                if (node.url) {
                    // 书签：索引 URL
                    if (!refPool.urlMap.has(node.url)) {
                        refPool.urlMap.set(node.url, new Set());
                    }
                    refPool.urlMap.get(node.url).add(node);
                }
            }
            if (node.children) indexRef(node.children);
        });
    };
    indexRef(referenceTree);

    // 辅助：更改节点 ID 并递归更新子节点的 parentId
    const updateNodeId = (node, newId) => {
        if (!node) return;
        const oldId = node.id;
        node.id = newId;

        // 更新子节点的 parentId 指向新 ID
        if (node.children) {
            node.children.forEach(child => {
                child.parentId = newId;
            });
        }
    };

    // --- Pass 1: ID 精确匹配 (Lock-in) ---
    // 遍历 Target，如果 ID 在 Reference 中存在且类型兼容，优先锁定。
    const pass1_IDMatch = (nodes) => {
        if (!nodes) return;
        const list = Array.isArray(nodes) ? nodes : [nodes];
        list.forEach(node => {
            const id = String(node.id);
            if (refPool.ids.has(id)) {
                // 检查 Reference 中该节点是否已被认领 (本 Pass 不应该发生，除非 Ref 有重复 ID)
                if (!refPool.claimedIds.has(id)) {
                    // 类型检查（简单）：有无 URL
                    const refNode = refPool.nodeMap.get(id);
                    const isSameType = (!!node.url === !!refNode.url);
                    if (isSameType) {
                        refPool.claimedIds.add(id);
                        node._matchedRefNode = refNode; // 暂存匹配关系供 Pass 2 使用
                    }
                }
            }
            if (node.children) pass1_IDMatch(node.children);
        });
    };
    pass1_IDMatch(targetTree);

    // --- Pass 2: 结构位置匹配 (Relative Position) ---
    // 遍历 Target (Top-Down)，对于未匹配的节点，
    // 如果其 Parent 已匹配，则在 Parent 对应的 RefNode children 中寻找“包含相同 Title/URL”的未认领节点。
    const pass2_StructureMatch = (nodes, parentMatchedRefNode) => {
        if (!nodes) return;
        const list = Array.isArray(nodes) ? nodes : [nodes];

        list.forEach(node => {
            // 如果该节点在 Pass 1 还没匹配
            if (!node._matchedRefNode) {
                // 尝试结构匹配
                // 条件：父节点必须已匹配 (parentMatchedRefNode 存在)
                if (parentMatchedRefNode && parentMatchedRefNode.children) {
                    const isBookmark = !!node.url;

                    // 在参考父节点的子节点中寻找候选
                    const candidate = parentMatchedRefNode.children.find(refChild => {
                        const refId = String(refChild.id);
                        if (refPool.claimedIds.has(refId)) return false; // 已被别人认领

                        const refIsBookmark = !!refChild.url;
                        if (isBookmark !== refIsBookmark) return false; // 类型不同

                        // 匹配标准：名字相同
                        if (node.title !== refChild.title) return false;

                        // 如果是书签，URL 也必须相同
                        if (isBookmark && node.url !== refChild.url) return false;

                        return true;
                    });

                    if (candidate) {
                        // 匹配成功！
                        const newId = String(candidate.id);
                        // 修改 Target 节点 ID
                        updateNodeId(node, newId);
                        // 标记领用
                        refPool.claimedIds.add(newId);
                        node._matchedRefNode = candidate;
                    }
                }
            }

            // 递归子节点 (传入当前节点匹配到的 RefObj，如果没匹配到则传 null，导致子链断裂无法进行结构匹配)
            if (node.children) {
                pass2_StructureMatch(node.children, node._matchedRefNode);
            }
        });
    };
    // 根节点处理：通常 root (id:0) 在 Pass 1 已经匹配。
    // targetTree 本身可能是 root 数组，或者 root 对象
    // 我们假设 targetTree[0] 是 root
    const rootNodes = Array.isArray(targetTree) ? targetTree : [targetTree];
    // 为了启动 Top-Down，我们需要根节点的 Ref。
    // 如果根节点 Pass 1 匹配了，就传进去。
    rootNodes.forEach(root => {
        // 通常 root 已经有 id=0 匹配了
        pass2_StructureMatch(root.children, root._matchedRefNode);
    });

    // --- Pass 3: 全局内容匹配 (Same URL - Fallback) ---
    // 对于书签，如果结构匹配失败（例如书签被移动到了不同文件夹），尝试全局 URL 匹配。
    // 仅限书签。文件夹名字太通用，不宜全局匹配。
    const pass3_GlobalUrlMatch = (nodes) => {
        if (!nodes) return;
        const list = Array.isArray(nodes) ? nodes : [nodes];
        list.forEach(node => {
            // 如果还没匹配，且是书签
            if (!node._matchedRefNode && node.url) {
                const candidates = refPool.urlMap.get(node.url);
                if (candidates) {
                    // 找一个未认领的 ID
                    // 优先找 Title 也相同的?
                    let bestMatch = null;

                    // 策略：先找 Title 相同的未认领项
                    for (const cand of candidates) {
                        if (!refPool.claimedIds.has(String(cand.id))) {
                            if (cand.title === node.title) {
                                bestMatch = cand;
                                break;
                            }
                        }
                    }

                    // 如果没找到 Title 相同的，随便找一个未认领的 URL 相同的 (视为改名 + 移动)
                    if (!bestMatch) {
                        for (const cand of candidates) {
                            if (!refPool.claimedIds.has(String(cand.id))) {
                                bestMatch = cand;
                                break;
                            }
                        }
                    }

                    if (bestMatch) {
                        const newId = String(bestMatch.id);
                        updateNodeId(node, newId);
                        refPool.claimedIds.add(newId);
                        node._matchedRefNode = bestMatch;
                    }
                }
            }
            if (node.children) pass3_GlobalUrlMatch(node.children);
        });
    };
    pass3_GlobalUrlMatch(targetTree);

    // 清理临时属性
    const cleanup = (nodes) => {
        if (!nodes) return;
        const list = Array.isArray(nodes) ? nodes : [nodes];
        list.forEach(node => {
            delete node._matchedRefNode;
            if (node.children) cleanup(node.children);
        });
    };
    cleanup(targetTree);
}

// 生成备份历史的树形 HTML（与"当前变化"视图保持一致的结构）
// changeMap: Map<id, {type: 'added'|'deleted'|'modified'|'moved'|'modified+moved', moved?: {...}}>
// options: { maxDepth: number } - 控制默认展开深度
function generateHistoryTreeHtml(bookmarkTree, changeMap, mode, options = {}) {
    const isZh = currentLang === 'zh_CN';
    const maxDepth = options.maxDepth !== undefined ? options.maxDepth : 999;

    // 检查某个节点或其子节点是否有变化
    function hasChangesRecursive(node) {
        if (!node) return false;
        if (changeMap.has(node.id)) return true;
        if (node.children) {
            return node.children.some(child => hasChangesRecursive(child));
        }
        return false;
    }

    // 递归生成树形 HTML（使用与永久栏目相同的结构）
    // forceInclude: 简略模式下的“上下文展开”开关（例如：文件夹被移动时，为了能展开查看内容，需要把其子树也渲染出来）
    function renderHistoryTreeNode(node, level = 0, forceInclude = false) {
        if (!node) return '';

        // 简略模式下只显示有变化的节点
        const shouldInclude = mode === 'detailed' || forceInclude || hasChangesRecursive(node);
        if (!shouldInclude) return '';

        const change = changeMap.get(node.id);
        let changeClass = '';
        let statusIcon = '';

        if (change) {
            const types = change.type ? change.type.split('+') : [];
            const isAdded = types.includes('added');
            const isDeleted = types.includes('deleted');
            const isModified = types.includes('modified');
            const isMoved = types.includes('moved');

            if (isAdded) {
                changeClass = 'tree-change-added';
                statusIcon = '<span class="change-badge added">+</span>';
            } else if (isDeleted) {
                changeClass = 'tree-change-deleted';
                statusIcon = '<span class="change-badge deleted">-</span>';
            } else {
                // 处理 modified 和 moved 的组合（与"当前变化"一致）
                if (isModified) {
                    changeClass = 'tree-change-modified';
                    statusIcon += '<span class="change-badge modified">~</span>';
                }

                if (isMoved) {
                    // 如果既有modified又有moved，添加mixed类
                    if (isModified) {
                        changeClass = 'tree-change-mixed';
                    } else {
                        changeClass = 'tree-change-moved';
                    }
                    // 使用与"当前变化"相同的路径格式和tooltip
                    let slash = '';
                    if (change.moved && change.moved.oldPath) {
                        slash = breadcrumbToSlashFolders(change.moved.oldPath);
                    }
                    statusIcon += `<span class="change-badge moved" data-move-from="${escapeHtml(slash)}" title="${escapeHtml(slash)}"><i class="fas fa-arrows-alt"></i><span class="move-tooltip">${slashPathToChipsHTML(slash)}</span></span>`;
                }
            }
        } else if (hasChangesRecursive(node) && mode === 'detailed') {
            // 文件夹本身无变化，但子节点有变化（简略模式不显示灰点）
            statusIcon = `<span class="change-badge has-changes" title="${isZh ? '此文件夹下有变化' : 'Contains changes'}">•</span>`;
        }

        const title = escapeHtml(node.title || (isZh ? '(无标题)' : '(Untitled)'));
        const isFolder = !node.url && node.children;
        const hasChildren = isFolder && node.children && node.children.length > 0;

        // 展开逻辑：
        // - 详细模式：根节点展开，包含变化的文件夹也展开
        // - 简略模式：祖先路径保持展开；若“变更对象本身是文件夹”，默认折叠（但内容已渲染，允许手动展开查看）
        // UPDATE: 增加 maxDepth 支持
        const isSelfChangedFolder = !!(isFolder && change && change.type);

        // 默认展开条件：
        // 1. 深度小于 maxDepth
        // 2. 或者是 detailed 模式且有子节点变化 (但这会导致全展开，所以我们要限制)
        // 修改为：(level < maxDepth) OR (shouldExpandRecursive && level < maxDepth + 1) ?
        // 简单点：只展开 maxDepth 层级。详细的让用户点。
        // 但是对于 Restore Result Preview，如果只显示根节点，用户看不到里面的变化。
        // 所以我们保留原有的 hasChangesRecursive 逻辑，加上 level 限制。

        let shouldExpand = false;

        if (mode === 'detailed') {
            // 详细模式 (Restore Preview 用这个):
            // 默认展开根节点 (level 0) 和 第一级 (level 1)
            // 即使有深层变化，也默认折叠，防止内容太多。用户看到红点/绿点自己展开。
            shouldExpand = level < maxDepth;

            // 如果在 auto backup 详情弹窗里，我们可能希望还是尽量展开？
            // 传入的 maxDepth 如果很大 (999)，就保持原样
            if (options.maxDepth === undefined || options.maxDepth === null || options.maxDepth > 100) {
                shouldExpand = (level === 0 || hasChangesRecursive(node));
            }
        } else {
            // 简略模式
            shouldExpand = ((level === 0 || hasChangesRecursive(node)) && !isSelfChangedFolder);
        }

        // 关键：当“文件夹本身发生移动（拖动）”时，简略模式也需要允许展开查看其内容。
        // 否则简略模式只会显示这个文件夹节点，展开后是空的，用户无法确认“移动的是什么”。
        const shouldForceIncludeChildrenInSimple =
            mode !== 'detailed' &&
            !forceInclude &&
            isFolder &&
            change &&
            typeof change.type === 'string';
        const nextForceInclude = forceInclude || shouldForceIncludeChildrenInSimple;

        if (isFolder) {
            // 文件夹节点
            const childrenHtml = hasChildren
                ? node.children.map(child => renderHistoryTreeNode(child, level + 1, nextForceInclude)).join('')
                : '';

            return `
                <div class="tree-node">
                    <div class="tree-item ${changeClass}" data-node-id="${node.id}" data-node-type="folder" data-node-level="${level}">
                        <span class="tree-toggle ${shouldExpand ? 'expanded' : ''}"><i class="fas fa-chevron-right"></i></span>
                        <i class="tree-icon fas fa-folder${shouldExpand ? '-open' : ''}"></i>
                        <span class="tree-label">${title}</span>
                        <span class="change-badges">${statusIcon}</span>
                    </div>
                    <div class="tree-children ${shouldExpand ? 'expanded' : ''}">
                        ${childrenHtml}
                    </div>
                </div>
            `;
        } else {
            // 书签节点
            const favicon = typeof getFaviconUrl === 'function' ? getFaviconUrl(node.url) : '';
            return `
                <div class="tree-node">
                    <div class="tree-item ${changeClass}" data-node-id="${node.id}" data-node-type="bookmark" data-node-level="${level}">
                        <span class="tree-toggle" style="opacity: 0"></span>
                        ${favicon ? `<img class="tree-icon" src="${favicon}" alt="">` : `<i class="tree-icon fas fa-bookmark"></i>`}
                        <a href="${escapeHtml(node.url || '')}" target="_blank" class="tree-label tree-bookmark-link" rel="noopener noreferrer">${title}</a>
                        <span class="change-badges">${statusIcon}</span>
                    </div>
                </div>
            `;
        }
    }

    // 生成树内容
    let treeContent = '';
    const nodes = Array.isArray(bookmarkTree) ? bookmarkTree : [bookmarkTree];
    nodes.forEach(node => {
        if (node.children) {
            node.children.forEach(child => {
                treeContent += renderHistoryTreeNode(child, 0);
            });
        }
    });

    if (!treeContent) {
        return `
            <div class="detail-section">
                <div class="detail-empty">
                    <i class="fas fa-check-circle"></i>
                    ${isZh ? '无变化' : 'No changes'}
                </div>
            </div>
        `;
    }

    // 获取各类型变化数量（区分文件夹F和书签B）
    let addedFolders = 0, addedBookmarks = 0;
    let deletedFolders = 0, deletedBookmarks = 0;
    let modifiedFolders = 0, modifiedBookmarks = 0;
    let movedFolders = 0, movedBookmarks = 0;

    // 构建节点ID到节点的映射，用于判断节点类型
    const nodeMap = new Map();
    function buildNodeMap(node) {
        if (!node) return;
        if (node.id) nodeMap.set(node.id, node);
        if (node.children) node.children.forEach(buildNodeMap);
    }
    const treeNodes = Array.isArray(bookmarkTree) ? bookmarkTree : [bookmarkTree];
    treeNodes.forEach(buildNodeMap);

    changeMap.forEach((change, id) => {
        const node = nodeMap.get(id);
        const isFolder = node && !node.url && node.children;
        const types = change.type ? change.type.split('+') : [];

        if (types.includes('added')) {
            if (isFolder) addedFolders++; else addedBookmarks++;
        }
        if (types.includes('deleted')) {
            if (isFolder) deletedFolders++; else deletedBookmarks++;
        }
        if (types.includes('modified')) {
            if (isFolder) modifiedFolders++; else modifiedBookmarks++;
        }
        if (types.includes('moved')) {
            if (isFolder) movedFolders++; else movedBookmarks++;
        }
    });

    // 生成图例（内联在标题行，带数量，区分F/B）
    const formatCount = (folders, bookmarks) => {
        const parts = [];
        if (folders > 0) parts.push(`${folders}F`);
        if (bookmarks > 0) parts.push(`${bookmarks}B`);
        return parts.join(' ');
    };

    const legendItems = [];
    const addedTotal = addedFolders + addedBookmarks;
    const deletedTotal = deletedFolders + deletedBookmarks;
    const modifiedTotal = modifiedFolders + modifiedBookmarks;
    const movedTotal = movedFolders + movedBookmarks;

    // 增加和删除显示F/B详情，移动和修改只显示总数
    if (addedTotal > 0) legendItems.push(`<span class="legend-item"><span class="legend-dot added"></span><span class="legend-count">:${formatCount(addedFolders, addedBookmarks)}</span></span>`);
    if (deletedTotal > 0) legendItems.push(`<span class="legend-item"><span class="legend-dot deleted"></span><span class="legend-count">:${formatCount(deletedFolders, deletedBookmarks)}</span></span>`);
    if (movedTotal > 0) legendItems.push(`<span class="legend-item"><span class="legend-dot moved"></span><span class="legend-count">:${movedTotal}</span></span>`);
    if (modifiedTotal > 0) legendItems.push(`<span class="legend-item"><span class="legend-dot modified"></span><span class="legend-count">:${modifiedTotal}</span></span>`);
    const legend = legendItems.join('');

    return `
        <div class="detail-section">
            <div class="detail-section-title detail-section-title-with-legend">
                <span class="detail-title-left">
                    ${options.customTitle ? options.customTitle : (isZh ? '书签变化' : 'Bookmark Changes')}
                    ${!options.customTitle ? `<span class="detail-mode-label">(${mode === 'detailed' ? (isZh ? '详细' : 'Detailed') : (isZh ? '简略' : 'Simple')})</span>` : ''}
                </span>
                <span class="detail-title-legend">${legend}</span>
            </div>
            <div class="history-tree-container bookmark-tree">
                ${treeContent}
            </div>
        </div>
    `;
}

// 截断 URL 显示
function truncateUrl(url, maxLength) {
    if (!url || url.length <= maxLength) return url;
    return url.substring(0, maxLength) + '...';
}

// 生成详细变化的 HTML（Git diff 风格）
async function generateDetailedChanges(record) {
    console.log('[详细变化] ========== 开始生成详细变化 ==========');
    console.log('[详细变化] 记录时间:', record.time);
    console.log('[详细变化] 记录状态:', record.status);
    console.log('[详细变化] 记录有 bookmarkTree:', !!record.bookmarkTree);
    console.log('[详细变化] bookmarkTree 类型:', typeof record.bookmarkTree);

    if (record.bookmarkTree) {
        console.log('[详细变化] bookmarkTree 是数组:', Array.isArray(record.bookmarkTree));
        console.log('[详细变化] bookmarkTree 长度:', record.bookmarkTree.length);
        console.log('[详细变化] bookmarkTree[0] 存在:', !!record.bookmarkTree[0]);
        if (record.bookmarkTree[0]) {
            console.log('[详细变化] bookmarkTree[0] 的 children 数量:', record.bookmarkTree[0].children?.length || 0);
        }
    }

    // 检查当前记录是否有 bookmarkTree
    if (!record.bookmarkTree) {
        console.log('[详细变化] ❌ 当前记录没有 bookmarkTree（可能是旧记录或保存失败）');
        return null;
    }

    // 找到上一条记录
    const recordIndex = syncHistory.findIndex(r => r.time === record.time);
    console.log('[详细变化] 记录索引:', recordIndex);

    if (recordIndex <= 0) {
        // 第一条记录，显示所有书签为新增
        if (record.isFirstBackup) {
            console.log('[详细变化] 第一次备份，显示所有书签为新增');
            return generateFirstBackupDiff(record.bookmarkTree);
        }
        console.log('[详细变化] 第一条记录但不是首次备份');
        return null;
    }

    // 获取上一条记录
    let previousRecord = null;
    for (let i = recordIndex - 1; i >= 0; i--) {
        if (syncHistory[i].status === 'success' && syncHistory[i].bookmarkTree) {
            previousRecord = syncHistory[i];
            break;
        }
    }

    if (!previousRecord || !previousRecord.bookmarkTree) {
        console.log('[详细变化] 没有找到上一条有效的备份记录');
        return null;
    }

    console.log('[详细变化] 找到上一条记录:', previousRecord.time);

    // 生成 diff（对比这次备份和上次备份）
    const oldLines = bookmarkTreeToLines(previousRecord.bookmarkTree);
    const newLines = bookmarkTreeToLines(record.bookmarkTree);

    console.log('[详细变化] oldLines 数量:', oldLines.length);
    console.log('[详细变化] newLines 数量:', newLines.length);

    const groupedHunks = generateDiffByPath(oldLines, newLines);

    console.log('[详细变化] groupedHunks 数量:', groupedHunks.length);

    return renderDiffHtml(groupedHunks);
}

// 生成首次备份的 diff（所有书签都是新增）
function generateFirstBackupDiff(bookmarkTree) {
    const lines = bookmarkTreeToLines(bookmarkTree);

    if (lines.length === 0) {
        return `
            <div class="detail-section">
                <div class="detail-empty">
                    <i class="fas fa-inbox"></i>
                    ${currentLang === 'zh_CN' ? '空书签' : 'Empty bookmarks'}
                </div>
            </div>
        `;
    }

    // 按路径分组
    const grouped = {};
    lines.forEach(line => {
        const path = line.path || (currentLang === 'zh_CN' ? '根目录' : 'Root');
        if (!grouped[path]) grouped[path] = [];
        grouped[path].push(line);
    });

    let html = '<div class="detail-section"><div class="git-diff-viewer">';
    html += '<div class="diff-file-header">';
    html += `<span class="diff-file-path">${currentLang === 'zh_CN' ? '首次备份 - 所有书签' : 'First Backup - All Bookmarks'}</span>`;
    html += '</div>';

    Object.entries(grouped).forEach(([path, pathLines]) => {
        html += '<div class="diff-folder-group">';
        html += `<div class="diff-folder-header-static">`;
        html += renderBreadcrumb(path, currentLang);
        html += '</div>';
        html += '<div class="diff-hunk">';
        html += `<div class="diff-hunk-header">`;
        html += `<span class="hunk-location">@@ +1,${pathLines.length} @@</span>`;
        html += `<span class="hunk-stats"><span class="stat-add">+${pathLines.length}</span></span>`;
        html += '</div>';
        html += '<div class="diff-hunk-content">';

        pathLines.forEach((line, idx) => {
            html += `<div class="diff-line-wrapper added">`;
            html += `<span class="diff-line-num old"></span>`;
            html += `<span class="diff-line-num new">${idx + 1}</span>`;
            html += `<span class="diff-line-prefix">+</span>`;
            html += `<span class="diff-line-content">${escapeHtml(line.line)}</span>`;
            html += `</div>`;
        });

        html += '</div></div></div>';
    });

    html += '</div></div>';
    return html;
}

// 渲染 diff HTML
function renderDiffHtml(groupedHunks) {
    if (!groupedHunks || groupedHunks.length === 0) {
        return `
            <div class="detail-section">
                <div class="detail-empty">
                    <i class="fas fa-check-circle"></i>
                    ${currentLang === 'zh_CN' ? '无变化' : 'No changes'}
                </div>
            </div>
        `;
    }

    // 渲染 Git diff
    let diffHtml = '<div class="detail-section"><div class="git-diff-viewer">';
    diffHtml += '<div class="diff-file-header">';
    diffHtml += `<span class="diff-file-path">${currentLang === 'zh_CN' ? '书签变化详情' : 'Bookmark Changes'}</span>`;
    diffHtml += '</div>';

    let hunkIndex = 0;
    groupedHunks.forEach((group) => {
        diffHtml += '<div class="diff-folder-group">';
        diffHtml += `<div class="diff-folder-header-static">`;
        diffHtml += renderBreadcrumb(group.path, currentLang);
        diffHtml += '</div>';

        group.hunks.forEach(hunk => {
            const hunkId = `detail-hunk-${hunkIndex++}`;
            const hunkLines = hunk.contextBefore.length + hunk.changes.length + hunk.contextAfter.length;
            const shouldCollapse = hunkLines > 15;

            const addCount = hunk.changes.filter(c => c.type === 'add').length;
            const deleteCount = hunk.changes.filter(c => c.type === 'delete').length;

            diffHtml += '<div class="diff-hunk">';

            const iconClass = shouldCollapse ? 'fa-chevron-right' : 'fa-chevron-down';
            diffHtml += `<div class="diff-hunk-header collapsible" data-hunk-id="${hunkId}">`;
            diffHtml += `<i class="fas ${iconClass} collapse-icon" id="${hunkId}-icon"></i>`;
            diffHtml += `<span class="hunk-location">@@ -${hunk.oldStart},${hunk.oldCount} +${hunk.newStart},${hunk.newCount} @@</span>`;
            diffHtml += `<span class="hunk-stats">`;
            if (addCount > 0) diffHtml += `<span class="stat-add">+${addCount}</span>`;
            if (deleteCount > 0) diffHtml += `<span class="stat-delete">-${deleteCount}</span>`;
            diffHtml += `</span>`;
            diffHtml += '</div>';

            diffHtml += `<div class="diff-hunk-content ${shouldCollapse ? 'collapsed' : ''}" id="${hunkId}">`;

            // 前置上下文
            hunk.contextBefore.forEach(ctx => {
                diffHtml += `<div class="diff-line-wrapper context">`;
                diffHtml += `<span class="diff-line-num old">${ctx.oldIdx + 1}</span>`;
                diffHtml += `<span class="diff-line-num new">${ctx.oldIdx + 1}</span>`;
                diffHtml += `<span class="diff-line-prefix"> </span>`;
                diffHtml += `<span class="diff-line-content">${escapeHtml(ctx.line.line)}</span>`;
                diffHtml += `</div>`;
            });

            // 变化
            hunk.changes.forEach(change => {
                if (change.type === 'delete') {
                    diffHtml += `<div class="diff-line-wrapper deleted">`;
                    diffHtml += `<span class="diff-line-num old">${change.oldIdx + 1}</span>`;
                    diffHtml += `<span class="diff-line-num new"></span>`;
                    diffHtml += `<span class="diff-line-prefix">-</span>`;
                    diffHtml += `<span class="diff-line-content">${escapeHtml(change.line.line)}</span>`;
                    diffHtml += `</div>`;
                } else if (change.type === 'add') {
                    diffHtml += `<div class="diff-line-wrapper added">`;
                    diffHtml += `<span class="diff-line-num old"></span>`;
                    diffHtml += `<span class="diff-line-num new">${change.newIdx + 1}</span>`;
                    diffHtml += `<span class="diff-line-prefix">+</span>`;
                    diffHtml += `<span class="diff-line-content">${escapeHtml(change.line.line)}</span>`;
                    diffHtml += `</div>`;
                }
            });

            // 后置上下文
            hunk.contextAfter.forEach(ctx => {
                diffHtml += `<div class="diff-line-wrapper context">`;
                diffHtml += `<span class="diff-line-num old">${ctx.oldIdx + 1}</span>`;
                diffHtml += `<span class="diff-line-num new">${ctx.oldIdx + 1}</span>`;
                diffHtml += `<span class="diff-line-prefix"> </span>`;
                diffHtml += `<span class="diff-line-content">${escapeHtml(ctx.line.line)}</span>`;
                diffHtml += `</div>`;
            });

            diffHtml += '</div></div>';
        });

        diffHtml += '</div>';
    });

    diffHtml += '</div></div>';
    return diffHtml;
}

// =============================================================================
// 搜索功能
// =============================================================================

let searchTimeout = null;

function handleSearch(e) {
    const query = e.target.value.trim().toLowerCase();

    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        performSearch(query);
    }, 300);
}

function performSearch(query) {
    if (!query) {
        renderCurrentView();
        return;
    }

    // 根据当前视图执行搜索
    switch (currentView) {
        case 'history':
            searchHistory(query);
            break;
        case 'additions':
            searchAdditions(query);
            break;
        case 'tree':
            searchTree(query);
            break;
    }
}

function searchHistory(query) {
    const container = document.getElementById('historyList');
    const filtered = syncHistory.filter(record => {
        const note = (record.note || '').toLowerCase();
        const time = formatTime(record.time).toLowerCase();
        return note.includes(query) || time.includes(query);
    });

    if (filtered.length === 0) {
        container.innerHTML = `<div class="empty-state"><div class="empty-state-title">未找到匹配的记录</div></div>`;
        return;
    }

    // 重新渲染过滤后的历史
    syncHistory = filtered;
    renderHistoryView();
}

function searchAdditions(query) {
    const filtered = allBookmarks.filter(bookmark => {
        const title = (bookmark.title || '').toLowerCase();
        const url = (bookmark.url || '').toLowerCase();
        return title.includes(query) || url.includes(query);
    });

    const groupedByDate = groupBookmarksByDate(filtered);
    const container = document.getElementById('additionsList');
    container.innerHTML = renderBookmarkGroups(groupedByDate);
}

function searchTree(query) {
    // 树搜索暂时不实现，因为需要保持树结构
    renderTreeView();
}

// =============================================================================
// 主题和语言切换
// =============================================================================

// 主题和语言切换 - 独立设置，主UI优先
// 设置覆盖后会显示重置按钮

function toggleTheme() {
    currentTheme = currentTheme === 'light' ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', currentTheme);

    // 设置覆盖标志
    try {
        localStorage.setItem('historyViewerHasCustomTheme', 'true');
        localStorage.setItem('historyViewerCustomTheme', currentTheme);
        console.log('[History Viewer] 设置主题覆盖:', currentTheme);
    } catch (e) {
        console.error('[History Viewer] 无法保存主题覆盖:', e);
    }

    // 更新图标
    const icon = document.querySelector('#themeToggle i');
    if (icon) {
        icon.className = currentTheme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
    }
}

function toggleLanguage() {
    currentLang = currentLang === 'zh_CN' ? 'en' : 'zh_CN';
    window.currentLang = currentLang; // 同步到 window

    // 设置覆盖标志
    try {
        localStorage.setItem('historyViewerHasCustomLang', 'true');
        localStorage.setItem('historyViewerCustomLang', currentLang);
        console.log('[History Viewer] 设置语言覆盖:', currentLang);
    } catch (e) {
        console.error('[History Viewer] 无法保存语言覆盖:', e);
    }

    applyLanguage();

    // 只更新界面文字，不重新渲染内容（避免图标重新加载）
    // renderCurrentView();

    // 手动更新需要多语言的UI元素（不涉及书签树内容）
    updateLanguageDependentUI();

    // 复习热力图：重新加载一次以应用当前语言
    // 只影响热力图容器，不会重新加载书签图标
    try {
        loadHeatmapData();
    } catch (e) {
        console.warn('[Heatmap] 语言切换时重载失败:', e);
    }

    // 刷新书签关联记录列表（更新badge文字）
    refreshBrowsingRelatedHistory();
}

// 更新依赖语言的UI元素（不重新渲染内容，避免图标重新加载）
function updateLanguageDependentUI() {
    const isEn = currentLang === 'en';

    // 只更新图例文字（如果存在）
    const legends = document.querySelectorAll('.tree-legend');
    legends.forEach(legend => {
        legend.innerHTML = `
            <span class="legend-item"><span class="legend-dot added"></span> ${isEn ? 'Added' : '新增'}</span>
            <span class="legend-item"><span class="legend-dot deleted"></span> ${isEn ? 'Deleted' : '删除'}</span>
            <span class="legend-item"><span class="legend-dot moved"></span> ${isEn ? 'Moved' : '移动'}</span>
            <span class="legend-item"><span class="legend-dot modified"></span> ${isEn ? 'Modified' : '修改'}</span>
        `;
    });

    // 更新加载文本（如果存在）
    const loadingTexts = document.querySelectorAll('.loading');
    loadingTexts.forEach(el => {
        if (el.textContent.includes('Loading') || el.textContent.includes('加载中')) {
            el.textContent = i18n.loading[currentLang];
        }
    });

    // 更新空状态文本
    const emptyStates = document.querySelectorAll('.empty-state');
    emptyStates.forEach(el => {
        if (el.textContent.includes('No') || el.textContent.includes('没有')) {
            el.textContent = isEn ? 'No data' : '没有数据';
        }
    });

    // ===== 更新临时栏目相关的多语言元素 =====

    // 1. 更新临时栏目的按钮tooltip
    document.querySelectorAll('.temp-node-rename-btn').forEach(btn => {
        const label = isEn ? 'Rename section' : '重命名栏目';
        btn.title = label;
        btn.setAttribute('aria-label', label);
    });

    document.querySelectorAll('.temp-node-color-btn, .temp-node-color-input').forEach(btn => {
        const label = isEn ? 'Change color' : '调整栏目颜色';
        btn.title = label;
        btn.setAttribute('aria-label', label);
    });

    document.querySelectorAll('.temp-color-lock-btn').forEach(btn => {
        const locked = btn.classList.contains('locked');
        const label = locked
            ? (isEn ? 'Unlock color' : '解除锁定')
            : (isEn ? 'Lock color' : '锁定颜色');
        btn.title = label;
        btn.setAttribute('aria-label', label);
    });

    document.querySelectorAll('.temp-node-close').forEach(btn => {
        const label = isEn ? 'Remove section' : '删除临时栏目';
        btn.title = label;
        btn.setAttribute('aria-label', label);
    });

    // 2. 更新临时栏目说明（现为 WYSIWYG editor）
    document.querySelectorAll('.temp-node-description').forEach(descEl => {
        const placeholder = isEn ? 'Click to add description...' : '点击添加说明...';
        try {
            descEl.setAttribute('data-placeholder', placeholder);
            descEl.setAttribute('aria-label', placeholder);
        } catch (_) { }

        const text = (descEl.textContent || '').replace(/\u200B/g, '').trim();
        const hasNonText = !!descEl.querySelector('hr, input[type="checkbox"], ul, ol, blockquote, h1, h2, h3, h4, h5, h6');
        const hasContent = Boolean(text) || hasNonText;
        descEl.title = hasContent
            ? (isEn ? 'Click to edit' : '点击编辑说明')
            : (isEn ? 'Click to add description' : '点击添加说明');
    });

    // 3. 更新说明编辑按钮的tooltip
    document.querySelectorAll('.temp-node-desc-edit-btn').forEach(btn => {
        btn.title = isEn ? 'Edit description' : '编辑说明';
    });

    document.querySelectorAll('.temp-node-desc-format-btn').forEach(btn => {
        btn.title = isEn ? 'Format toolbar' : '格式工具栏';
    });

    document.querySelectorAll('.temp-node-desc-delete-btn').forEach(btn => {
        btn.title = isEn ? 'Clear input' : '清空输入框';
    });

    // 4. 更新永久栏目的说明提示
    const permanentTipCollapsed = document.querySelector('.permanent-section-tip-collapsed span');
    if (permanentTipCollapsed) {
        const text = isEn ? 'Click to add description...' : '点击添加说明...';
        permanentTipCollapsed.textContent = text;
    }

    const permanentTipText = document.querySelector('.permanent-section-tip');
    if (permanentTipText) {
        const placeholder = isEn ? 'Click to add description...' : '点击添加说明...';
        try {
            permanentTipText.setAttribute('data-placeholder', placeholder);
            permanentTipText.setAttribute('aria-label', placeholder);
        } catch (_) { }

        const text = (permanentTipText.textContent || '').replace(/\u200B/g, '').trim();
        const hasNonText = !!permanentTipText.querySelector('hr, input[type="checkbox"], ul, ol, blockquote, h1, h2, h3, h4, h5, h6');
        const hasContent = Boolean(text) || hasNonText;
        permanentTipText.title = hasContent
            ? (isEn ? 'Click to edit' : '点击编辑说明')
            : (isEn ? 'Click to add description' : '点击添加说明');
    }

    document.querySelectorAll('.permanent-section-tip-format-btn').forEach(btn => {
        btn.title = isEn ? 'Format toolbar' : '格式工具栏';
    });

    // 5. 更新书签关联记录排序按钮的tooltip
    const relatedSortBtn = document.getElementById('browsingRelatedSortBtn');
    if (relatedSortBtn) {
        const tooltip = relatedSortBtn.querySelector('.btn-tooltip');
        if (tooltip) {
            tooltip.textContent = browsingRelatedSortAsc
                ? (i18n.currentAscending?.[currentLang] || (isEn ? 'Current: Ascending' : '当前：正序'))
                : (i18n.currentDescending?.[currentLang] || (isEn ? 'Current: Descending' : '当前：倒序'));
        }
    }

    console.log('[toggleLanguage] 已更新UI文字（包括临时栏目）');
}

// =============================================================================
// 实时更新
// =============================================================================

function handleStorageChange(changes, namespace) {
    if (namespace !== 'local') return;

    console.log('[存储监听] 检测到变化:', Object.keys(changes));

    // 备份历史被清空：关闭详情弹窗并清理本地状态，避免残留旧记录内容/展开状态
    if (changes.syncHistory) {
        try {
            const newHistory = changes.syncHistory.newValue || [];
            if (Array.isArray(newHistory) && newHistory.length === 0) {
                const modal = document.getElementById('detailModal');
                if (modal && modal.classList.contains('show')) {
                    closeModal();
                } else {
                    currentDetailRecordTime = null;
                    currentDetailRecord = null;
                    currentDetailRecordMode = null;
                }

                try {
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                        const key = localStorage.key(i);
                        if (!key) continue;
                        if (key.startsWith(HISTORY_DETAIL_MODE_PREFIX) || key.startsWith(HISTORY_DETAIL_EXPANDED_PREFIX)) {
                            localStorage.removeItem(key);
                        }
                    }
                } catch (_) { }

                try {
                    const body = document.getElementById('modalBody');
                    if (body) body.innerHTML = '';
                } catch (_) { }
            }
        } catch (e) {
            console.warn('[存储监听] 清空备份历史后的 UI 清理失败:', e);
        }
    }

    // 成功备份后（自动/手动/切换），立即清理 Canvas 永久栏目内的颜色标识，并清空显式移动集合
    try {
        if (currentView === 'canvas' && changes.syncHistory) {
            const newHistory = changes.syncHistory.newValue || [];
            const oldHistory = changes.syncHistory.oldValue || [];
            if (Array.isArray(newHistory) && newHistory.length > 0) {
                const isAppended = !Array.isArray(oldHistory) || newHistory.length > oldHistory.length;
                const lastRec = newHistory[newHistory.length - 1];
                if (isAppended && lastRec && lastRec.status === 'success') {
                    const fp = lastRec.fingerprint || lastRec.time || String(Date.now());
                    if (fp !== window.__lastResetFingerprint) {
                        // 清空显式移动集合，避免蓝标残留
                        try { explicitMovedIds = new Map(); } catch (_) { }
                        resetPermanentSectionChangeMarkers();
                        window.__lastResetFingerprint = fp;
                    }
                }
            }
        }
    } catch (e) {
        console.warn('[存储监听] 备份后清理永久栏目标识失败:', e);
    }

    // 如果正在撤销过程中，不执行自动刷新，让后台完全完成
    if (revertInProgress) {
        console.log('[存储监听] 正在撤销过程中，暂时跳过自动刷新');
        return;
    }

    // Canvas 视图：lastSyncOperations 只是“结构变化标记”，真正的永久栏目树已由 bookmarks API 增量更新。
    // 若在这里做全量重载/重渲，会造成永久栏目明显闪烁与抖动（尤其在频繁移动/修改时）。
    const isCanvasOpsOnly =
        currentView === 'canvas' &&
        !!changes.lastSyncOperations &&
        !changes.syncHistory &&
        !changes.lastSyncTime &&
        !changes.lastBookmarkData;
    if (isCanvasOpsOnly) {
        console.log('[存储监听] Canvas下仅 lastSyncOperations 变化，跳过自动刷新以避免永久栏目闪烁');
        return;
    }

    // 检查相关数据是否变化 - 实时更新
    if (changes.syncHistory || changes.lastSyncTime || changes.lastBookmarkData || changes.lastSyncOperations) {
        console.log('[存储监听] 书签数据变化，立即重新加载...');

        // 清除缓存，强制重新加载
        cachedCurrentChanges = null;
        cachedBookmarkTree = null;
        cachedTreeData = null; // 清除树视图缓存
        cachedOldTree = null;
        lastTreeFingerprint = null;
        lastTreeSnapshotVersion = null;
        cachedCurrentTreeIndex = null;
        jsonDiffRendered = false; // 重置JSON渲染标志

        // 立即重新加载数据
        loadAllData({ skipRender: true }).then(async () => {
            console.log('[存储监听] 数据重新加载完成');

            // 如果当前在 current-changes 视图，使用重试机制刷新
            if (currentView === 'current-changes') {
                console.log('[存储监听] 刷新当前变化视图（带重试，强制刷新）');
                await renderCurrentChangesViewWithRetry(3, true);
            }

            // 如果当前在 tree 视图，刷新树视图（强制刷新）
            if (currentView === 'tree') {
                console.log('[存储监听] 刷新书签树与JSON视图');
                await renderTreeView(true);
            }

            // 如果当前在 canvas 视图，同步刷新永久栏目（强制刷新）
            if (currentView === 'canvas') {
                // Canvas 视图：永久栏目已经由 bookmarks API 增量更新，频繁强制重渲会造成明显“刷新/闪烁/抖动”
                // 这里仅在“尚未渲染出树”时才做一次兜底渲染，其余情况保持 DOM 稳定以优化观感。
                const treeContainer = document.getElementById('bookmarkTree');
                const treeHasDom = !!(treeContainer && treeContainer.children && treeContainer.children.length > 0);
                if (!treeHasDom) {
                    console.log('[存储监听] Canvas 永久栏目尚未渲染，执行一次兜底渲染');
                    await renderTreeView(true);
                    if (window.CanvasModule && window.CanvasModule.enhance) {
                        try { window.CanvasModule.enhance(); } catch (e) { console.warn('[Canvas] enhance失败:', e); }
                    }
                } else {
                    console.log('[存储监听] Canvas 永久栏目已存在，跳过强制重渲以避免闪烁');
                }
            }

            // 如果当前在 additions 视图，刷新添加记录视图
            if (currentView === 'additions') {
                console.log('[存储监听] 刷新书签温故视图');
                await renderAdditionsView();
            }

            // 如果当前在 history 视图，刷新历史记录视图
            if (currentView === 'history') {
                console.log('[存储监听] 刷新历史记录视图');
                await renderHistoryView();
            }
        });

        // 并行预加载其他视图
        setTimeout(() => {
            preloadAllViews();
        }, 500);
    }

    // 主题变化（只在没有覆盖设置时跟随主UI）
    if (changes.currentTheme && !hasThemeOverride()) {
        const newTheme = changes.currentTheme.newValue;
        console.log('[存储监听] 主题变化，跟随主UI:', newTheme);
        currentTheme = newTheme;
        document.documentElement.setAttribute('data-theme', currentTheme);

        // 更新主题切换按钮图标
        const icon = document.querySelector('#themeToggle i');
        if (icon) {
            icon.className = currentTheme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
        }
    }

    // 语言变化（只在没有覆盖设置时跟随主UI）
    if (changes.preferredLang && !hasLangOverride()) {
        const newLang = changes.preferredLang.newValue;
        console.log('[存储监听] 语言变化，跟随主UI:', newLang);
        currentLang = newLang;
        window.currentLang = currentLang; // 同步到 window

        // 更新语言切换按钮文本
        const langText = document.querySelector('#langToggle .lang-text');
        if (langText) {
            langText.textContent = currentLang === 'zh_CN' ? 'EN' : '中';
        }

        // 应用新语言到所有UI元素
        applyLanguage();

        // 重新渲染当前视图以应用语言
        renderCurrentView();

        // 刷新书签关联记录列表（更新badge文字）
        refreshBrowsingRelatedHistory();
    }

    // 翻牌历史变化（用于实时刷新热力图）
    if (changes.flipHistory && currentView === 'recommend') {
        loadHeatmapData();
    }
}

// =============================================================================
// 书签API监听（实时更新书签树）
// =============================================================================

function setupBookmarkListener() {
    if (!browserAPI.bookmarks) {
        console.warn('[书签监听] 书签API不可用');
        return;
    }

    console.log('[书签监听] 设置书签API监听器');

    // 书签创建
    browserAPI.bookmarks.onCreated.addListener(async (id, bookmark) => {
        console.log('[书签监听] 书签创建:', bookmark.title);
        try {
            addBookmarkToAdditionsCache(bookmark);
            // S值计算由background.js的bookmarks.onCreated监听器处理
            // 支持 tree 和 canvas 视图（canvas视图包含永久栏目的书签树）
            if (currentView === 'tree' || currentView === 'canvas') {
                await applyIncrementalCreateToTree(id, bookmark);
                scheduleCachedCurrentTreeSnapshotRefresh('onCreated');
            }
            clearCanvasLazyChangeHints('onCreated');
            // 立即刷新当前变化（轻量重绘容器，不刷新页面）
            if (currentView === 'current-changes') {
                await renderCurrentChangesViewWithRetry(1, true);
            }

            // 书签集合变化会影响「点击记录」「点击排行」「书签关联记录」
            // 这里使用全量重建（仅限最近一年的历史，内部有lookback与去重）
            scheduleHistoryRefresh({ forceFull: true });
        } catch (e) {
            // 仅记录错误，不触发完全刷新以避免页面闪烁和滚动位置丢失
            console.warn('[书签监听] onCreated 处理异常:', e);
        }
    });

    // 书签删除
    browserAPI.bookmarks.onRemoved.addListener(async (id, removeInfo) => {
        console.log('[书签监听] 书签删除:', id);
        try {
            removeBookmarkFromAdditionsCache(id);
            // 从S值缓存中删除该书签
            if (typeof removeCachedScore === 'function') {
                await removeCachedScore(id);
            }
            // 删除对应的 favicon 缓存
            // removeInfo.node 包含被删除书签的信息（包括 URL）
            if (removeInfo.node && removeInfo.node.url) {
                FaviconCache.clear(removeInfo.node.url);
            }

            // 支持 tree 和 canvas 视图（canvas视图包含永久栏目的书签树）
            if (currentView === 'tree' || currentView === 'canvas') {
                applyIncrementalRemoveFromTree(id);
                scheduleCachedCurrentTreeSnapshotRefresh('onRemoved');
            }
            clearCanvasLazyChangeHints('onRemoved');
            if (currentView === 'current-changes') {
                await renderCurrentChangesViewWithRetry(1, true);
            }

            // 书签被删除后，对应的点击记录与排行需要重算
            scheduleHistoryRefresh({ forceFull: true });
        } catch (e) {
            // 仅记录错误，不触发完全刷新以避免页面闪烁和滚动位置丢失
            console.warn('[书签监听] onRemoved 处理异常:', e);
        }
    });

    // 书签修改
    browserAPI.bookmarks.onChanged.addListener(async (id, changeInfo) => {
        console.log('[书签监听] 书签修改:', changeInfo);
        try {
            updateBookmarkInAdditionsCache(id, changeInfo);

            // URL或标题变化时，清除T值缓存并重算S值
            if (changeInfo.url || changeInfo.title) {
                // P10修复：书签URL/标题变化时，清除整个T值缓存以确保正确性
                // 因为无法可靠获取修改前的旧URL/标题，直接让缓存重新加载
                if (trackingRankingCache.loaded) {
                    clearTrackingRankingCache();
                    console.log('[书签修改] 已清除T值缓存（URL或标题变化）');
                }
                // 发消息给background.js重新计算该书签的S值
                browserAPI.runtime.sendMessage({ action: 'updateBookmarkScore', bookmarkId: id });
                console.log('[书签修改] 已请求background更新S值:', id);
            }

            // 支持 tree 和 canvas 视图（canvas视图包含永久栏目的书签树）
            if (currentView === 'tree' || currentView === 'canvas') {
                await applyIncrementalChangeToTree(id, changeInfo);
                scheduleCachedCurrentTreeSnapshotRefresh('onChanged');
            }
            clearCanvasLazyChangeHints('onChanged');
            if (currentView === 'current-changes') {
                await renderCurrentChangesViewWithRetry(1, true);
            }

            // 书签URL或标题变化会影响匹配结果，重建最近一年的点击记录
            scheduleHistoryRefresh({ forceFull: true });
        } catch (e) {
            // 仅记录错误，不触发完全刷新以避免页面闪烁和滚动位置丢失
            console.warn('[书签监听] onChanged 处理异常:', e);
        }
    });

    // 书签移动
    browserAPI.bookmarks.onMoved.addListener(async (id, moveInfo) => {
        console.log('[书签监听] 书签移动:', id);

        try {
            moveBookmarkInAdditionsCache(id, moveInfo);
            // 将本次移动记为显式主动移动，确保稳定显示蓝色标识
            explicitMovedIds.set(id, Date.now() + Infinity);

            // 支持 tree 和 canvas 视图（canvas视图包含永久栏目的书签树）
            if (currentView === 'tree' || currentView === 'canvas') {
                await applyIncrementalMoveToTree(id, moveInfo);
                applyIncrementalMoveToCachedCurrentTree(id, moveInfo);
                scheduleCachedCurrentTreeSnapshotRefresh('onMoved');
            }
            clearCanvasLazyChangeHints('onMoved');
            if (currentView === 'current-changes') {
                await renderCurrentChangesViewWithRetry(1, true);
            }
        } catch (e) {
            // 仅记录错误，不触发完全刷新以避免页面闪烁和滚动位置丢失
            console.warn('[书签监听] onMoved 处理异常:', e);
        }
    });
}

// 如果当前在树视图或Canvas视图，刷新书签树
async function refreshTreeViewIfVisible() {
    // 支持 tree 和 canvas 视图（canvas视图包含永久栏目的书签树）
    if (currentView === 'tree' || currentView === 'canvas') {
        console.log('[书签监听] 检测到书签变化，刷新树视图');

        // 清除缓存，强制刷新
        cachedBookmarkTree = null;
        cachedTreeData = null;
        lastTreeFingerprint = null;
        lastTreeSnapshotVersion = null;
        cachedCurrentTreeIndex = null;
        jsonDiffRendered = false;

        // 延迟一点刷新，避免频繁更新
        setTimeout(async () => {
            try {
                await renderTreeView(true);
                console.log('[书签监听] 树视图刷新完成');
            } catch (error) {
                console.error('[书签监听] 刷新树视图失败:', error);
            }
        }, 200);
    }
}

// =============================================================================
// 消息监听
// =============================================================================

function setupRealtimeMessageListener() {
    if (messageListenerRegistered) return;
    messageListenerRegistered = true;

    browserAPI.runtime.onMessage.addListener((message) => {
        if (!message || !message.action) return;

        if (message.action === 'analysisUpdated') {
            if (!viewerInitialized) {
                deferredAnalysisMessage = message;
                return;
            }
            handleAnalysisUpdatedMessage(message);
        } else if (message.action === 'trackingDataUpdated') {
            // T值数据更新，增量更新缓存
            if (message.url || message.title) {
                // 增量更新缓存（不清除整个缓存，只更新变化的条目）
                if (trackingRankingCache.loaded) {
                    const stat = {
                        url: message.url,
                        title: message.title,
                        compositeMs: message.compositeMs || 0
                    };
                    // 累加到现有值（如果已存在）
                    if (message.url && trackingRankingCache.byUrl.has(message.url)) {
                        const existing = trackingRankingCache.byUrl.get(message.url);
                        stat.compositeMs = existing.compositeMs + (message.compositeMs || 0);
                    } else if (message.title && trackingRankingCache.byTitle.has(message.title)) {
                        const existing = trackingRankingCache.byTitle.get(message.title);
                        stat.compositeMs = existing.compositeMs + (message.compositeMs || 0);
                    }
                    // 更新双索引
                    if (message.title) {
                        trackingRankingCache.byTitle.set(message.title, stat);
                    }
                    if (message.url) {
                        trackingRankingCache.byUrl.set(message.url, stat);
                    }
                    console.log('[T值缓存] 增量更新:', message.title || message.url);
                }

                // T值变化后，发消息给background.js触发S值增量更新
                // background.js也会监听trackingDataUpdated，即使html页面没打开也能更新
                if (message.url) {
                    browserAPI.runtime.sendMessage({ action: 'updateBookmarkScoreByUrl', url: message.url });
                }
            }
        } else if (message.action === 'clearFaviconCache') {
            // 书签URL被修改，清除favicon缓存（静默）
            if (message.url) {
                FaviconCache.clear(message.url);
            }
        } else if (message.action === 'updateFaviconFromTab') {
            // 从打开的 tab 更新 favicon（静默）
            if (message.url && message.favIconUrl) {
                FaviconCache.save(message.url, message.favIconUrl).then(() => {
                    // 更新页面上对应的 favicon 图标
                    updateFaviconImages(message.url, message.favIconUrl);
                }).catch(() => {
                    // 静默处理错误
                });
            }
        } else if (message.action === 'captureCanvasThumbnailNow') {
            // 主 UI 请求当前 Canvas 立即截图
            if (currentView === 'canvas') {
                try {
                    captureCanvasThumbnail();
                } catch (e) {
                    console.warn('[Canvas Thumbnail] 即时截图失败:', e);
                }
            }
        } else if (message.action === 'clearExplicitMoved') {
            try {
                explicitMovedIds = new Map();
                if (currentView === 'canvas') {
                    resetPermanentSectionChangeMarkers();
                }
            } catch (e) { /* 忽略 */ }
        } else if (message.action === 'recentMovedBroadcast' && message.id) {
            // 后台广播的最近被移动的ID，立即记入显式集合（仅标记这个节点）
            // 这确保用户拖拽的节点优先被标识为蓝色"moved"
            // 永久记录，不再有时间限制
            explicitMovedIds.set(message.id, Date.now() + Infinity);
            // 若在树视图，立即给这个被拖拽的节点补蓝标（不影响其他节点）
            if (currentView === 'tree' || currentView === 'canvas') {
                try {
                    const container = document.getElementById('bookmarkTree');
                    const item = container && container.querySelector(`.tree-item[data-node-id="${message.id}"]`);
                    if (item) {
                        const badges = item.querySelector('.change-badges');
                        if (badges) {
                            const existing = badges.querySelector('.change-badge.moved');
                            if (existing) existing.remove();
                            let tip = '';
                            try {
                                if (cachedOldTree) {
                                    const bcSelf = getNamedPathFromTree(cachedOldTree, String(message.id));
                                    if (bcSelf) tip = breadcrumbToSlashFolders(bcSelf);
                                }
                            } catch (_) { }
                            if (!tip) tip = '/';
                            badges.insertAdjacentHTML('beforeend', `<span class="change-badge moved" data-move-from="${escapeHtml(tip)}" title="${escapeHtml(tip)}"><i class="fas fa-arrows-alt"></i><span class="move-tooltip">${slashPathToChipsHTML(tip)}</span></span>`);
                            item.classList.add('tree-change-moved');
                        }
                    }
                } catch (_) { }
            }
        } else if (message.action === 'clearLocalStorage') {
            // 收到来自 background.js 的清除 localStorage 请求（"恢复到初始状态"功能）
            console.log('[history.js] 收到清除 localStorage 请求');
            try {
                localStorage.clear();
                console.log('[history.js] localStorage 已清除');
            } catch (e) {
                console.warn('[history.js] 清除 localStorage 失败:', e);
            }
        }
    });
}

// ==================== 事件委托设置 ====================
// 使用事件委托处理所有按钮的data-action属性，避免CSP错误
function setupEventDelegation() {
    // 使用事件委托处理按钮点击
    document.addEventListener('click', async (event) => {
        const button = event.target.closest('button[data-action]');
        if (!button) return;

        const action = button.dataset.action;
        console.log('[事件委托] 处理按钮点击:', action);

        try {
            switch (action) {
                case 'copyCurrentDiff':
                    await window.copyCurrentDiff();
                    break;
                case 'copyHistoryDiff':
                    // 获取recordTime（可能在button上或父元素上）
                    const recordTime = button.dataset.recordTime || button.closest('[data-record-time]')?.dataset.recordTime;
                    if (recordTime) {
                        await window.copyHistoryDiff(recordTime);
                    }
                    break;

                case 'copyJSONDiff':
                    await copyJSONDiff();
                    break;
                default:
                    console.warn('[事件委托] 未知的action:', action);
            }
        } catch (error) {
            console.error('[事件委托] 处理按钮点击失败:', action, error);
        }
    });
}

async function handleAnalysisUpdatedMessage(message) {
    if (realtimeUpdateInProgress) {
        pendingAnalysisMessage = message;
        return;
    }

    realtimeUpdateInProgress = true;
    try {
        await processAnalysisUpdatedMessage(message);
    } catch (error) {
        console.error('[消息监听] 处理 analysisUpdated 失败:', error);
    } finally {
        realtimeUpdateInProgress = false;
        if (pendingAnalysisMessage) {
            const nextMessage = pendingAnalysisMessage;
            pendingAnalysisMessage = null;
            handleAnalysisUpdatedMessage(nextMessage);
        }
    }
}

async function processAnalysisUpdatedMessage(message) {
    console.log('[消息监听] 收到 analysisUpdated 消息:', {
        bookmarkDiff: message.bookmarkDiff,
        folderDiff: message.folderDiff,
        bookmarkCount: message.bookmarkCount,
        folderCount: message.folderCount
    });

    const analysisSignature = JSON.stringify({
        bookmarkDiff: message.bookmarkDiff,
        folderDiff: message.folderDiff,
        bookmarkMoved: message.bookmarkMoved,
        folderMoved: message.folderMoved,
        bookmarkModified: message.bookmarkModified,
        folderModified: message.folderModified,
        bookmarkCount: message.bookmarkCount,
        folderCount: message.folderCount
    });

    if (analysisSignature === lastAnalysisSignature) {
        console.log('[消息监听] 数据未变化，跳过刷新');
        return;
    }

    lastAnalysisSignature = analysisSignature;

    cachedCurrentChanges = null;
    cachedBookmarkTree = null;

    if (currentView === 'current-changes') {
        // 直接轻量刷新当前变化视图
        await renderCurrentChangesViewWithRetry(1, false);
    }

    setTimeout(() => {
        preloadAllViews();
    }, 500);
}

// =============================================================================
// 工具函数
// =============================================================================

function formatTime(timestamp) {
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
}

// 用于导出文件名的本地时间格式化（避免 toISOString 的 UTC 时区问题）
function formatTimeForFilename(timestamp) {
    const date = timestamp ? new Date(timestamp) : new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
}

function sanitizeFilenameSegment(text) {
    return String(text || '')
        .replace(/[\\/:*?"<>|]/g, '_')
        .replace(/\s+/g, '_')
        .replace(/_+/g, '_')
        .replace(/^_+|_+$/g, '');
}

function buildSequenceMapFromHistory(historyRecords) {
    const records = Array.isArray(historyRecords) ? historyRecords.slice() : [];
    records.sort((a, b) => Number(a?.time || 0) - Number(b?.time || 0));
    const map = new Map();
    const used = new Set();
    for (const r of records) {
        const seq = Number(r?.seqNumber);
        if (Number.isFinite(seq) && seq > 0) used.add(seq);
    }
    let next = 1;
    for (const r of records) {
        let seq = Number(r?.seqNumber);
        if (!(Number.isFinite(seq) && seq > 0)) {
            while (used.has(next)) next++;
            seq = next;
            used.add(seq);
            next++;
        }
        map.set(String(r.time), seq);
    }
    return map;
}

function formatSelectedSequenceRanges(seqNumbers, lang) {
    const delim = lang === 'zh_CN' ? '、' : ',';
    const nums = Array.from(new Set((seqNumbers || []).filter(n => Number.isFinite(n) && n > 0)))
        .sort((a, b) => a - b);
    if (nums.length === 0) return '';

    const parts = [];
    let start = nums[0];
    let end = nums[0];
    for (let i = 1; i < nums.length; i++) {
        const n = nums[i];
        if (n === end + 1) {
            end = n;
            continue;
        }
        parts.push(start === end ? String(start) : `${start}-${end}`);
        start = n;
        end = n;
    }
    parts.push(start === end ? String(start) : `${start}-${end}`);
    return parts.join(delim);
}

function generateBookmarkExportHTMLFromTree(treeRoot) {
    const escapeAttr = (s) => String(s ?? '').replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    const escapeText = (s) => String(s ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    let html = '<!DOCTYPE NETSCAPE-Bookmark-file-1>\n';
    html += '<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">\n';
    html += '<TITLE>Bookmarks</TITLE>\n';
    html += '<H1>Bookmarks</H1>\n';
    html += '<DL><p>\n';

    const generateNodeHTML = (node, indentLevel) => {
        const indent = '    '.repeat(indentLevel);
        const title = escapeText(node?.title || '');
        const url = node?.url ? String(node.url) : '';
        const isFolder = !url && node && Array.isArray(node.children);

        if (isFolder) {
            let result = `${indent}<DT><H3>${title}</H3>\n`;
            result += `${indent}<DL><p>\n`;
            node.children.forEach(child => {
                result += generateNodeHTML(child, indentLevel + 1);
            });
            result += `${indent}</DL><p>\n`;
            return result;
        }

        if (url) {
            return `${indent}<DT><A HREF="${escapeAttr(url)}">${title}</A>\n`;
        }

        // fallback: treat as folder-ish if children exists, otherwise skip
        if (node && Array.isArray(node.children)) {
            let result = `${indent}<DT><H3>${title}</H3>\n`;
            result += `${indent}<DL><p>\n`;
            node.children.forEach(child => {
                result += generateNodeHTML(child, indentLevel + 1);
            });
            result += `${indent}</DL><p>\n`;
            return result;
        }

        return '';
    };

    const nodes = Array.isArray(treeRoot) ? treeRoot : [treeRoot];
    nodes.forEach(root => {
        if (!root) return;
        if (root.title) {
            html += generateNodeHTML({ title: root.title, children: root.children || [] }, 1);
            return;
        }
        if (Array.isArray(root.children)) {
            root.children.forEach(child => {
                html += generateNodeHTML(child, 1);
            });
        }
    });

    html += '</DL><p>\n';
    return html;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showLoading() {
    document.querySelectorAll('.view.active .history-commits, .view.active .additions-container, .view.active .bookmark-tree').forEach(el => {
        el.innerHTML = `<div class="loading">${i18n.loading[currentLang]}</div>`;
    });
}

function showError(message) {
    const container = document.querySelector('.view.active > div:last-child');
    if (container) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fas fa-exclamation-triangle"></i></div>
                <div class="empty-state-title">${escapeHtml(message)}</div>
            </div>
        `;
    }
}

function showToast(message) {
    // 简单的提示功能
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        background: var(--accent-primary);
        color: white;
        border-radius: 8px;
        box-shadow: var(--shadow-lg);
        z-index: 10000;
        animation: slideIn 0.3s ease;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);

    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => toast.remove(), 300);
    }, 2000);
}



// 添加动画样式
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
`;
document.head.appendChild(style);

// =============================================================================
// 复制Diff功能
// =============================================================================

// 复制当前Changes视图的diff（JSON格式，限制数量以防止卡顿）
window.copyCurrentDiff = async function () {
    try {
        const changeData = await getDetailedChanges(false);

        // 获取当前书签树用于生成git diff
        const currentTree = await new Promise(resolve => {
            browserAPI.bookmarks.getTree(resolve);
        });

        // 获取上一次备份的树
        let oldTree = null;
        const lastData = await new Promise(resolve => {
            browserAPI.storage.local.get(['lastBookmarkData'], (data) => {
                resolve(data.lastBookmarkData);
            });
        });

        if (lastData && lastData.bookmarkTree) {
            oldTree = lastData.bookmarkTree;
        }

        // 生成Git diff格式
        let diffText = '';

        if (oldTree && currentTree) {
            // 生成文件树的git diff
            const oldLines = bookmarkTreeToLines(oldTree);
            const newLines = bookmarkTreeToLines(currentTree);
            const hunks = generateGitDiff(oldLines, newLines);
            diffText = hunksToGitDiffText(hunks, 'bookmarks.html', 'bookmarks.html', currentLang);
        }

        // 添加变化统计头部
        let result = '';
        result += `# 书签变化统计\n`;
        result += `# 生成时间: ${new Date().toLocaleString()}\n`;
        result += `#\n`;

        if (changeData.stats) {
            result += `# 数量变化: `;
            if (changeData.stats.bookmarkDiff !== 0) {
                result += `书签 ${changeData.stats.bookmarkDiff > 0 ? '+' : ''}${changeData.stats.bookmarkDiff}`;
            }
            if (changeData.stats.folderDiff !== 0) {
                if (changeData.stats.bookmarkDiff !== 0) result += ', ';
                result += `文件夹 ${changeData.stats.folderDiff > 0 ? '+' : ''}${changeData.stats.folderDiff}`;
            }
            result += `\n`;
        }

        // 变化明细
        if (changeData.added && changeData.added.length > 0) {
            result += `# 新增: ${changeData.added.length}项\n`;
        }
        if (changeData.deleted && changeData.deleted.length > 0) {
            result += `# 删除: ${changeData.deleted.length}项\n`;
        }
        if (changeData.moved && changeData.moved.length > 0) {
            result += `# 移动: ${changeData.moved.length}项\n`;
        }
        if (changeData.modified && changeData.modified.length > 0) {
            result += `# 修改: ${changeData.modified.length}项\n`;
        }
        result += `#\n`;

        result += diffText;

        await navigator.clipboard.writeText(result);
        showToast(currentLang === 'zh_CN' ? 'Git Diff已复制到剪贴板' : 'Git Diff copied to clipboard');
    } catch (error) {
        console.error('[复制Diff] 失败:', error);
        showToast(currentLang === 'zh_CN' ? '复制失败' : 'Copy failed');
    }
};



// 复制历史记录的diff（JSON格式，排除bookmarkTree以防止卡顿）
window.copyHistoryDiff = async function (recordTime) {
    try {
        const recordIndex = syncHistory.findIndex(r => r.time === recordTime);
        if (recordIndex === -1) {
            showToast(currentLang === 'zh_CN' ? '未找到记录' : 'Record not found');
            return;
        }

        const record = syncHistory[recordIndex];
        let result = '';

        // 生成diff文件头
        result += `# 备份历史记录 - Git Diff\n`;
        result += `# 备份时间: ${record.time || new Date().toLocaleString()}\n`;
        result += `# 备份类型: ${record.type || 'unknown'}\n`;
        result += `# 备份方向: ${record.direction || 'unknown'}\n`;
        result += `# 备份状态: ${record.status || 'unknown'}\n`;
        if (record.note) {
            result += `# 备份备注: ${record.note}\n`;
        }
        result += `#\n`;

        // 添加统计信息
        if (record.bookmarkStats) {
            result += `# 当前统计:\n`;
            result += `# - 书签数: ${record.bookmarkStats.currentBookmarkCount || 0}\n`;
            result += `# - 文件夹数: ${record.bookmarkStats.currentFolderCount || 0}\n`;
            if (record.bookmarkStats.prevBookmarkCount !== undefined) {
                result += `# - 书签变化: ${record.bookmarkStats.bookmarkDiff > 0 ? '+' : ''}${record.bookmarkStats.bookmarkDiff || 0}\n`;
            }
            if (record.bookmarkStats.prevFolderCount !== undefined) {
                result += `# - 文件夹变化: ${record.bookmarkStats.folderDiff > 0 ? '+' : ''}${record.bookmarkStats.folderDiff || 0}\n`;
            }
            result += `#\n`;
        }

        // 如果是第一次备份
        if (record.isFirstBackup) {
            result += `# ===== 首次备份 - 初始内容 =====\n`;
            if (record.bookmarkTree) {
                const lines = bookmarkTreeToLines(record.bookmarkTree);
                result += `diff --git a/bookmarks.html b/bookmarks.html\n`;
                result += `new file mode 100644\n`;
                result += `index 0000000..1111111\n`;
                result += `--- /dev/null\n`;
                result += `+++ b/bookmarks.html\n`;

                // 生成所有行为新增
                lines.forEach((line, idx) => {
                    result += `+${line.line}\n`;
                });
            }
        } else if (recordIndex > 0) {
            // 获取前一个备份
            const prevRecord = syncHistory[recordIndex - 1];
            if (prevRecord && record.bookmarkTree && prevRecord.bookmarkTree) {
                // 对比两个备份
                const oldLines = bookmarkTreeToLines(prevRecord.bookmarkTree);
                const newLines = bookmarkTreeToLines(record.bookmarkTree);
                const hunks = generateGitDiff(oldLines, newLines);
                const diffText = hunksToGitDiffText(hunks, 'bookmarks.html', 'bookmarks.html', currentLang);
                result += diffText;
            } else {
                result += `# 无法生成完整的diff（缺少前一个备份的数据）\n`;
                if (record.bookmarkStats) {
                    result += `# 数量变化:\n`;
                    if (record.bookmarkStats.bookmarkDiff !== 0) {
                        result += `#   书签: ${record.bookmarkStats.bookmarkDiff > 0 ? '+' : ''}${record.bookmarkStats.bookmarkDiff}\n`;
                    }
                    if (record.bookmarkStats.folderDiff !== 0) {
                        result += `#   文件夹: ${record.bookmarkStats.folderDiff > 0 ? '+' : ''}${record.bookmarkStats.folderDiff}\n`;
                    }
                }
            }
        } else {
            result += `# 无法生成diff（这是第一个备份）\n`;
        }

        await navigator.clipboard.writeText(result);

        const message = record.isFirstBackup
            ? (currentLang === 'zh_CN' ? '已复制首次备份的Git Diff' : 'Copied first backup Git Diff')
            : (currentLang === 'zh_CN' ? 'Git Diff已复制到剪贴板' : 'Git Diff copied to clipboard');
        showToast(message);
    } catch (error) {
        console.error('[复制历史Diff] 失败:', error);
        showToast(currentLang === 'zh_CN' ? '复制失败' : 'Copy failed');
    }
};


// 从书签树提取书签列表（扁平化，包含路径信息）
function extractBookmarksFromTree(tree) {
    const bookmarks = [];

    function traverse(nodes, path = []) {
        if (!nodes) return;

        nodes.forEach(node => {
            if (node.url) {
                // 这是一个书签
                bookmarks.push({
                    title: node.title,
                    url: node.url,
                    folder: path.join(' > ') || (currentLang === 'zh_CN' ? '根目录' : 'Root'),
                    dateAdded: node.dateAdded ? new Date(node.dateAdded).toISOString() : null
                });
            } else if (node.children) {
                // 这是一个文件夹，递归处理
                traverse(node.children, [...path, node.title]);
            }
        });
    }

    if (tree && tree[0] && tree[0].children) {
        traverse(tree[0].children);
    }

    return bookmarks;
}



// 导出历史记录的diff为HTML（可视化格式）
window.exportHistoryDiffToHTML = async function (recordTime) {
    try {
        const recordIndex = syncHistory.findIndex(r => r.time === recordTime);
        if (recordIndex === -1) {
            showToast(currentLang === 'zh_CN' ? '未找到记录' : 'Record not found');
            return;
        }

        const record = syncHistory[recordIndex];

        // 获取diff数据（与copyHistoryDiff相同的逻辑）
        let diffData;

        if (record.isFirstBackup && record.bookmarkTree) {
            // 第一次备份：完整的书签列表
            const bookmarksList = extractBookmarksFromTree(record.bookmarkTree);
            diffData = {
                timestamp: record.time,
                type: 'first-backup',
                direction: record.direction,
                status: record.status,
                syncType: record.type,
                note: record.note || '',
                isFirstBackup: true,
                totalBookmarks: bookmarksList.length,
                totalFolders: record.bookmarkStats?.currentFolderCount || 0,
                bookmarks: bookmarksList
            };
        } else if (record.bookmarkTree && recordIndex > 0) {
            // 有完整书签树，可以计算详细diff
            const prevRecord = syncHistory[recordIndex - 1];
            if (prevRecord && prevRecord.bookmarkTree) {
                // 计算diff
                const oldTree = prevRecord.bookmarkTree;
                const newTree = record.bookmarkTree;

                const oldPrints = generateFingerprintsFromTree(oldTree);
                const newPrints = generateFingerprintsFromTree(newTree);

                const oldBookmarkPrints = new Set(oldPrints.bookmarks);
                const newBookmarkPrints = new Set(newPrints.bookmarks);

                const added = [];
                const deleted = [];
                const moved = [];

                // 检测新增和移动
                for (const print of newBookmarkPrints) {
                    if (!oldBookmarkPrints.has(print)) {
                        const bookmark = parseBookmarkFingerprint(print);
                        if (bookmark) {
                            let isMoved = false;
                            for (const oldPrint of oldBookmarkPrints) {
                                const oldBookmark = parseBookmarkFingerprint(oldPrint);
                                if (oldBookmark && oldBookmark.url === bookmark.url) {
                                    if (oldBookmark.path !== bookmark.path || oldBookmark.title !== bookmark.title) {
                                        isMoved = true;
                                        moved.push({
                                            ...bookmark,
                                            oldPath: oldBookmark.path,
                                            oldTitle: oldBookmark.title
                                        });
                                    }
                                    break;
                                }
                            }
                            if (!isMoved) {
                                added.push(bookmark);
                            }
                        }
                    }
                }

                // 检测删除
                for (const print of oldBookmarkPrints) {
                    if (!newBookmarkPrints.has(print)) {
                        const bookmark = parseBookmarkFingerprint(print);
                        if (bookmark) {
                            const isInMoved = moved.some(m => m.url === bookmark.url);
                            if (!isInMoved) {
                                deleted.push(bookmark);
                            }
                        }
                    }
                }

                diffData = {
                    timestamp: record.time,
                    type: 'history-diff',
                    direction: record.direction,
                    status: record.status,
                    syncType: record.type,
                    note: record.note || '',
                    bookmarkStats: record.bookmarkStats,
                    added: added,
                    deleted: deleted,
                    moved: moved,
                    hasDetailedDiff: true
                };
            } else {
                // 没有前一条记录的树，只能显示统计信息
                diffData = {
                    timestamp: record.time,
                    type: 'history-record',
                    direction: record.direction,
                    status: record.status,
                    syncType: record.type,
                    note: record.note || '',
                    bookmarkStats: record.bookmarkStats,
                    hasDetailedDiff: false
                };
            }
        } else {
            // 没有书签树，只显示统计信息
            diffData = {
                timestamp: record.time,
                type: 'history-record',
                direction: record.direction,
                status: record.status,
                syncType: record.type,
                note: record.note || '',
                bookmarkStats: record.bookmarkStats,
                hasDetailedDiff: false
            };
        }

        // 将diff数据转换为HTML
        const htmlContent = convertDiffDataToHTML(diffData);

        // 创建下载
        const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `bookmark-diff-${new Date(record.time).toISOString().replace(/[:.]/g, '-')}.html`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showToast(currentLang === 'zh_CN' ? 'Diff HTML已导出' : 'Diff HTML exported');
    } catch (error) {
        console.error('[导出Diff HTML] 失败:', error);
        showToast(currentLang === 'zh_CN' ? '导出失败' : 'Export failed');
    }
};

// 将diff数据转换为标准Netscape书签HTML格式（浏览器可导入）
function convertDiffDataToHTML(diffData) {
    const lang = currentLang || 'zh_CN';
    const isZh = lang === 'zh_CN';
    const timestamp = new Date(diffData.timestamp).toISOString();
    const dateAdded = Math.floor(new Date(diffData.timestamp).getTime() / 1000);

    // 标准Netscape书签HTML头部
    let html = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
<!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! -->
<!-- Bookmark Backup Extension - Diff Export -->
<!-- Timestamp: ${timestamp} -->
<!-- Type: ${diffData.type} -->
<!-- Status: ${diffData.status} -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p>
`;

    // 如果是首次备份，导出所有书签
    if (diffData.type === 'first-backup' && diffData.bookmarks) {
        // 按文件夹分组
        const folderMap = {};
        diffData.bookmarks.forEach(bookmark => {
            const folder = bookmark.folder || (isZh ? '根目录' : 'Root');
            if (!folderMap[folder]) {
                folderMap[folder] = [];
            }
            folderMap[folder].push(bookmark);
        });

        // 生成HTML
        Object.keys(folderMap).sort().forEach(folder => {
            const bookmarks = folderMap[folder];

            // 文件夹标题
            if (folder && folder !== (isZh ? '根目录' : 'Root')) {
                html += `    <DT><H3 ADD_DATE="${dateAdded}">${escapeHtml(folder)}</H3>\n`;
                html += `    <DL><p>\n`;

                bookmarks.forEach(bookmark => {
                    const bookmarkDate = bookmark.dateAdded ? Math.floor(new Date(bookmark.dateAdded).getTime() / 1000) : dateAdded;
                    html += `        <DT><A HREF="${escapeHtml(bookmark.url)}" ADD_DATE="${bookmarkDate}">${escapeHtml(bookmark.title)}</A>\n`;
                });

                html += `    </DL><p>\n`;
            } else {
                // 根目录的书签
                bookmarks.forEach(bookmark => {
                    const bookmarkDate = bookmark.dateAdded ? Math.floor(new Date(bookmark.dateAdded).getTime() / 1000) : dateAdded;
                    html += `    <DT><A HREF="${escapeHtml(bookmark.url)}" ADD_DATE="${bookmarkDate}">${escapeHtml(bookmark.title)}</A>\n`;
                });
            }
        });
    }
    // 如果有详细diff，按类别导出
    else if (diffData.hasDetailedDiff) {
        // 新增的书签
        if (diffData.added && diffData.added.length > 0) {
            html += `    <DT><H3 ADD_DATE="${dateAdded}">${isZh ? '新增书签' : 'Added Bookmarks'}</H3>\n`;
            html += `    <DL><p>\n`;

            // 按路径分组
            const folderMap = {};
            diffData.added.forEach(bookmark => {
                const folder = bookmark.path || (isZh ? '根目录' : 'Root');
                if (!folderMap[folder]) {
                    folderMap[folder] = [];
                }
                folderMap[folder].push(bookmark);
            });

            Object.keys(folderMap).sort().forEach(folder => {
                const bookmarks = folderMap[folder];

                if (folder && folder !== (isZh ? '根目录' : 'Root')) {
                    html += `        <DT><H3 ADD_DATE="${dateAdded}">${escapeHtml(folder)}</H3>\n`;
                    html += `        <DL><p>\n`;
                    bookmarks.forEach(bookmark => {
                        html += `            <DT><A HREF="${escapeHtml(bookmark.url)}" ADD_DATE="${dateAdded}">${escapeHtml(bookmark.title)}</A>\n`;
                    });
                    html += `        </DL><p>\n`;
                } else {
                    bookmarks.forEach(bookmark => {
                        html += `        <DT><A HREF="${escapeHtml(bookmark.url)}" ADD_DATE="${dateAdded}">${escapeHtml(bookmark.title)}</A>\n`;
                    });
                }
            });

            html += `    </DL><p>\n`;
        }

        // 删除的书签
        if (diffData.deleted && diffData.deleted.length > 0) {
            html += `    <DT><H3 ADD_DATE="${dateAdded}">${isZh ? '删除书签' : 'Deleted Bookmarks'}</H3>\n`;
            html += `    <DL><p>\n`;

            // 按路径分组
            const folderMap = {};
            diffData.deleted.forEach(bookmark => {
                const folder = bookmark.path || (isZh ? '根目录' : 'Root');
                if (!folderMap[folder]) {
                    folderMap[folder] = [];
                }
                folderMap[folder].push(bookmark);
            });

            Object.keys(folderMap).sort().forEach(folder => {
                const bookmarks = folderMap[folder];

                if (folder && folder !== (isZh ? '根目录' : 'Root')) {
                    html += `        <DT><H3 ADD_DATE="${dateAdded}">${escapeHtml(folder)}</H3>\n`;
                    html += `        <DL><p>\n`;
                    bookmarks.forEach(bookmark => {
                        html += `            <DT><A HREF="${escapeHtml(bookmark.url)}" ADD_DATE="${dateAdded}">${escapeHtml(bookmark.title)}</A>\n`;
                    });
                    html += `        </DL><p>\n`;
                } else {
                    bookmarks.forEach(bookmark => {
                        html += `        <DT><A HREF="${escapeHtml(bookmark.url)}" ADD_DATE="${dateAdded}">${escapeHtml(bookmark.title)}</A>\n`;
                    });
                }
            });

            html += `    </DL><p>\n`;
        }

        // 移动的书签
        if (diffData.moved && diffData.moved.length > 0) {
            html += `    <DT><H3 ADD_DATE="${dateAdded}">${isZh ? '移动书签' : 'Moved Bookmarks'}</H3>\n`;
            html += `    <DL><p>\n`;

            // 按新路径分组
            const folderMap = {};
            diffData.moved.forEach(bookmark => {
                const folder = bookmark.path || (isZh ? '根目录' : 'Root');
                if (!folderMap[folder]) {
                    folderMap[folder] = [];
                }
                folderMap[folder].push(bookmark);
            });

            Object.keys(folderMap).sort().forEach(folder => {
                const bookmarks = folderMap[folder];

                if (folder && folder !== (isZh ? '根目录' : 'Root')) {
                    html += `        <DT><H3 ADD_DATE="${dateAdded}">${escapeHtml(folder)}</H3>\n`;
                    html += `        <DL><p>\n`;
                    bookmarks.forEach(bookmark => {
                        const titleWithNote = bookmark.oldPath !== bookmark.path
                            ? `${escapeHtml(bookmark.title)} [${isZh ? '从' : 'from'}: ${escapeHtml(bookmark.oldPath)}]`
                            : escapeHtml(bookmark.title);
                        html += `            <DT><A HREF="${escapeHtml(bookmark.url)}" ADD_DATE="${dateAdded}">${titleWithNote}</A>\n`;
                    });
                    html += `        </DL><p>\n`;
                } else {
                    bookmarks.forEach(bookmark => {
                        const titleWithNote = bookmark.oldPath !== bookmark.path
                            ? `${escapeHtml(bookmark.title)} [${isZh ? '从' : 'from'}: ${escapeHtml(bookmark.oldPath)}]`
                            : escapeHtml(bookmark.title);
                        html += `        <DT><A HREF="${escapeHtml(bookmark.url)}" ADD_DATE="${dateAdded}">${titleWithNote}</A>\n`;
                    });
                }
            });

            html += `    </DL><p>\n`;
        }
    }
    // 如果没有详细数据，添加一个说明
    else {
        html += `    <DT><H3 ADD_DATE="${dateAdded}">${isZh ? '无详细变化数据' : 'No Detailed Changes'}</H3>\n`;
        html += `    <DL><p>\n`;
        html += `        <DT>${isZh ? '此记录仅包含统计信息，无法导出具体书签' : 'This record only contains statistics, no bookmarks available'}\n`;
        html += `    </DL><p>\n`;
    }

    html += `</DL><p>\n`;

    return html;
}

// 将书签树转换为Netscape标准HTML格式（浏览器可导入）
function convertBookmarkTreeToNetscapeHTML(bookmarkTree, timestamp) {
    const dateAdded = Math.floor(new Date(timestamp).getTime() / 1000);

    let html = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
<!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p>
`;

    // 递归处理书签树
    function processNode(node, indent = '    ') {
        if (!node) return '';

        let result = '';

        if (node.url) {
            // 这是一个书签
            const addDate = node.dateAdded ? Math.floor(node.dateAdded / 1000) : dateAdded;
            const title = escapeHtml(node.title || 'Untitled');
            const url = escapeHtml(node.url);
            result += `${indent}<DT><A HREF="${url}" ADD_DATE="${addDate}">${title}</A>\n`;
        } else if (node.children) {
            // 这是一个文件夹
            const folderDate = node.dateAdded ? Math.floor(node.dateAdded / 1000) : dateAdded;
            const folderTitle = escapeHtml(node.title || 'Untitled Folder');

            result += `${indent}<DT><H3 ADD_DATE="${folderDate}">${folderTitle}</H3>\n`;
            result += `${indent}<DL><p>\n`;

            // 处理子节点
            for (const child of node.children) {
                result += processNode(child, indent + '    ');
            }

            result += `${indent}</DL><p>\n`;
        }

        return result;
    }

    // 处理根节点的children
    if (bookmarkTree && bookmarkTree[0] && bookmarkTree[0].children) {
        for (const child of bookmarkTree[0].children) {
            html += processNode(child);
        }
    }

    html += `</DL><p>\n`;

    return html;
}
// ============================================================================
// 书签关联记录功能（浏览器历史记录 + 书签标识）
// 复用「点击记录」的 browsingHistoryCalendarInstance.bookmarksByDate 数据库
// ============================================================================

let browsingRelatedSortAsc = false; // 排序方式：false=倒序（新到旧），true=正序（旧到新）
let browsingRelatedCurrentRange = 'day'; // 当前选中的时间范围
let browsingRelatedBookmarkUrls = null; // 缓存的书签URL集合（用于标识）
let browsingRelatedBookmarkTitles = null; // 缓存的书签标题集合（用于标识）
let browsingRelatedBookmarkInfo = null; // 缓存的书签URL->标题映射（用于统计与展示）

// 初始化书签关联记录
function initBrowsingRelatedHistory() {
    const panel = document.getElementById('browsingRelatedPanel');
    if (!panel) return;

    const buttons = panel.querySelectorAll('.ranking-time-filter-btn');
    const sortBtn = document.getElementById('browsingRelatedSortBtn');
    if (!buttons.length) return;

    const allowedRanges = ['day', 'week', 'month', 'year', 'all'];

    const setActiveRange = (range, shouldPersist = true) => {
        if (!allowedRanges.includes(range)) {
            range = 'day';
        }

        browsingRelatedCurrentRange = range;

        buttons.forEach(btn => {
            if (btn.dataset.range === range) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });

        // 显示对应的时间段菜单
        showBrowsingRelatedTimeMenu(range);

        loadBrowsingRelatedHistory(range);

        if (shouldPersist) {
            try {
                localStorage.setItem('browsingRelatedActiveRange', range);
            } catch (storageErr) {
                console.warn('[BrowsingRelated] 无法保存筛选范围:', storageErr);
            }
        }
    };

    buttons.forEach(btn => {
        btn.addEventListener('click', () => {
            const range = btn.dataset.range || 'day';
            setActiveRange(range);
        });
    });

    // 排序按钮事件
    if (sortBtn) {
        // 创建tooltip
        const tooltip = document.createElement('span');
        tooltip.className = 'btn-tooltip';
        const updateTooltip = () => {
            tooltip.textContent = browsingRelatedSortAsc
                ? (i18n.currentAscending?.[currentLang] || (currentLang === 'zh_CN' ? '当前：正序' : 'Current: Ascending'))
                : (i18n.currentDescending?.[currentLang] || (currentLang === 'zh_CN' ? '当前：倒序' : 'Current: Descending'));
        };
        updateTooltip();
        sortBtn.appendChild(tooltip);

        sortBtn.addEventListener('click', () => {
            browsingRelatedSortAsc = !browsingRelatedSortAsc;
            if (browsingRelatedSortAsc) {
                sortBtn.classList.add('asc');
            } else {
                sortBtn.classList.remove('asc');
            }
            updateTooltip();
            loadBrowsingRelatedHistory(browsingRelatedCurrentRange);
        });
    }

    let initialRange = 'day';
    try {
        const saved = localStorage.getItem('browsingRelatedActiveRange');
        if (saved && allowedRanges.includes(saved)) {
            initialRange = saved;
        }
    } catch (storageErr) {
        console.warn('[BrowsingRelated] 无法读取筛选范围:', storageErr);
    }

    setActiveRange(initialRange, false);
}

// 刷新书签关联记录
async function refreshBrowsingRelatedHistory() {
    const panel = document.getElementById('browsingRelatedPanel');
    if (!panel || !panel.classList.contains('active')) return;

    const activeBtn = panel.querySelector('.ranking-time-filter-btn.active');
    const range = activeBtn ? (activeBtn.dataset.range || 'day') : 'day';

    // 清除书签URL/标题缓存（以便重新获取最新书签）
    browsingRelatedBookmarkUrls = null;
    browsingRelatedBookmarkTitles = null;
    browsingRelatedBookmarkInfo = null;

    // ✨ 等待日历数据同步完成（确保标题匹配的记录能正确显示）
    const waitForCalendarData = async () => {
        const start = Date.now();
        const timeout = 2000; // 2秒超时
        while (Date.now() - start < timeout) {
            const inst = window.browsingHistoryCalendarInstance;
            if (inst && inst.bookmarksByDate && inst.bookmarksByDate.size > 0) {
                return true;
            }
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        return false;
    };

    const dataReady = await waitForCalendarData();
    if (!dataReady) {
        console.warn('[BrowsingRelated] 等待日历数据超时');
    }

    // 直接重新加载（数据来自 browsingHistoryCalendarInstance）
    loadBrowsingRelatedHistory(range);
}

// 获取书签URL和标题集合（使用URL或标题匹配）
async function getBookmarkUrlsAndTitles() {
    if (browsingRelatedBookmarkUrls && browsingRelatedBookmarkTitles && browsingRelatedBookmarkInfo) {
        return {
            urls: browsingRelatedBookmarkUrls,
            titles: browsingRelatedBookmarkTitles,
            info: browsingRelatedBookmarkInfo
        };
    }

    const browserAPI = (typeof chrome !== 'undefined') ? chrome : browser;
    if (!browserAPI || !browserAPI.bookmarks || !browserAPI.bookmarks.getTree) {
        return { urls: new Set(), titles: new Set() };
    }

    const urls = new Set();
    const titles = new Set();
    const info = new Map(); // url -> { url, title, folderPath }

    const collectUrlsAndTitles = (nodes, parentPath = []) => {
        if (!Array.isArray(nodes)) return;
        for (const node of nodes) {
            if (node.url) {
                const url = node.url;
                urls.add(url);

                // 同时收集标题（去除空白后存储）
                const trimmedTitle = typeof node.title === 'string' ? node.title.trim() : '';
                if (trimmedTitle) {
                    titles.add(trimmedTitle);
                }

                // 记录URL到标题和文件夹路径的映射
                if (!info.has(url)) {
                    info.set(url, {
                        url,
                        title: trimmedTitle || url,
                        folderPath: parentPath.slice() // 复制父文件夹路径
                    });
                }
            }
            if (node.children) {
                // 构建当前节点的路径（排除根节点）
                const currentPath = node.title ? [...parentPath, node.title] : parentPath;
                collectUrlsAndTitles(node.children, currentPath);
            }
        }
    };

    try {
        const tree = await new Promise((resolve, reject) => {
            browserAPI.bookmarks.getTree((result) => {
                if (browserAPI.runtime && browserAPI.runtime.lastError) {
                    reject(browserAPI.runtime.lastError);
                } else {
                    resolve(result);
                }
            });
        });

        collectUrlsAndTitles(tree);
        browsingRelatedBookmarkUrls = urls;
        browsingRelatedBookmarkTitles = titles;
        browsingRelatedBookmarkInfo = info;
        return { urls, titles, info };
    } catch (error) {
        console.error('[BrowsingRelated] 获取书签URL和标题失败:', error);
        return { urls: new Set(), titles: new Set(), info: new Map() };
    }
}

// 获取时间范围的起始时间
function getTimeRangeStart(range) {
    const now = new Date();
    let startTime = new Date();

    switch (range) {
        case 'day':
            startTime.setHours(0, 0, 0, 0);
            break;
        case 'week':
            const dayOfWeek = now.getDay();
            const daysToMonday = (dayOfWeek === 0 ? 6 : dayOfWeek - 1);
            startTime.setDate(now.getDate() - daysToMonday);
            startTime.setHours(0, 0, 0, 0);
            break;
        case 'month':
            startTime.setDate(1);
            startTime.setHours(0, 0, 0, 0);
            break;
        case 'year':
            startTime.setMonth(0, 1);
            startTime.setHours(0, 0, 0, 0);
            break;
        case 'all':
            return 0; // 从最早时间开始
        default:
            startTime.setHours(0, 0, 0, 0);
    }

    return startTime.getTime();
}

// 获取书签关联历史数据（不渲染，仅返回数据）
async function getBrowsingRelatedHistoryData(range = 'day') {
    const browserAPI = (typeof chrome !== 'undefined') ? chrome : browser;
    if (!browserAPI || !browserAPI.history || !browserAPI.history.search) {
        return [];
    }

    try {
        const startTime = getTimeRangeStart(range);
        const endTime = Date.now();

        const historyItems = await new Promise((resolve, reject) => {
            browserAPI.history.search({
                text: '',
                startTime: startTime,
                endTime: endTime,
                maxResults: 0
            }, (results) => {
                if (browserAPI.runtime && browserAPI.runtime.lastError) {
                    reject(browserAPI.runtime.lastError);
                } else {
                    resolve(results || []);
                }
            });
        });

        return historyItems;
    } catch (error) {
        console.error('[BrowsingRelated] 获取历史数据失败:', error);
        return [];
    }
}

// 加载书签关联记录（显示所有浏览记录，标识出书签）
// 复用「点击记录」的书签集合进行标识，实现数据一致性
async function loadBrowsingRelatedHistory(range = 'day') {
    const listContainer = document.getElementById('browsingRelatedList');
    if (!listContainer) return;

    const isZh = currentLang === 'zh_CN';
    const loadingTitle = isZh ? '正在读取历史记录...' : 'Loading history...';

    listContainer.innerHTML = `
        <div class="empty-state">
            <div class="empty-state-icon"><i class="fas fa-spinner fa-spin"></i></div>
            <div class="empty-state-title">${loadingTitle}</div>
        </div>
    `;

    try {
        const browserAPI = (typeof chrome !== 'undefined') ? chrome : browser;
        if (!browserAPI || !browserAPI.history || !browserAPI.history.search) {
            throw new Error('History API not available');
        }

        // 确保「点击记录」日历已初始化
        if (typeof initBrowsingHistoryCalendar === 'function' && !window.browsingHistoryCalendarInstance) {
            console.log('[BrowsingRelated] 初始化日历...');
            initBrowsingHistoryCalendar();
        }

        // 等待日历数据加载（最多10秒）
        const waitForCalendarData = async () => {
            const start = Date.now();
            const timeout = 10000;
            while (Date.now() - start < timeout) {
                const inst = window.browsingHistoryCalendarInstance;
                if (inst && inst.bookmarksByDate && inst.bookmarksByDate.size > 0) {
                    console.log('[BrowsingRelated] 日历数据已加载，记录数:', inst.bookmarksByDate.size);
                    return inst;
                }
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            console.warn('[BrowsingRelated] 等待日历数据超时');
            return window.browsingHistoryCalendarInstance || null;
        };

        const calendar = await waitForCalendarData();

        // 获取时间范围
        const startTime = getTimeRangeStart(range);
        const endTime = Date.now();

        // 搜索所有历史记录（不限制数量）
        const historyItems = await new Promise((resolve, reject) => {
            browserAPI.history.search({
                text: '',
                startTime: startTime,
                endTime: endTime,
                maxResults: 0  // 0表示不限制数量
            }, (results) => {
                if (browserAPI.runtime && browserAPI.runtime.lastError) {
                    reject(browserAPI.runtime.lastError);
                } else {
                    resolve(results || []);
                }
            });
        });

        if (historyItems.length === 0) {
            const emptyTitle = isZh ? '该时间范围内没有历史记录' : 'No history in this time range';
            listContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i class="fas fa-history"></i></div>
                    <div class="empty-state-title">${emptyTitle}</div>
                </div>
            `;
            return;
        }

        // ✨ 使用 getVisits 获取每个URL的详细访问记录，展开为每次访问一条
        const expandedItems = [];
        const getVisitsAsync = (url) => new Promise((resolve) => {
            if (!browserAPI.history.getVisits) {
                resolve([]);
                return;
            }
            browserAPI.history.getVisits({ url }, (visits) => {
                if (browserAPI.runtime && browserAPI.runtime.lastError) {
                    resolve([]);
                } else {
                    resolve(visits || []);
                }
            });
        });

        // 并发获取所有URL的访问详情
        const visitPromises = historyItems.map(async (item) => {
            const visits = await getVisitsAsync(item.url);
            // 过滤在时间范围内的访问
            const filteredVisits = visits.filter(v =>
                v.visitTime >= startTime && v.visitTime <= endTime
            );

            if (filteredVisits.length > 0) {
                // 每次访问创建一条记录
                return filteredVisits.map(visit => ({
                    ...item,
                    lastVisitTime: visit.visitTime,
                    transition: visit.transition || '',
                    _visitId: visit.visitId
                }));
            } else {
                // 如果没有详细访问记录，使用汇总记录
                return [item];
            }
        });

        const allVisitArrays = await Promise.all(visitPromises);
        allVisitArrays.forEach(arr => expandedItems.push(...arr));

        if (expandedItems.length === 0) {
            const emptyTitle = isZh ? '该时间范围内没有历史记录' : 'No history in this time range';
            listContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i class="fas fa-history"></i></div>
                    <div class="empty-state-title">${emptyTitle}</div>
                </div>
            `;
            return;
        }

        // 用展开后的记录替换原来的
        const historyItemsExpanded = expandedItems;

        // ✨ 获取书签URL和标题集合（用于标识哪些是书签）
        // 优先从「点击记录」日历获取，保持数据一致性
        let bookmarkUrls, bookmarkTitles;

        // 优先使用 DatabaseManager 获取书签信息（最准确）
        if (calendar && calendar.dbManager) {
            console.log('[BrowsingRelated] 从DatabaseManager获取书签集合');
            const bookmarkDB = calendar.dbManager.getBookmarksDB();
            if (bookmarkDB) {
                bookmarkUrls = bookmarkDB.getAllUrls();
                bookmarkTitles = bookmarkDB.getAllTitles();
                console.log('[BrowsingRelated] DatabaseManager书签集合 - URL:', bookmarkUrls.size, 'Title:', bookmarkTitles.size);
            } else {
                // 回退到日历数据
                bookmarkUrls = new Set();
                bookmarkTitles = new Set();
            }
        } else if (calendar && calendar.bookmarksByDate && calendar.bookmarksByDate.size > 0) {
            console.log('[BrowsingRelated] 从日历提取书签集合');
            // 从日历实例中提取书签URL和标题集合
            bookmarkUrls = new Set();
            bookmarkTitles = new Set();
            for (const records of calendar.bookmarksByDate.values()) {
                if (!Array.isArray(records)) continue;
                records.forEach(record => {
                    if (record.url) bookmarkUrls.add(record.url);
                    if (record.title && record.title.trim()) bookmarkTitles.add(record.title.trim());
                });
            }
            console.log('[BrowsingRelated] 日历书签集合 - URL:', bookmarkUrls.size, 'Title:', bookmarkTitles.size);
        } else {
            console.log('[BrowsingRelated] 使用降级方案获取书签');
            // 降级方案：直接获取书签库
            const result = await getBookmarkUrlsAndTitles();
            bookmarkUrls = result.urls;
            bookmarkTitles = result.titles;
            console.log('[BrowsingRelated] 降级方案书签集合 - URL:', bookmarkUrls.size, 'Title:', bookmarkTitles.size);
        }

        // 按当前排序方式排序（使用展开后的记录）
        if (browsingRelatedSortAsc) {
            // 正序：旧到新
            historyItemsExpanded.sort((a, b) => (a.lastVisitTime || 0) - (b.lastVisitTime || 0));
        } else {
            // 倒序：新到旧
            historyItemsExpanded.sort((a, b) => (b.lastVisitTime || 0) - (a.lastVisitTime || 0));
        }

        // 渲染历史记录（根据数量和时间范围自动决定是否懒加载）
        renderBrowsingRelatedList(listContainer, historyItemsExpanded, bookmarkUrls, bookmarkTitles, range);

    } catch (error) {
        console.error('[BrowsingRelated] 加载失败:', error);
        const errorTitle = isZh ? '加载历史记录失败' : 'Failed to load history';
        const errorDesc = isZh ? '请检查浏览器权限设置' : 'Please check browser permissions';
        listContainer.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fas fa-exclamation-circle"></i></div>
                <div class="empty-state-title">${errorTitle}</div>
                <div class="empty-state-description">${errorDesc}</div>
            </div>
        `;
    }
}

// 渲染书签关联记录列表（大列表场景支持懒加载）
async function renderBrowsingRelatedList(container, historyItems, bookmarkUrls, bookmarkTitles, range) {
    if (!container) return;

    container.innerHTML = '';

    const isZh = currentLang === 'zh_CN';
    const bookmarkLabel = i18n.browsingRelatedBadgeText[currentLang];

    // ✨ 应用时间筛选
    let filteredItems = historyItems;
    if (browsingRelatedTimeFilter) {
        filteredItems = filterHistoryByTime(historyItems, browsingRelatedTimeFilter, range);
        if (filteredItems.length === 0) {
            const emptyTitle = isZh ? '没有匹配的记录' : 'No matching records';
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i class="fas fa-filter"></i></div>
                    <div class="empty-state-title">${emptyTitle}</div>
                </div>
            `;
            return;
        }
    }

    // ✨ 辅助函数：判断记录是否为书签
    const checkIsBookmark = (item) => {
        if (bookmarkUrls.has(item.url)) return true;
        if (item.title && item.title.trim() && bookmarkTitles.has(item.title.trim())) return true;
        return false;
    };

    // ✨ 辅助函数：从URL提取用于比较的键（去掉查询参数和hash）
    const getUrlKey = (url) => {
        try {
            const u = new URL(url);
            return u.origin + u.pathname; // 只保留协议+域名+路径
        } catch {
            return url;
        }
    };

    // ✨ 辅助函数：检测字符串是否是URL
    const isUrl = (str) => {
        if (!str) return false;
        return str.startsWith('http://') || str.startsWith('https://') || str.startsWith('chrome-extension://') || str.startsWith('file://');
    };

    // ✨ 辅助函数：规范化标题用于比较
    const normalizeTitle = (title) => {
        if (!title) return '';
        const trimmed = title.trim();
        // 如果标题本身是URL，则去掉查询参数进行比较
        if (isUrl(trimmed)) {
            return getUrlKey(trimmed);
        }
        return trimmed
            .replace(/\s+/g, ' ')  // 多个空白字符合并为一个空格
            .replace(/[\u200B-\u200D\uFEFF]/g, ''); // 去除零宽字符
    };

    // ✨ 合并连续相同标题的非书签记录
    // 规则：连续相同名字的浏览记录合并，书签作为分界线不合并
    const mergeConsecutiveItems = (items) => {
        const groups = [];
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const isBookmark = checkIsBookmark(item);
            // 优先使用标题，如果标题为空则使用URL的路径部分（去掉查询参数）
            const itemTitle = (item.title && item.title.trim()) ? normalizeTitle(item.title) : getUrlKey(item.url);

            if (isBookmark) {
                // 书签单独成组，不合并
                groups.push({
                    startIndex: i + 1,
                    endIndex: i + 1,
                    items: [item],
                    isBookmark: true,
                    representativeItem: item,
                    title: itemTitle
                });
            } else {
                // 非书签：检查是否可以和前一组合并
                const lastGroup = groups.length > 0 ? groups[groups.length - 1] : null;
                if (lastGroup && !lastGroup.isBookmark && lastGroup.title === itemTitle) {
                    // 合并到前一组
                    lastGroup.endIndex = i + 1;
                    lastGroup.items.push(item);
                } else {
                    // 创建新组
                    groups.push({
                        startIndex: i + 1,
                        endIndex: i + 1,
                        items: [item],
                        isBookmark: false,
                        representativeItem: item,
                        title: itemTitle
                    });
                }
            }
        }
        return groups;
    };

    // 合并后的分组
    const mergedGroups = mergeConsecutiveItems(filteredItems);

    // 懒加载规则：
    // - 当分组数 > 500 时启用懒加载（所有范围都适用）
    // - 其他情况一次性渲染全部
    const enableLazy = mergedGroups.length > 500;

    // 渲染单个分组的函数
    const renderGroup = (group) => {
        const item = group.representativeItem;
        const isBookmark = group.isBookmark;

        const itemEl = document.createElement('div');
        itemEl.className = 'related-history-item' + (isBookmark ? ' is-bookmark' : '');

        // 添加 dataset 属性用于跳转匹配
        const visitTimestamp = item.lastVisitTime || null;
        itemEl.dataset.url = item.url;
        itemEl.dataset.visitTime = visitTimestamp || Date.now();
        if (visitTimestamp) {
            itemEl.dataset.visitMinute = Math.floor(visitTimestamp / 60000);
        }
        if (item.title && item.title.trim()) {
            itemEl.dataset.title = item.title.trim();
        }

        // 获取favicon
        const faviconUrl = getFaviconUrl(item.url);

        // ✨ 格式化时间：如果合并了多条，显示时间范围
        let timeStr;
        if (group.items.length === 1) {
            // 单条记录：显示单个时间
            const visitTime = item.lastVisitTime ? new Date(item.lastVisitTime) : new Date();
            timeStr = formatTimeByRange(visitTime, range);
        } else {
            // 多条记录：显示时间范围（第一条 ~ 最后一条）
            const firstItem = group.items[0];
            const lastItem = group.items[group.items.length - 1];
            const firstTime = firstItem.lastVisitTime ? new Date(firstItem.lastVisitTime) : new Date();
            const lastTime = lastItem.lastVisitTime ? new Date(lastItem.lastVisitTime) : new Date();
            const firstTimeStr = formatTimeByRange(firstTime, range);
            const lastTimeStr = formatTimeByRange(lastTime, range);
            // 时间顺序已经由排序决定，直接按数组顺序显示
            timeStr = `${firstTimeStr} ~ ${lastTimeStr}`;
        }

        const displayTitle = (item.title && item.title.trim()) ? item.title : item.url;

        // ✨ 序号显示：如果合并了多条，显示为 "起始~结束" 格式
        const numberStr = group.startIndex === group.endIndex
            ? `${group.startIndex}`
            : `${group.startIndex}~${group.endIndex}`;

        itemEl.innerHTML = `
            <div class="related-history-number">${numberStr}</div>
            <div class="related-history-header">
                <img src="${faviconUrl}" class="related-history-favicon" alt="">
                <div class="related-history-info">
                    <div class="related-history-title">${escapeHtml(displayTitle)}</div>
                </div>
            </div>
            <div class="related-history-meta">
                <div class="related-history-time">
                    <i class="fas fa-clock"></i>
                    ${timeStr}
                </div>
                ${isBookmark ? `<div class="related-history-badge">${bookmarkLabel}</div>` : ''}
            </div>
        `;

        // 点击打开链接
        itemEl.addEventListener('click', () => {
            const browserAPI = (typeof chrome !== 'undefined') ? chrome : browser;
            if (browserAPI && browserAPI.tabs && browserAPI.tabs.create) {
                browserAPI.tabs.create({ url: item.url });
            } else {
                window.open(item.url, '_blank');
            }
        });

        return itemEl;
    };

    if (!enableLazy) {
        for (const group of mergedGroups) {
            container.appendChild(renderGroup(group));
        }
        return;
    }

    // 启用懒加载：每次追加 1000 个分组
    const PAGE_SIZE = 1000;
    let offset = 0;

    const appendNextPage = () => {
        const end = Math.min(offset + PAGE_SIZE, mergedGroups.length);

        for (let i = offset; i < end; i++) {
            container.appendChild(renderGroup(mergedGroups[i]));
        }

        offset = end;
    };

    appendNextPage();

    // 找到真正的滚动容器（.content-area）
    const scrollContainer = container.closest('.content-area') || container;

    const onScroll = () => {
        if (offset >= mergedGroups.length) return;
        // 提前加载：使用视口高度的3倍作为阈值，至少1500px
        const threshold = Math.max(1500, scrollContainer.clientHeight * 3);
        if (scrollContainer.scrollTop + scrollContainer.clientHeight + threshold >= scrollContainer.scrollHeight) {
            appendNextPage();
        }
    };

    // 清理旧的监听器
    if (scrollContainer.__browsingRelatedScrollHandler) {
        scrollContainer.removeEventListener('scroll', scrollContainer.__browsingRelatedScrollHandler);
    }
    scrollContainer.addEventListener('scroll', onScroll);
    scrollContainer.__browsingRelatedScrollHandler = onScroll;

    // 暴露懒加载状态和函数，供跳转功能使用
    container.__lazyLoadState = {
        totalItems: filteredItems.length,
        getLoadedCount: () => offset,
        loadMore: appendNextPage,
        loadAll: () => {
            while (offset < mergedGroups.length) {
                appendNextPage();
            }
        }
    };
}

// 根据时间范围格式化时间
function formatTimeByRange(date, range) {
    const isZh = currentLang === 'zh_CN';
    const hour = String(date.getHours()).padStart(2, '0');
    const minute = String(date.getMinutes()).padStart(2, '0');
    const timeOnly = `${hour}:${minute}`;

    switch (range) {
        case 'day':
            // 当天：只显示时间
            return timeOnly;

        case 'week':
            // 当周：显示周几+时间
            const weekdays = isZh
                ? ['周日', '周一', '周二', '周三', '周四', '周五', '周六']
                : ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const weekday = weekdays[date.getDay()];
            return `${weekday} ${timeOnly}`;

        case 'month':
        case 'year':
            // 当月/当年：显示月-日 时间
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${month}-${day} ${timeOnly}`;

        default:
            return timeOnly;
    }
}

// 格式化时间为日期时间格式（保留用于其他地方）
function formatRelativeTime(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hour = String(date.getHours()).padStart(2, '0');
    const minute = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day} ${hour}:${minute}`;
}

// ========== 点击排行 - 时间段菜单功能 ==========

// 全局变量：点击排行当前选中的时间筛选
let browsingRankingTimeFilter = null; // { type: 'hour'|'day'|'week'|'month', value: number|Date }
let browsingRankingCurrentRange = 'month'; // 当前选中的时间范围
let browsingRankingViewMode = 'bookmark'; // 'bookmark' 或 'folder'

// 初始化视图模式（从localStorage读取）
function initBrowsingRankingViewMode() {
    try {
        const saved = localStorage.getItem('browsingRankingViewMode');
        if (saved === 'folder' || saved === 'bookmark') {
            browsingRankingViewMode = saved;
        }
    } catch (e) {
        console.warn('[BrowsingRanking] 无法读取视图模式:', e);
    }
}

// 保存视图模式
function saveBrowsingRankingViewMode(mode) {
    browsingRankingViewMode = mode;
    try {
        localStorage.setItem('browsingRankingViewMode', mode);
    } catch (e) {
        console.warn('[BrowsingRanking] 无法保存视图模式:', e);
    }
}

// 显示点击排行的时间段菜单
async function showBrowsingRankingTimeMenu(range) {
    browsingRankingCurrentRange = range;
    const menuContainer = document.getElementById('browsingRankingTimeMenu');
    if (!menuContainer) return;

    menuContainer.innerHTML = '';
    menuContainer.style.display = 'none';
    browsingRankingTimeFilter = null; // 重置筛选

    // 初始化视图模式
    initBrowsingRankingViewMode();

    // 获取点击排行的数据
    const stats = await ensureBrowsingClickRankingStats();
    if (!stats || !stats.items || stats.items.length === 0) {
        return;
    }

    const now = new Date();
    const isZh = currentLang === 'zh_CN';

    // 创建菜单行容器（包含时间按钮和切换按钮）
    const menuRow = document.createElement('div');
    menuRow.style.display = 'flex';
    menuRow.style.alignItems = 'center';
    menuRow.style.justifyContent = 'space-between';
    menuRow.style.gap = '12px';

    // 创建时间菜单项容器
    const itemsContainer = document.createElement('div');
    itemsContainer.className = 'time-menu-items';
    itemsContainer.style.flex = '1';

    // 添加"全部"按钮（默认选中）
    const allBtn = document.createElement('button');
    allBtn.className = 'time-menu-btn active';
    allBtn.textContent = isZh ? '全部' : 'All';
    allBtn.dataset.filter = 'all';
    allBtn.addEventListener('click', () => {
        itemsContainer.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
        allBtn.classList.add('active');
        browsingRankingTimeFilter = null;
        loadBrowsingClickRanking(browsingRankingCurrentRange);
    });
    itemsContainer.appendChild(allBtn);

    // 根据范围显示不同的时间段按钮
    switch (range) {
        case 'day':
            renderRankingDayHoursMenu(itemsContainer, now, stats);
            break;
        case 'week':
            renderRankingWeekDaysMenu(itemsContainer, now, stats);
            break;
        case 'month':
            renderRankingMonthWeeksMenu(itemsContainer, now, stats);
            break;
        case 'year':
            renderRankingYearMonthsMenu(itemsContainer, now, stats);
            break;
        case 'all':
            // 全部：显示有数据的年份
            renderRankingAllYearsMenu(itemsContainer, stats);
            break;
    }

    menuRow.appendChild(itemsContainer);

    // 创建"文件夹/书签"滑块开关
    const toggleContainer = document.createElement('div');
    toggleContainer.className = 'ranking-view-toggle';
    toggleContainer.style.cssText = `
        position: relative;
        display: inline-flex;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 20px;
        padding: 3px;
        flex-shrink: 0;
    `;

    // 滑块
    const slider = document.createElement('div');
    slider.className = 'toggle-slider';
    slider.style.cssText = `
        position: absolute;
        top: 3px;
        height: calc(100% - 6px);
        width: calc(50% - 3px);
        background: linear-gradient(135deg, var(--accent-primary) 0%, #0056b3 100%);
        border-radius: 16px;
        transition: left 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        z-index: 0;
    `;
    slider.style.left = browsingRankingViewMode === 'folder' ? '3px' : 'calc(50%)';
    toggleContainer.appendChild(slider);

    // 按钮通用样式
    const btnStyle = `
        position: relative;
        z-index: 1;
        padding: 5px 12px;
        font-size: 11px;
        font-weight: 500;
        border: none;
        background: transparent;
        cursor: pointer;
        transition: color 0.2s;
        white-space: nowrap;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
        border-radius: 16px;
    `;

    // 文件夹按钮（左边）
    const folderBtn = document.createElement('button');
    folderBtn.style.cssText = btnStyle;
    folderBtn.style.color = browsingRankingViewMode === 'folder' ? '#fff' : 'var(--text-tertiary)';
    folderBtn.innerHTML = `<i class="fas fa-folder" style="font-size:11px;"></i><span>${isZh ? '文件夹' : 'Folder'}</span>`;

    // 书签按钮（右边）
    const bookmarkBtn = document.createElement('button');
    bookmarkBtn.style.cssText = btnStyle;
    bookmarkBtn.style.color = browsingRankingViewMode === 'bookmark' ? '#fff' : 'var(--text-tertiary)';
    bookmarkBtn.innerHTML = `<i class="fas fa-bookmark" style="font-size:10px;"></i><span>${isZh ? '书签' : 'Bookmark'}</span>`;

    const updateToggle = (mode) => {
        slider.style.left = mode === 'folder' ? '3px' : 'calc(50%)';
        folderBtn.style.color = mode === 'folder' ? '#fff' : 'var(--text-tertiary)';
        bookmarkBtn.style.color = mode === 'bookmark' ? '#fff' : 'var(--text-tertiary)';
    };

    folderBtn.addEventListener('click', () => {
        if (browsingRankingViewMode !== 'folder') {
            saveBrowsingRankingViewMode('folder');
            updateToggle('folder');
            loadBrowsingClickRanking(browsingRankingCurrentRange);
        }
    });

    bookmarkBtn.addEventListener('click', () => {
        if (browsingRankingViewMode !== 'bookmark') {
            saveBrowsingRankingViewMode('bookmark');
            updateToggle('bookmark');
            loadBrowsingClickRanking(browsingRankingCurrentRange);
        }
    });

    // hover效果
    [folderBtn, bookmarkBtn].forEach(btn => {
        btn.addEventListener('mouseenter', () => {
            if ((btn === folderBtn && browsingRankingViewMode !== 'folder') ||
                (btn === bookmarkBtn && browsingRankingViewMode !== 'bookmark')) {
                btn.style.color = 'var(--text-primary)';
            }
        });
        btn.addEventListener('mouseleave', () => {
            if ((btn === folderBtn && browsingRankingViewMode !== 'folder') ||
                (btn === bookmarkBtn && browsingRankingViewMode !== 'bookmark')) {
                btn.style.color = 'var(--text-tertiary)';
            }
        });
    });

    toggleContainer.appendChild(folderBtn);
    toggleContainer.appendChild(bookmarkBtn);
    menuRow.appendChild(toggleContainer);

    // 对于 'all' 范围，即使只有"全部"按钮，也要显示菜单（因为需要切换按钮）
    if (itemsContainer.children.length > 1 || range === 'all') {
        menuContainer.appendChild(menuRow);
        menuContainer.style.display = 'block';
    }
}

// 渲染点击排行当天的小时菜单
function renderRankingDayHoursMenu(container, date, stats) {
    const isZh = currentLang === 'zh_CN';
    const boundaries = stats.boundaries;
    const calendar = window.browsingHistoryCalendarInstance;
    if (!calendar || !calendar.bookmarksByDate) return;

    // 分析有数据的小时
    const hoursSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t >= boundaries.dayStart && t <= boundaries.now) {
                hoursSet.add(new Date(t).getHours());
            }
        });
    }

    Array.from(hoursSet).sort((a, b) => a - b).forEach(hour => {
        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = `${String(hour).padStart(2, '0')}:00`;
        btn.dataset.hour = hour;
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRankingTimeFilter = { type: 'hour', value: hour };
            loadBrowsingClickRanking(browsingRankingCurrentRange);
        });
        container.appendChild(btn);
    });
}

// 渲染点击排行当周的天菜单
function renderRankingWeekDaysMenu(container, date, stats) {
    const isZh = currentLang === 'zh_CN';
    const boundaries = stats.boundaries;
    const calendar = window.browsingHistoryCalendarInstance;
    if (!calendar || !calendar.bookmarksByDate) return;

    const weekdayNames = isZh
        ? ['周日', '周一', '周二', '周三', '周四', '周五', '周六']
        : ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

    // 分析有数据的天
    const daysSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t >= boundaries.weekStart && t <= boundaries.now) {
                daysSet.add(new Date(t).toDateString());
            }
        });
    }

    // 生成本周的日期
    const weekStart = new Date(boundaries.weekStart);
    for (let i = 0; i < 7; i++) {
        const dayDate = new Date(weekStart);
        dayDate.setDate(weekStart.getDate() + i);

        if (!daysSet.has(dayDate.toDateString())) continue;
        if (dayDate.getTime() > boundaries.now) continue;

        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = weekdayNames[dayDate.getDay()];
        btn.dataset.date = dayDate.toISOString();
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRankingTimeFilter = { type: 'day', value: dayDate };
            loadBrowsingClickRanking(browsingRankingCurrentRange);
        });
        container.appendChild(btn);
    }
}

// 渲染点击排行当月的周菜单
function renderRankingMonthWeeksMenu(container, date, stats) {
    const isZh = currentLang === 'zh_CN';
    const boundaries = stats.boundaries;
    const calendar = window.browsingHistoryCalendarInstance;
    if (!calendar || !calendar.bookmarksByDate) return;

    // 分析有数据的周
    const weeksSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t >= boundaries.monthStart && t <= boundaries.now) {
                weeksSet.add(getWeekNumberForRelated(new Date(t)));
            }
        });
    }

    Array.from(weeksSet).sort((a, b) => a - b).forEach(weekNum => {
        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = isZh ? `第${weekNum}周` : `W${weekNum}`;
        btn.dataset.week = weekNum;
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRankingTimeFilter = { type: 'week', value: weekNum };
            loadBrowsingClickRanking(browsingRankingCurrentRange);
        });
        container.appendChild(btn);
    });
}

// 渲染点击排行当年的月份菜单
function renderRankingYearMonthsMenu(container, date, stats) {
    const isZh = currentLang === 'zh_CN';
    const boundaries = stats.boundaries;
    const calendar = window.browsingHistoryCalendarInstance;
    if (!calendar || !calendar.bookmarksByDate) return;

    const monthNames = isZh
        ? ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月']
        : ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    // 分析有数据的月份
    const monthsSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t >= boundaries.yearStart && t <= boundaries.now) {
                monthsSet.add(new Date(t).getMonth());
            }
        });
    }

    Array.from(monthsSet).sort((a, b) => a - b).forEach(month => {
        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = monthNames[month];
        btn.dataset.month = month;
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRankingTimeFilter = { type: 'month', value: month };
            loadBrowsingClickRanking(browsingRankingCurrentRange);
        });
        container.appendChild(btn);
    });
}

// 渲染点击排行全部时间的年份菜单
function renderRankingAllYearsMenu(container, stats) {
    const isZh = currentLang === 'zh_CN';
    const calendar = window.browsingHistoryCalendarInstance;
    if (!calendar || !calendar.bookmarksByDate) return;

    // 分析有数据的年份
    const yearsSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t > 0) {
                yearsSet.add(new Date(t).getFullYear());
            }
        });
    }

    // 按年份倒序排列（最近的年份在前）
    Array.from(yearsSet).sort((a, b) => b - a).forEach(year => {
        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = isZh ? `${year}年` : `${year}`;
        btn.dataset.year = year;
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRankingTimeFilter = { type: 'year', value: year };
            loadBrowsingClickRanking(browsingRankingCurrentRange);
        });
        container.appendChild(btn);
    });
}

// 按时间筛选点击排行项目（重新计算每个时间段的点击次数）
function filterRankingItemsByTime(items, filter, boundaries) {
    if (!filter || !items || items.length === 0) return items;

    const calendar = window.browsingHistoryCalendarInstance;
    if (!calendar || !calendar.bookmarksByDate) return items;

    // 使用与原始统计相同的映射
    const stats = browsingClickRankingStats;
    if (!stats || !stats.bookmarkKeyMap || !stats.bookmarkInfoMap) return items;

    const bookmarkKeyMap = stats.bookmarkKeyMap;
    const bookmarkInfoMap = stats.bookmarkInfoMap;

    // 创建 bookmarkKey -> 访问次数的映射
    const keyVisitCounts = new Map();

    // 遍历所有访问记录，使用与原始统计完全相同的匹配逻辑
    for (const bookmarks of calendar.bookmarksByDate.values()) {
        for (const bm of bookmarks) {
            if (!bm || !bm.url) continue;

            const url = bm.url;
            const title = typeof bm.title === 'string' && bm.title.trim()
                ? bm.title.trim()
                : (bm.url || '');
            const t = typeof bm.visitTime === 'number'
                ? bm.visitTime
                : (bm.dateAdded instanceof Date ? bm.dateAdded.getTime() : 0);
            if (!t) continue;

            const visitDate = new Date(t);
            let matches = false;

            switch (filter.type) {
                case 'hour':
                    if (t >= boundaries.dayStart && t <= boundaries.now &&
                        visitDate.getHours() === filter.value) {
                        matches = true;
                    }
                    break;
                case 'day':
                    if (t >= boundaries.weekStart && t <= boundaries.now &&
                        visitDate.toDateString() === filter.value.toDateString()) {
                        matches = true;
                    }
                    break;
                case 'week':
                    if (t >= boundaries.monthStart && t <= boundaries.now &&
                        getWeekNumberForRelated(visitDate) === filter.value) {
                        matches = true;
                    }
                    break;
                case 'month':
                    if (t >= boundaries.yearStart && t <= boundaries.now &&
                        visitDate.getMonth() === filter.value) {
                        matches = true;
                    }
                    break;
                case 'year':
                    // 筛选特定年份（用于「全部」范围的年份二级菜单）
                    if (visitDate.getFullYear() === filter.value) {
                        matches = true;
                    }
                    break;
            }

            if (matches) {
                // 与原始统计完全相同的匹配逻辑
                let bookmarkKey = bookmarkKeyMap.get(`url:${url}`);
                if (!bookmarkKey && title) {
                    bookmarkKey = bookmarkKeyMap.get(`title:${title}`);
                }

                if (bookmarkKey) {
                    keyVisitCounts.set(bookmarkKey, (keyVisitCounts.get(bookmarkKey) || 0) + 1);
                }
            }
        }
    }

    // 将 bookmarkKey 的计数映射回 item.url
    const urlVisitCounts = new Map();
    for (const [key, count] of keyVisitCounts.entries()) {
        const info = bookmarkInfoMap.get(key);
        if (info && info.url) {
            urlVisitCounts.set(info.url, count);
        }
    }

    // 过滤并更新items的点击次数
    const result = items
        .filter(item => urlVisitCounts.has(item.url) && urlVisitCounts.get(item.url) > 0)
        .map(item => ({
            ...item,
            filteredCount: urlVisitCounts.get(item.url)
        }))
        .sort((a, b) => {
            if (b.filteredCount !== a.filteredCount) return b.filteredCount - a.filteredCount;
            return (b.lastVisitTime || 0) - (a.lastVisitTime || 0);
        });

    return result;
}

// ========== 书签关联页面 - 时间段菜单功能 ==========

// 全局变量：当前选中的时间筛选
let browsingRelatedTimeFilter = null; // { type: 'hour'|'day'|'week'|'month', value: number|Date }

// 显示时间段菜单（按需显示，只显示有数据的时间段）
// 使用与点击排行相同的数据源（calendar.bookmarksByDate），保持一致
async function showBrowsingRelatedTimeMenu(range) {
    const menuContainer = document.getElementById('browsingRelatedTimeMenu');
    if (!menuContainer) return;

    menuContainer.innerHTML = '';
    menuContainer.style.display = 'none';
    browsingRelatedTimeFilter = null; // 重置筛选

    // 使用与点击排行相同的数据源
    const calendar = window.browsingHistoryCalendarInstance;
    if (!calendar || !calendar.bookmarksByDate || calendar.bookmarksByDate.size === 0) {
        return; // 没有数据，不显示菜单
    }

    // 获取时间边界（与点击排行保持一致）
    const stats = await ensureBrowsingClickRankingStats();
    if (!stats || !stats.boundaries) return;

    const boundaries = stats.boundaries;
    const now = new Date();
    const isZh = currentLang === 'zh_CN';

    // 创建菜单项容器
    const itemsContainer = document.createElement('div');
    itemsContainer.className = 'time-menu-items';

    // 添加"全部"按钮（默认选中）
    const allBtn = document.createElement('button');
    allBtn.className = 'time-menu-btn active';
    allBtn.textContent = isZh ? '全部' : 'All';
    allBtn.dataset.filter = 'all';
    allBtn.addEventListener('click', () => {
        itemsContainer.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
        allBtn.classList.add('active');
        browsingRelatedTimeFilter = null;
        loadBrowsingRelatedHistory(browsingRelatedCurrentRange);
    });
    itemsContainer.appendChild(allBtn);

    // 使用与点击排行相同的数据源和边界
    switch (range) {
        case 'day':
            // 当天：只显示有数据的小时段
            renderRelatedDayHoursMenu(itemsContainer, boundaries, calendar);
            break;
        case 'week':
            // 当周：只显示有数据的天
            renderRelatedWeekDaysMenu(itemsContainer, boundaries, calendar);
            break;
        case 'month':
            // 当月：只显示有数据的周
            renderRelatedMonthWeeksMenu(itemsContainer, boundaries, calendar);
            break;
        case 'year':
            // 当年：只显示有数据的月份
            renderRelatedYearMonthsMenu(itemsContainer, boundaries, calendar);
            break;
        case 'all':
            // 全部：显示有数据的年份
            renderRelatedAllYearsMenu(itemsContainer, calendar);
            break;
    }

    if (itemsContainer.children.length > 1) { // 至少有"全部"和一个其他选项
        menuContainer.appendChild(itemsContainer);
        menuContainer.style.display = 'block';
    }
}

// 辅助函数：复用日历的 ISO 8601 周数计算
function getWeekNumberForRelated(date) {
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);
    const thursday = new Date(d);
    thursday.setDate(d.getDate() + (4 - (d.getDay() || 7)));
    const yearStart = new Date(thursday.getFullYear(), 0, 1);
    const weekNo = Math.ceil((((thursday - yearStart) / 86400000) + 1) / 7);
    return weekNo;
}

// 书签关联记录 - 渲染当天的小时菜单（使用与点击排行相同的数据源）
function renderRelatedDayHoursMenu(container, boundaries, calendar) {
    const isZh = currentLang === 'zh_CN';
    if (!calendar || !calendar.bookmarksByDate) return;

    // 分析有数据的小时（与点击排行完全相同的逻辑）
    const hoursSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t >= boundaries.dayStart && t <= boundaries.now) {
                hoursSet.add(new Date(t).getHours());
            }
        });
    }

    Array.from(hoursSet).sort((a, b) => a - b).forEach(hour => {
        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = `${String(hour).padStart(2, '0')}:00`;
        btn.dataset.hour = hour;
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRelatedTimeFilter = { type: 'hour', value: hour };
            loadBrowsingRelatedHistory(browsingRelatedCurrentRange);
        });
        container.appendChild(btn);
    });
}

// 书签关联记录 - 渲染当周的天菜单（使用与点击排行相同的数据源）
function renderRelatedWeekDaysMenu(container, boundaries, calendar) {
    const isZh = currentLang === 'zh_CN';
    if (!calendar || !calendar.bookmarksByDate) return;

    const weekdayNames = isZh
        ? ['周日', '周一', '周二', '周三', '周四', '周五', '周六']
        : ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

    // 分析有数据的天
    const daysSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t >= boundaries.weekStart && t <= boundaries.now) {
                daysSet.add(new Date(t).toDateString());
            }
        });
    }

    // 生成本周的日期
    const weekStart = new Date(boundaries.weekStart);
    for (let i = 0; i < 7; i++) {
        const dayDate = new Date(weekStart);
        dayDate.setDate(weekStart.getDate() + i);

        if (!daysSet.has(dayDate.toDateString())) continue;
        if (dayDate.getTime() > boundaries.now) continue;

        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = weekdayNames[dayDate.getDay()];
        btn.dataset.date = dayDate.toISOString();
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRelatedTimeFilter = { type: 'day', value: dayDate };
            loadBrowsingRelatedHistory(browsingRelatedCurrentRange);
        });
        container.appendChild(btn);
    }
}

// 书签关联记录 - 渲染当月的周菜单（使用与点击排行相同的数据源）
function renderRelatedMonthWeeksMenu(container, boundaries, calendar) {
    const isZh = currentLang === 'zh_CN';
    if (!calendar || !calendar.bookmarksByDate) return;

    // 分析有数据的周
    const weeksSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t >= boundaries.monthStart && t <= boundaries.now) {
                weeksSet.add(getWeekNumberForRelated(new Date(t)));
            }
        });
    }

    Array.from(weeksSet).sort((a, b) => a - b).forEach(weekNum => {
        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = isZh ? `第${weekNum}周` : `W${weekNum}`;
        btn.dataset.week = weekNum;
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRelatedTimeFilter = { type: 'week', value: weekNum };
            loadBrowsingRelatedHistory(browsingRelatedCurrentRange);
        });
        container.appendChild(btn);
    });
}

// 书签关联记录 - 渲染当年的月份菜单（使用与点击排行相同的数据源）
function renderRelatedYearMonthsMenu(container, boundaries, calendar) {
    const isZh = currentLang === 'zh_CN';
    if (!calendar || !calendar.bookmarksByDate) return;

    const monthNames = isZh
        ? ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月']
        : ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    // 分析有数据的月份
    const monthsSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t >= boundaries.yearStart && t <= boundaries.now) {
                monthsSet.add(new Date(t).getMonth());
            }
        });
    }

    Array.from(monthsSet).sort((a, b) => a - b).forEach(month => {
        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = monthNames[month];
        btn.dataset.month = month;
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRelatedTimeFilter = { type: 'month', value: month };
            loadBrowsingRelatedHistory(browsingRelatedCurrentRange);
        });
        container.appendChild(btn);
    });
}

// 书签关联记录 - 渲染全部时间的年份菜单
function renderRelatedAllYearsMenu(container, calendar) {
    const isZh = currentLang === 'zh_CN';
    if (!calendar || !calendar.bookmarksByDate) return;

    // 分析有数据的年份
    const yearsSet = new Set();
    for (const records of calendar.bookmarksByDate.values()) {
        records.forEach(record => {
            const t = record.visitTime || (record.dateAdded instanceof Date ? record.dateAdded.getTime() : 0);
            if (t > 0) {
                yearsSet.add(new Date(t).getFullYear());
            }
        });
    }

    // 按年份倒序排列（最近的年份在前）
    Array.from(yearsSet).sort((a, b) => b - a).forEach(year => {
        const btn = document.createElement('button');
        btn.className = 'time-menu-btn';
        btn.textContent = isZh ? `${year}年` : `${year}`;
        btn.dataset.year = year;
        btn.addEventListener('click', () => {
            container.querySelectorAll('.time-menu-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            browsingRelatedTimeFilter = { type: 'year', value: year };
            loadBrowsingRelatedHistory(browsingRelatedCurrentRange);
        });
        container.appendChild(btn);
    });
}

// 按时间筛选历史记录
function filterHistoryByTime(items, filter, range) {
    if (!filter || !items || items.length === 0) return items;

    return items.filter(item => {
        if (!item.lastVisitTime) return false;

        const itemDate = new Date(item.lastVisitTime);

        switch (filter.type) {
            case 'hour':
                // 筛选特定小时
                return itemDate.getHours() === filter.value;

            case 'day':
                // 筛选特定日期
                const filterDate = new Date(filter.value);
                return itemDate.toDateString() === filterDate.toDateString();

            case 'week':
                // 筛选特定周
                const weekNum = getWeekNumberForRelated(itemDate);
                return weekNum === filter.value;

            case 'month':
                // 筛选特定月份
                return itemDate.getMonth() === filter.value;

            case 'year':
                // 筛选特定年份
                return itemDate.getFullYear() === filter.value;

            default:
                return true;
        }
    });
}

// ============================================================================
// 跳转至书签关联记录功能（从点击记录跳转）
// ============================================================================

// 全局变量：存储待高亮的记录信息
let pendingHighlightInfo = null;

// 返回按钮相关
let jumpSourceInfo = null;  // 记录跳转来源信息

function getWeekStartForRelated(date) {
    const d = new Date(date);
    const day = d.getDay() || 7; // 周日返回0，转换为7
    const weekStart = new Date(d);
    weekStart.setDate(d.getDate() - day + 1);
    weekStart.setHours(0, 0, 0, 0);
    return weekStart;
}

function getPreferredRangeFromCalendar(instance) {
    if (!instance || !instance.viewLevel) return null;
    const level = String(instance.viewLevel).toLowerCase();
    switch (level) {
        case 'day':
        case 'week':
        case 'month':
        case 'year':
            return level;
        default:
            return null;
    }
}

function getPrimaryRangeForVisit(visitDate) {
    if (!visitDate) return 'day';
    const now = new Date();
    if (visitDate.toDateString() === now.toDateString()) {
        return 'day';
    }
    const diff = Math.abs(now - visitDate);
    const oneDay = 24 * 60 * 60 * 1000;
    if (diff <= 7 * oneDay) {
        return 'week';
    }
    if (diff <= 31 * oneDay) {
        return 'month';
    }
    if (visitDate.getFullYear() === now.getFullYear()) {
        return 'year';
    }
    return 'all';
}

function buildRangeFilter(range, visitDate) {
    if (!visitDate) return null;
    switch (range) {
        case 'day':
            return { type: 'hour', value: visitDate.getHours() };
        case 'week': {
            const dayDate = new Date(visitDate);
            dayDate.setHours(0, 0, 0, 0);
            return { type: 'day', value: dayDate };
        }
        case 'month':
            return { type: 'week', value: getWeekNumberForRelated(visitDate) };
        case 'year':
            return { type: 'month', value: visitDate.getMonth() };
        case 'all':
            return { type: 'year', value: visitDate.getFullYear() };
        default:
            return null;
    }
}

function buildRelatedRangeStrategies(visitTime, options = {}) {
    const strategies = [];
    const seen = new Set();
    const { preferredRange = null } = options || {};
    const hasVisitTime = typeof visitTime === 'number' && !Number.isNaN(visitTime);
    const visitDate = hasVisitTime ? new Date(visitTime) : null;

    const pushStrategy = (range, filter = null) => {
        if (!range) return;
        const filterKey = filter
            ? `${filter.type}-${filter.value instanceof Date ? filter.value.toISOString() : filter.value}`
            : 'none';
        const key = `${range}|${filterKey}`;
        if (seen.has(key)) return;
        seen.add(key);
        strategies.push({ range, filter });
    };

    if (!visitDate) {
        pushStrategy(preferredRange || 'day', null);
        pushStrategy('all', null);
        return strategies;
    }

    const primaryRange = getPrimaryRangeForVisit(visitDate);
    const orderedRanges = [];
    if (preferredRange) orderedRanges.push(preferredRange);
    orderedRanges.push(primaryRange);
    if (primaryRange !== 'year' && visitDate.getFullYear() === (new Date()).getFullYear()) {
        orderedRanges.push('year');
    }
    orderedRanges.push('all');

    const uniqueRanges = [];
    const rangeSeen = new Set();
    orderedRanges.forEach(range => {
        if (!range) return;
        if (rangeSeen.has(range)) return;
        rangeSeen.add(range);
        uniqueRanges.push(range);
    });

    uniqueRanges.forEach(range => {
        pushStrategy(range, buildRangeFilter(range, visitDate));
    });

    pushStrategy('all', null);
    return strategies;
}

function scheduleApplyRelatedFilter(filter, attempt = 0) {
    const MAX_ATTEMPTS = 10;
    const success = applyRelatedTimeFilter(filter);
    if (!success && attempt < MAX_ATTEMPTS) {
        setTimeout(() => scheduleApplyRelatedFilter(filter, attempt + 1), 120);
    }
}

function activateRelatedRangeStrategy(strategy) {
    if (!strategy) {
        // 确保在没有策略时也清理加载状态和超时
        clearTimeout(window.__relatedJumpTimeout);
        if (pendingHighlightInfo && pendingHighlightInfo.silentMenu) {
            setRelatedPanelSilent(false);
        }
        pendingHighlightInfo = null;
        return;
    }
    pendingHighlightInfo.activeStrategy = strategy;
    if (pendingHighlightInfo) {
        pendingHighlightInfo.pendingUIRange = strategy.range;
        pendingHighlightInfo.pendingUIFilter = strategy.filter || null;
    }

    const silentMode = pendingHighlightInfo && pendingHighlightInfo.silentMenu;
    if (silentMode) {
        setRelatedPanelSilent(true);
    }

    const loadAndHighlightSilently = () => {
        setTimeout(() => {
            highlightRelatedHistoryItem();
        }, 20);
    };

    if (silentMode) {
        browsingRelatedCurrentRange = strategy.range;
        browsingRelatedTimeFilter = strategy.filter || null;
        loadBrowsingRelatedHistory(strategy.range)
            .then(loadAndHighlightSilently)
            .catch(loadAndHighlightSilently);
        return;
    }

    const rangeName = strategy.range.charAt(0).toUpperCase() + strategy.range.slice(1);
    const filterBtn = document.getElementById(`browsingRelatedFilter${rangeName}`);

    const triggerHighlightFlow = () => {
        scheduleApplyRelatedFilter(strategy.filter || null);
        setTimeout(() => {
            highlightRelatedHistoryItem();
        }, 450);
    };

    if (filterBtn) {
        if (!filterBtn.classList.contains('active')) {
            filterBtn.click();
            setTimeout(triggerHighlightFlow, 350);
        } else {
            loadBrowsingRelatedHistory(strategy.range).then(() => {
                triggerHighlightFlow();
            }).catch(() => {
                triggerHighlightFlow();
            });
        }
    } else {
        loadBrowsingRelatedHistory(strategy.range).then(() => {
            triggerHighlightFlow();
        }).catch(() => {
            triggerHighlightFlow();
        });
    }
}

function syncRelatedUIWithStrategy(strategy) {
    if (!strategy) return;
    const range = strategy.range;
    const filter = strategy.filter || null;
    setActiveRelatedRangeButton(range);
    showBrowsingRelatedTimeMenu(range).then(() => {
        markRelatedTimeMenuSelection(filter);
    }).catch(() => {
        markRelatedTimeMenuSelection(filter);
    });
}

function setRelatedPanelSilent(enabled) {
    const panel = document.getElementById('browsingRelatedPanel');
    if (!panel) return;
    if (enabled) {
        const loadingText = currentLang === 'zh_CN' ? '正在定位记录…' : 'Locating record…';
        panel.setAttribute('data-loading-text', loadingText);
        panel.classList.add('related-silent-loading');
    } else {
        panel.classList.remove('related-silent-loading');
        panel.removeAttribute('data-loading-text');
    }
}

function setActiveRelatedRangeButton(range) {
    if (!range) return;
    const panel = document.getElementById('browsingRelatedPanel');
    if (!panel) return;
    const buttons = panel.querySelectorAll('.ranking-time-filter-btn');
    buttons.forEach(btn => {
        const isMatch = btn.dataset.range === range;
        btn.classList.toggle('active', isMatch);
    });
}

function markRelatedTimeMenuSelection(filter) {
    const menuContainer = document.getElementById('browsingRelatedTimeMenu');
    if (!menuContainer) return;
    const buttons = menuContainer.querySelectorAll('.time-menu-btn');
    buttons.forEach(btn => btn.classList.remove('active'));

    if (!filter) {
        const allBtn = menuContainer.querySelector('.time-menu-btn[data-filter="all"]');
        if (allBtn) allBtn.classList.add('active');
        return;
    }

    let targetBtn = null;
    buttons.forEach(btn => {
        if (filter.type === 'hour' && btn.dataset.hour == filter.value) {
            targetBtn = btn;
        } else if (filter.type === 'day' && btn.dataset.date) {
            const btnDate = new Date(btn.dataset.date);
            if (filter.value instanceof Date && btnDate.toDateString() === filter.value.toDateString()) {
                targetBtn = btn;
            }
        } else if (filter.type === 'week' && btn.dataset.week == filter.value) {
            targetBtn = btn;
        } else if (filter.type === 'month' && btn.dataset.month == filter.value) {
            targetBtn = btn;
        } else if (filter.type === 'year' && btn.dataset.year == filter.value) {
            targetBtn = btn;
        }
    });

    if (targetBtn) {
        targetBtn.classList.add('active');
    } else {
        const allBtn = menuContainer.querySelector('.time-menu-btn[data-filter="all"]');
        if (allBtn) allBtn.classList.add('active');
    }
}

// 跳转到书签关联记录并高亮对应条目
async function jumpToRelatedHistory(url, title, visitTime, sourceElement) {
    // 记录来源信息，用于返回
    jumpSourceInfo = {
        type: 'browsingHistory',  // 来自点击记录
        url: url,
        title: title,
        visitTime: visitTime,
        scrollTop: document.querySelector('.content-area')?.scrollTop || 0
    };

    // 添加超时保护机制，确保加载状态一定会被清理
    clearTimeout(window.__relatedJumpTimeout);
    window.__relatedJumpTimeout = setTimeout(() => {
        if (pendingHighlightInfo && pendingHighlightInfo.silentMenu) {
            console.warn('[BrowsingRelated] 跳转超时，强制清理加载状态');
            setRelatedPanelSilent(false);
            pendingHighlightInfo = null;
        }
    }, 10000); // 10秒超时保护

    // 1. 切换到「书签浏览记录」标签
    const browsingTab = document.getElementById('additionsTabBrowsing');
    if (browsingTab && !browsingTab.classList.contains('active')) {
        browsingTab.click();
    }

    // 2. 切换到「书签关联记录」子标签
    const relatedTab = document.getElementById('browsingTabRelated');
    if (relatedTab && !relatedTab.classList.contains('active')) {
        relatedTab.click();
    }

    const normalizedTitle = typeof title === 'string' ? title.trim() : '';
    const hasPreciseVisit = typeof visitTime === 'number' && !Number.isNaN(visitTime);
    const preferredRange = getPreferredRangeFromCalendar(window.browsingHistoryCalendarInstance);
    const strategyQueue = buildRelatedRangeStrategies(visitTime, { preferredRange });
    const effectiveStrategies = strategyQueue.length ? strategyQueue : [{ range: 'all', filter: null }];

    // 3. 存储待高亮信息和时间范围策略
    pendingHighlightInfo = {
        url: url,
        title: title,
        normalizedTitle,
        visitTime: visitTime,
        strategyQueue: effectiveStrategies,
        currentStrategyIndex: 0,
        showBackButton: true, // 标记需要显示返回按钮
        hasVisitTime: hasPreciseVisit,
        forceLoadAll: true,
        silentMenu: true,
        pendingUIRange: effectiveStrategies[0]?.range || null,
        pendingUIFilter: effectiveStrategies[0]?.filter || null
    };

    // 4. 启动首个时间范围策略
    activateRelatedRangeStrategy(effectiveStrategies[0]);
}

// 高亮书签关联记录中的目标条目
function highlightRelatedHistoryItem(retryCount = 0) {
    if (!pendingHighlightInfo) return;

    const {
        url,
        title,
        normalizedTitle,
        visitTime,
        strategyQueue = [],
        currentStrategyIndex = 0,
        fromAdditions,
        showBackButton: shouldShowBackButton,
        hasVisitTime: storedVisitFlag,
        forceLoadAll
    } = pendingHighlightInfo;
    const listContainer = document.getElementById('browsingRelatedList');
    if (!listContainer) {
        // 确保在容器不存在时也清理加载状态和超时
        clearTimeout(window.__relatedJumpTimeout);
        const silentMode = pendingHighlightInfo && pendingHighlightInfo.silentMenu;
        pendingHighlightInfo = null;
        if (silentMode) {
            setRelatedPanelSilent(false);
        }
        return;
    }

    const normalizedTitleValue = normalizedTitle || (title ? title.trim() : '');
    const computedHasVisitTime = typeof visitTime === 'number' && !Number.isNaN(visitTime);
    const hasVisitTime = typeof storedVisitFlag === 'boolean' ? storedVisitFlag : computedHasVisitTime;
    const targetMinute = hasVisitTime ? Math.floor(visitTime / (60 * 1000)) : null;

    const candidateSelector = hasVisitTime && targetMinute !== null
        ? `[data-visit-minute="${targetMinute}"]`
        : '.related-history-item';
    let nodes = listContainer.querySelectorAll(candidateSelector);
    if (!nodes || nodes.length === 0) {
        nodes = listContainer.querySelectorAll('.related-history-item');
    }

    let minuteUrlMatch = null;
    let minuteTitleMatch = null;
    let fallbackMatch = null;
    nodes.forEach(item => {
        if (minuteUrlMatch && minuteTitleMatch) {
            return;
        }

        const itemUrl = item.dataset.url;
        const itemTitle = (item.dataset.title || '').trim();
        const matchesUrl = itemUrl === url;
        const matchesTitle = normalizedTitleValue && itemTitle === normalizedTitleValue;

        if (hasVisitTime) {
            const itemMinuteAttr = item.dataset.visitMinute;
            if (itemMinuteAttr && Number(itemMinuteAttr) === targetMinute) {
                if (matchesUrl && !minuteUrlMatch) {
                    minuteUrlMatch = item;
                    return;
                }
                if (matchesTitle && !minuteTitleMatch) {
                    minuteTitleMatch = item;
                    return;
                }
            }
        } else if (!fallbackMatch && (matchesUrl || matchesTitle)) {
            fallbackMatch = item;
        }
    });

    let targetItem = minuteUrlMatch || minuteTitleMatch || null;
    if (!targetItem && !hasVisitTime) {
        targetItem = fallbackMatch;
    }

    if (targetItem) {
        const shouldSyncUI = pendingHighlightInfo && pendingHighlightInfo.silentMenu;
        const finalStrategy = pendingHighlightInfo ? pendingHighlightInfo.activeStrategy : null;
        listContainer.querySelectorAll('.related-history-item.highlight-target').forEach(el => {
            el.classList.remove('highlight-target');
        });
        targetItem.classList.add('highlight-target');
        targetItem.scrollIntoView({ behavior: 'instant', block: 'center' });
        if (shouldShowBackButton && typeof showBackButton === 'function' && jumpSourceInfo) {
            showBackButton();
        }
        if (shouldSyncUI && finalStrategy) {
            browsingRelatedTimeFilter = finalStrategy.filter || null;
            syncRelatedUIWithStrategy(finalStrategy);
        }
        showRelatedJumpSuccessToast(visitTime, title);
        // 清除超时保护
        clearTimeout(window.__relatedJumpTimeout);
        if (pendingHighlightInfo && pendingHighlightInfo.silentMenu) {
            setRelatedPanelSilent(false);
        }
        pendingHighlightInfo = null;
        return;
    }

    const lazyState = listContainer.__lazyLoadState;
    if (lazyState) {
        if (forceLoadAll && !lazyState.__forceLoaded) {
            lazyState.__forceLoaded = true;
            lazyState.loadAll();
            setTimeout(() => highlightRelatedHistoryItem(retryCount + 1), 120);
            return;
        }
        if (lazyState.getLoadedCount() < lazyState.totalItems) {
            lazyState.loadMore();
            if (retryCount < 20) {
                setTimeout(() => highlightRelatedHistoryItem(retryCount + 1), 120);
            } else {
                lazyState.loadAll();
                setTimeout(() => highlightRelatedHistoryItem(100), 150);
            }
            return;
        }
    }

    if (retryCount < 5) {
        setTimeout(() => highlightRelatedHistoryItem(retryCount + 1), 220);
        return;
    }

    if (strategyQueue.length && currentStrategyIndex < strategyQueue.length - 1) {
        const nextIndex = currentStrategyIndex + 1;
        pendingHighlightInfo.currentStrategyIndex = nextIndex;
        activateRelatedRangeStrategy(strategyQueue[nextIndex]);
        return;
    }

    const silentMode = pendingHighlightInfo && pendingHighlightInfo.silentMenu;
    // 清除超时保护
    clearTimeout(window.__relatedJumpTimeout);
    pendingHighlightInfo = null;
    if (silentMode) {
        setRelatedPanelSilent(false);
    }
    if (fromAdditions || hasVisitTime) {
        showNoRecordToast();
    }
}

// 显示暂无记录提示
function showNoRecordToast() {
    const msg = typeof currentLang !== 'undefined' && currentLang === 'zh_CN'
        ? '暂无浏览记录（可能是导入的书签）'
        : 'No browsing history found (may be imported bookmark)';

    // 创建提示元素
    let toast = document.getElementById('noRecordToast');
    if (!toast) {
        toast = document.createElement('div');
        toast.id = 'noRecordToast';
        toast.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(toast);
    }

    toast.textContent = msg;
    toast.style.opacity = '1';

    setTimeout(() => {
        toast.style.opacity = '0';
    }, 2500);
}

function showRelatedJumpSuccessToast(visitTime, title) {
    const isZh = currentLang === 'zh_CN';
    const dateText = visitTime
        ? new Date(visitTime).toLocaleString(isZh ? 'zh-CN' : 'en-US', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        })
        : '';
    const safeTitle = (title && title.trim()) || (isZh ? '目标记录' : 'target entry');
    const msg = isZh
        ? `已定位：${safeTitle}${dateText ? `（${dateText}）` : ''}`
        : `Jumped to ${safeTitle}${dateText ? ` (${dateText})` : ''}`;

    let toast = document.getElementById('relatedJumpToast');
    if (!toast) {
        toast = document.createElement('div');
        toast.id = 'relatedJumpToast';
        toast.style.cssText = `
            position: fixed;
            top: 28px;
            right: 28px;
            background: rgba(33, 150, 243, 0.92);
            color: #fff;
            padding: 14px 18px;
            border-radius: 10px;
            font-size: 13px;
            box-shadow: 0 8px 24px rgba(33, 150, 243, 0.35);
            z-index: 11000;
            opacity: 0;
            transition: opacity 0.25s ease;
        `;
        document.body.appendChild(toast);
    }

    toast.textContent = msg;
    toast.style.opacity = '1';

    clearTimeout(toast.__hideTimer);
    toast.__hideTimer = setTimeout(() => {
        toast.style.opacity = '0';
    }, 2400);
}

// 从「书签添加记录」跳转到「书签关联记录」
async function jumpToRelatedHistoryFromAdditions(url, title, dateAdded) {
    const browserAPI = (typeof chrome !== 'undefined') ? chrome : browser;

    // 先查询该URL在书签添加时间附近是否有访问记录
    let hasMatchingVisit = false;
    let matchingVisitTime = null;

    try {
        if (browserAPI && browserAPI.history && browserAPI.history.getVisits) {
            const visits = await new Promise((resolve, reject) => {
                browserAPI.history.getVisits({ url: url }, (results) => {
                    if (browserAPI.runtime && browserAPI.runtime.lastError) {
                        reject(browserAPI.runtime.lastError);
                    } else {
                        resolve(results || []);
                    }
                });
            });

            // 查找时间精确匹配的访问记录（同一分钟内，即60秒）
            const oneMinute = 60 * 1000;
            let minDiff = Infinity;

            visits.forEach(visit => {
                const diff = Math.abs(visit.visitTime - dateAdded);
                if (diff < minDiff) {
                    minDiff = diff;
                    matchingVisitTime = visit.visitTime;
                }
            });

            // 时间差必须在1分钟内才算匹配
            hasMatchingVisit = minDiff <= oneMinute;
        }
    } catch (e) {
        console.warn('[jumpToRelatedHistoryFromAdditions] 查询访问记录失败:', e);
    }

    // 如果没有精确匹配的访问记录，直接显示提示，不跳转
    if (!hasMatchingVisit) {
        showNoRecordToast();
        return;
    }

    // 记录来源信息，用于返回
    jumpSourceInfo = {
        type: 'bookmarkAdditions',  // 来自书签添加记录
        url: url,
        title: title,
        dateAdded: dateAdded,
        scrollTop: document.querySelector('.content-area')?.scrollTop || 0
    };

    // 添加超时保护机制
    clearTimeout(window.__relatedJumpTimeout);
    window.__relatedJumpTimeout = setTimeout(() => {
        if (pendingHighlightInfo && pendingHighlightInfo.silentMenu) {
            console.warn('[BrowsingRelated] 跳转超时，强制清理加载状态');
            setRelatedPanelSilent(false);
            pendingHighlightInfo = null;
        }
    }, 10000);

    // 1. 切换到「书签浏览记录」标签
    const browsingTab = document.getElementById('additionsTabBrowsing');
    if (browsingTab && !browsingTab.classList.contains('active')) {
        browsingTab.click();
    }

    // 2. 切换到「书签关联记录」子标签
    const relatedTab = document.getElementById('browsingTabRelated');
    if (relatedTab && !relatedTab.classList.contains('active')) {
        relatedTab.click();
    }

    // 3. 根据访问时间构建时间范围策略
    const normalizedTitle = typeof title === 'string' ? title.trim() : '';
    const hasPreciseVisit = typeof matchingVisitTime === 'number' && !Number.isNaN(matchingVisitTime);
    const preferredRange = getPreferredRangeFromCalendar(window.bookmarkCalendarInstance);
    const strategyQueue = buildRelatedRangeStrategies(matchingVisitTime, { preferredRange });
    const effectiveStrategies = strategyQueue.length ? strategyQueue : [{ range: 'all', filter: null }];

    // 4. 存储待高亮信息
    pendingHighlightInfo = {
        url: url,
        title: title,
        normalizedTitle,
        visitTime: matchingVisitTime,
        strategyQueue: effectiveStrategies,
        currentStrategyIndex: 0,
        fromAdditions: true,
        showBackButton: true,  // 标记需要显示返回按钮
        hasVisitTime: hasPreciseVisit,
        forceLoadAll: true,
        silentMenu: true,
        pendingUIRange: effectiveStrategies[0]?.range || null,
        pendingUIFilter: effectiveStrategies[0]?.filter || null
    };

    // 5. 启动对应的范围策略
    activateRelatedRangeStrategy(effectiveStrategies[0]);
}

// 从「点击排行」跳转到「书签关联记录」并高亮所有匹配记录
async function jumpToRelatedHistoryFromRanking(url, title, currentRange) {
    // 保存当前的二级菜单筛选条件
    const currentTimeFilter = browsingRankingTimeFilter ? { ...browsingRankingTimeFilter } : null;

    // 记录来源信息，用于返回
    jumpSourceInfo = {
        type: 'clickRanking',  // 来自点击排行
        url: url,
        title: title,
        range: currentRange,
        timeFilter: currentTimeFilter,  // 保存二级菜单筛选条件
        scrollTop: document.querySelector('.content-area')?.scrollTop || 0
    };

    // 添加超时保护机制
    clearTimeout(window.__relatedJumpTimeout);
    window.__relatedJumpTimeout = setTimeout(() => {
        if (pendingHighlightInfo) {
            console.warn('[BrowsingRelated] 跳转超时，强制清理状态');
            setRelatedPanelSilent(false);
            pendingHighlightInfo = null;
        }
    }, 10000);

    // 1. 切换到「书签浏览记录」标签
    const browsingTab = document.getElementById('additionsTabBrowsing');
    if (browsingTab && !browsingTab.classList.contains('active')) {
        browsingTab.click();
    }

    // 2. 切换到「书签关联记录」子标签
    const relatedTab = document.getElementById('browsingTabRelated');
    if (relatedTab && !relatedTab.classList.contains('active')) {
        relatedTab.click();
    }

    // 3. 存储待高亮信息
    pendingHighlightInfo = {
        url: url,
        title: title,
        currentRange: currentRange,
        timeFilter: currentTimeFilter,  // 传递二级菜单筛选条件
        fromRanking: true,
        showBackButton: true,
        highlightAll: true
    };

    // 4. 切换到对应的时间范围（这会触发 showBrowsingRelatedTimeMenu）
    const rangeName = currentRange.charAt(0).toUpperCase() + currentRange.slice(1);
    const filterBtn = document.getElementById(`browsingRelatedFilter${rangeName}`);
    if (filterBtn && !filterBtn.classList.contains('active')) {
        filterBtn.click();
    } else {
        // 已经在当前范围，重新加载
        await loadBrowsingRelatedHistory(currentRange);
    }

    // 5. 延迟应用二级菜单筛选并高亮
    setTimeout(() => {
        if (currentTimeFilter) {
            scheduleApplyRelatedFilter(currentTimeFilter);
        }
        highlightAllRelatedHistoryItems();
    }, 500);
}

// 应用书签关联记录的二级菜单筛选（从点击排行跳转时使用）
function applyRelatedTimeFilter(filter) {
    const menuContainer = document.getElementById('browsingRelatedTimeMenu');
    if (!menuContainer) return false;
    const buttons = menuContainer.querySelectorAll('.time-menu-btn');
    if (!buttons.length) return false;

    let targetBtn = null;

    buttons.forEach(btn => {
        if (!filter) {
            if (btn.dataset.filter === 'all' && !targetBtn) {
                targetBtn = btn;
            }
            return;
        }

        if (btn.dataset.filter === 'all' && filter.type === 'all') {
            targetBtn = btn;
        } else if (filter.type === 'hour' && btn.dataset.hour == filter.value) {
            targetBtn = btn;
        } else if (filter.type === 'day' && btn.dataset.date) {
            const btnDate = new Date(btn.dataset.date);
            if (filter.value instanceof Date && btnDate.toDateString() === filter.value.toDateString()) {
                targetBtn = btn;
            }
        } else if (filter.type === 'week' && btn.dataset.week == filter.value) {
            targetBtn = btn;
        } else if (filter.type === 'month' && btn.dataset.month == filter.value) {
            targetBtn = btn;
        } else if (filter.type === 'year' && btn.dataset.year == filter.value) {
            targetBtn = btn;
        }
    });

    if (targetBtn) {
        targetBtn.click();
        return true;
    }

    return false;
}

// 高亮点击记录日历中所有匹配的记录（从点击排行跳转时使用）
function highlightAllClickHistoryItems(retryCount = 0) {
    if (!pendingHighlightInfo) return;

    const { url, title, currentRange, showBackButton: shouldShowBackButton } = pendingHighlightInfo;

    // 获取点击记录日历实例
    const calendar = window.browsingHistoryCalendarInstance;
    if (!calendar || !calendar.bookmarksByDate) {
        if (retryCount < 10) {
            setTimeout(() => highlightAllClickHistoryItems(retryCount + 1), 300);
        } else {
            pendingHighlightInfo = null;
            showNoRecordToast();
        }
        return;
    }

    // 查找日历容器中的所有书签项
    const calendarContainer = document.getElementById('browsingHistoryCalendar');
    if (!calendarContainer) {
        if (retryCount < 10) {
            setTimeout(() => highlightAllClickHistoryItems(retryCount + 1), 300);
        }
        return;
    }

    // 查找所有匹配URL的书签项（使用 data-bookmark-url 属性）
    const items = calendarContainer.querySelectorAll('[data-bookmark-url]');
    const matchedItems = [];

    items.forEach(item => {
        const itemUrl = item.dataset.bookmarkUrl;
        if (itemUrl === url) {
            matchedItems.push(item);
        }
    });

    if (matchedItems.length > 0) {
        // 移除之前的高亮
        calendarContainer.querySelectorAll('[data-bookmark-url].highlight-target').forEach(el => {
            el.classList.remove('highlight-target');
        });

        // 为所有匹配项添加高亮
        matchedItems.forEach(item => {
            item.classList.add('highlight-target');
        });

        // 滚动到第一个匹配项
        matchedItems[0].scrollIntoView({ behavior: 'instant', block: 'center' });

        // 显示返回按钮
        if (shouldShowBackButton && jumpSourceInfo) {
            showBackButton();
        }

        // 清除待高亮信息
        pendingHighlightInfo = null;
        return;
    }

    // 没找到匹配项，可能需要等待渲染
    if (retryCount < 10) {
        setTimeout(() => highlightAllClickHistoryItems(retryCount + 1), 300);
    } else {
        pendingHighlightInfo = null;
        showNoRecordToast();
    }
}

// 高亮所有匹配的书签关联记录（保留，可能其他地方使用）
function highlightAllRelatedHistoryItems(retryCount = 0) {
    if (!pendingHighlightInfo) return;

    const { url, title, highlightAll, showBackButton: shouldShowBackButton } = pendingHighlightInfo;
    const listContainer = document.getElementById('browsingRelatedList');
    if (!listContainer) {
        // 确保在容器不存在时也清理状态
        clearTimeout(window.__relatedJumpTimeout);
        pendingHighlightInfo = null;
        return;
    }

    // 查找所有匹配的记录项（URL匹配或标题匹配，与点击排行的计数逻辑保持一致）
    const items = listContainer.querySelectorAll('.related-history-item');
    const matchedItems = [];
    const normalizedTitle = title ? title.trim() : '';

    items.forEach(item => {
        const itemUrl = item.dataset.url;
        const itemTitle = item.dataset.title || '';

        // URL 精确匹配
        if (itemUrl === url) {
            matchedItems.push(item);
        }
        // 标题匹配（URL不同但标题相同）
        else if (normalizedTitle && itemTitle === normalizedTitle) {
            matchedItems.push(item);
        }
    });

    // 如果找到了匹配项，高亮显示
    if (matchedItems.length > 0) {
        // 移除之前的高亮
        listContainer.querySelectorAll('.related-history-item.highlight-target').forEach(el => {
            el.classList.remove('highlight-target');
        });

        // 为所有匹配项添加高亮
        matchedItems.forEach(item => {
            item.classList.add('highlight-target');
        });

        // 获取当前排序顺序（默认按时间降序，即最新的在前）
        const sortBtn = document.querySelector('.sort-indicator-btn');
        const isAscending = sortBtn && sortBtn.classList.contains('asc');

        // 根据排序滚动到第一个或最后一个（最新/最旧的记录）
        const targetItem = isAscending ? matchedItems[0] : matchedItems[0];
        targetItem.scrollIntoView({ behavior: 'instant', block: 'center' });

        // 显示返回按钮
        if (shouldShowBackButton && jumpSourceInfo) {
            showBackButton();
        }

        // 清除超时保护和待高亮信息
        clearTimeout(window.__relatedJumpTimeout);
        pendingHighlightInfo = null;
        return;
    }

    // 检查是否有未加载的数据（懒加载场景）
    const lazyState = listContainer.__lazyLoadState;
    if (lazyState && lazyState.getLoadedCount() < lazyState.totalItems) {
        // 还有未加载的数据，加载更多后重试
        lazyState.loadMore();
        if (retryCount < 20) {
            setTimeout(() => highlightAllRelatedHistoryItems(retryCount + 1), 100);
        } else {
            // 重试次数过多，加载全部然后最后尝试一次
            lazyState.loadAll();
            setTimeout(() => highlightAllRelatedHistoryItems(100), 100);
        }
        return;
    }

    // 没找到匹配项
    if (retryCount < 5) {
        setTimeout(() => highlightAllRelatedHistoryItems(retryCount + 1), 300);
    } else {
        // 清除超时保护
        clearTimeout(window.__relatedJumpTimeout);
        pendingHighlightInfo = null;
        // 显示暂无记录提示
        showNoRecordToast();
    }
}

// ============================================================================
// 返回按钮功能
// ============================================================================

// 显示返回按钮
function showBackButton() {
    // 如果已存在，先移除（但不清除 jumpSourceInfo）
    const existingBtn = document.getElementById('jumpBackBtn');
    if (existingBtn) existingBtn.remove();

    console.log('[showBackButton] 显示返回按钮, jumpSourceInfo:', jumpSourceInfo);

    const btn = document.createElement('button');
    btn.id = 'jumpBackBtn';
    btn.className = 'jump-back-btn';
    btn.innerHTML = '<i class="fas fa-arrow-left"></i>';
    btn.title = typeof currentLang !== 'undefined' && currentLang === 'zh_CN' ? '返回' : 'Go Back';

    btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('[showBackButton] 点击返回按钮');
        goBackToSource();
    });

    document.body.appendChild(btn);

    // 显示动画
    setTimeout(() => {
        btn.style.opacity = '1';
        btn.style.transform = 'translateY(0)';
    }, 50);
}

// 隐藏返回按钮（可选是否清除来源信息）
function hideBackButton(clearSource = true) {
    const btn = document.getElementById('jumpBackBtn');
    if (btn) {
        btn.remove();
    }
    if (clearSource) {
        jumpSourceInfo = null;
    }
}

// 返回到跳转来源
async function goBackToSource() {
    if (!jumpSourceInfo) {
        console.warn('[goBackToSource] jumpSourceInfo 为空');
        return;
    }

    const { type, url, scrollTop } = jumpSourceInfo;
    console.log('[goBackToSource] 返回:', type, url);

    // 先隐藏返回按钮
    const btn = document.getElementById('jumpBackBtn');
    if (btn) btn.remove();

    // 清除来源信息（在使用完之后立即清除）
    jumpSourceInfo = null;

    if (type === 'browsingHistory') {
        // 返回点击记录 - 需要切换到「点击记录」子标签
        const historyTab = document.getElementById('browsingTabHistory');
        if (historyTab) {
            historyTab.click();
            console.log('[goBackToSource] 已切换到点击记录');
        }

        // 恢复滚动位置并高亮
        setTimeout(() => {
            const contentArea = document.querySelector('.content-area');
            if (contentArea && scrollTop) {
                contentArea.scrollTop = scrollTop;
            }
            highlightSourceBookmark(url);
        }, 500);

    } else if (type === 'bookmarkAdditions') {
        // 返回书签添加记录 - 需要切换到「书签添加记录」标签
        const reviewTab = document.getElementById('additionsTabReview');
        if (reviewTab) {
            reviewTab.click();
            console.log('[goBackToSource] 已切换到书签添加记录');
        }

        // 恢复滚动位置并高亮
        setTimeout(() => {
            const contentArea = document.querySelector('.content-area');
            if (contentArea && scrollTop) {
                contentArea.scrollTop = scrollTop;
            }
            highlightSourceBookmark(url);
        }, 500);

    } else if (type === 'clickRanking') {
        // 返回点击排行 - 需要切换到「点击排行」子标签
        const rankingTab = document.getElementById('browsingTabRanking');
        if (rankingTab) {
            rankingTab.click();
            console.log('[goBackToSource] 已切换到点击排行');
        }

        // 恢复滚动位置并高亮
        setTimeout(() => {
            const contentArea = document.querySelector('.content-area');
            if (contentArea && scrollTop) {
                contentArea.scrollTop = scrollTop;
            }
            highlightSourceRankingItem(url);
        }, 500);
    }
}

// 高亮来源书签
function highlightSourceBookmark(url) {
    // 在整个内容区域查找匹配的书签项
    const contentArea = document.querySelector('.content-area');
    if (!contentArea) {
        console.warn('[highlightSourceBookmark] 未找到 content-area');
        return;
    }

    // 查找所有匹配URL的书签项
    const items = contentArea.querySelectorAll('[data-bookmark-url]');
    console.log('[highlightSourceBookmark] 查找书签:', url, '找到', items.length, '个书签项');

    let found = false;

    items.forEach(item => {
        if (item.dataset.bookmarkUrl === url && !found) {
            found = true;
            console.log('[highlightSourceBookmark] 找到匹配书签，添加高亮');
            item.classList.add('highlight-source');
            item.scrollIntoView({ behavior: 'instant', block: 'center' });

            // 3秒后移除高亮
            setTimeout(() => {
                item.classList.remove('highlight-source');
            }, 3000);
        }
    });

    if (!found) {
        console.warn('[highlightSourceBookmark] 未找到匹配的书签');
    }
}

// 高亮点击排行中的来源书签
function highlightSourceRankingItem(url) {
    const listContainer = document.getElementById('browsingRankingList');
    if (!listContainer) {
        console.warn('[highlightSourceRankingItem] 未找到 browsingRankingList');
        return;
    }

    // 查找所有排行项
    const items = listContainer.querySelectorAll('.ranking-item');
    console.log('[highlightSourceRankingItem] 查找排行项:', url, '找到', items.length, '个项目');

    let found = false;

    items.forEach(item => {
        // 通过跳转按钮的 data-url 来匹配
        const jumpBtn = item.querySelector('.jump-to-related-btn');
        if (jumpBtn && jumpBtn.dataset.url === url && !found) {
            found = true;
            console.log('[highlightSourceRankingItem] 找到匹配排行项，添加高亮');
            item.classList.add('highlight-source');
            item.scrollIntoView({ behavior: 'instant', block: 'center' });

            // 3秒后移除高亮
            setTimeout(() => {
                item.classList.remove('highlight-source');
            }, 3000);
        }
    });

    if (!found) {
        console.warn('[highlightSourceRankingItem] 未找到匹配的排行项');
    }
}

// ============================================================================
// 回到顶部悬浮按钮功能
// ============================================================================

// 为指定面板创建回到顶部按钮
function createScrollToTopForPanel(panelId) {
    const panel = document.getElementById(panelId);
    if (!panel) return;

    // 检查是否已存在
    if (panel.querySelector('.scroll-to-top-btn')) return;

    const btn = document.createElement('button');
    btn.className = 'scroll-to-top-btn';
    btn.innerHTML = '<i class="fas fa-arrow-up"></i>';
    btn.title = typeof currentLang !== 'undefined' && currentLang === 'zh_CN' ? '回到顶部' : 'Back to Top';

    btn.addEventListener('click', () => {
        const contentArea = document.querySelector('.content-area');
        if (contentArea) {
            contentArea.scrollTo({ top: 0, behavior: 'smooth' });
        }
    });

    panel.style.position = 'relative';
    panel.appendChild(btn);

    return btn;
}

// 初始化所有回到顶部按钮
function initScrollToTopButtons() {
    const contentArea = document.querySelector('.content-area');
    if (!contentArea) return;

    // 为三个面板创建按钮
    createScrollToTopForPanel('browsingHistoryPanel');
    createScrollToTopForPanel('browsingRankingPanel');
    createScrollToTopForPanel('browsingRelatedPanel');

    // 获取所有按钮
    const buttons = document.querySelectorAll('.scroll-to-top-btn');

    // 监听滚动
    contentArea.addEventListener('scroll', () => {
        const show = contentArea.scrollTop > 200;
        buttons.forEach(btn => {
            btn.style.display = show ? 'flex' : 'none';
        });
    });
}

// 在 DOMContentLoaded 后初始化
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(initScrollToTopButtons, 1000);
    // 初始化导出变化模态框
    initExportChangesModal();
});

// ==================== 导出变化功能 ====================

// 当前导出的变化数据（供模态框使用）
let currentExportChangeData = null;
// 当前导出的历史记录（供备份历史导出使用）
let currentExportHistoryRecord = null;
// 当前导出的书签树（供备份历史导出使用）
let currentExportBookmarkTree = null;

// 显示导出变化模态框
function showExportChangesModal(changeData) {
    console.log('[showExportChangesModal] 接收到的 changeData:', changeData);
    console.log('[showExportChangesModal] changeData 的所有属性:', Object.keys(changeData || {}));
    console.log('[showExportChangesModal] hasChanges:', changeData?.hasChanges);
    console.log('[showExportChangesModal] stats:', changeData?.stats);
    console.log('[showExportChangesModal] diffMeta:', changeData?.diffMeta);
    console.log('[showExportChangesModal] added:', changeData?.added?.length || 0, changeData?.added);
    console.log('[showExportChangesModal] deleted:', changeData?.deleted?.length || 0, changeData?.deleted);
    console.log('[showExportChangesModal] modified:', changeData?.modified?.length || 0, changeData?.modified);
    console.log('[showExportChangesModal] moved:', changeData?.moved?.length || 0, changeData?.moved);

    currentExportChangeData = changeData;
    const modal = document.getElementById('exportChangesModal');
    if (modal) {
        modal.classList.add('show');
        // 重置为默认值
        const formatHtml = modal.querySelector('input[name="exportChangesFormat"][value="html"]');
        if (formatHtml) formatHtml.checked = true;
        const modeSimple = modal.querySelector('input[name="exportChangesMode"][value="simple"]');
        if (modeSimple) modeSimple.checked = true;
        const actionDownload = modal.querySelector('input[name="exportChangesAction"][value="download"]');
        if (actionDownload) actionDownload.checked = true;
        // 隐藏扩展层级
        const depthSection = document.getElementById('exportChangesDepthSection');
        if (depthSection) depthSection.style.display = 'none';

        // 隐藏详细模式说明
        const helpContent = document.getElementById('exportChangesDetailedHelpContent');
        if (helpContent) helpContent.style.display = 'none';

        // 隐藏标记说明
        const legendHelpContent = document.getElementById('exportChangesLegendHelpContent');
        if (legendHelpContent) legendHelpContent.style.display = 'none';
    }
}

// 显示备份历史的导出变化模态框
async function showHistoryExportChangesModal(recordTime, options = {}) {
    console.log('[showHistoryExportChangesModal] 记录时间:', recordTime);
    const { preferredMode, useDomTreeContainer, treeContainer } = options;

    // 查找记录
    const record = syncHistory.find(r => r.time === recordTime);
    if (!record) {
        showToast(currentLang === 'zh_CN' ? '未找到记录' : 'Record not found');
        return;
    }

    // 检查是否有 bookmarkTree
    if (!record.bookmarkTree) {
        showToast(currentLang === 'zh_CN' ? '该记录没有详细数据（旧记录已清理）' : 'No detailed data available (old records cleaned)');
        return;
    }

    // 找到上一条记录进行对比
    const recordIndex = syncHistory.findIndex(r => r.time === recordTime);
    let previousRecord = null;
    if (recordIndex > 0) {
        for (let i = recordIndex - 1; i >= 0; i--) {
            if (syncHistory[i].status === 'success' && syncHistory[i].bookmarkTree) {
                previousRecord = syncHistory[i];
                break;
            }
        }
    }

    // 计算变化 - 使用与"当前变化"相同的 detectTreeChangesFast
    let changeMap = new Map();
    let treeToExport = record.bookmarkTree;

    if (previousRecord && previousRecord.bookmarkTree) {
        changeMap = await detectTreeChangesFast(previousRecord.bookmarkTree, record.bookmarkTree, {
            useGlobalExplicitMovedIds: false,
            explicitMovedIdSet: (record && record.bookmarkStats && Array.isArray(record.bookmarkStats.explicitMovedIds))
                ? record.bookmarkStats.explicitMovedIds
                : null
        });

        // 关键：如果有删除的节点，需要重建树结构（与"当前变化"一致）
        let hasDeleted = false;
        for (const [, change] of changeMap) {
            if (change.type && change.type.includes('deleted')) {
                hasDeleted = true;
                break;
            }
        }
        if (hasDeleted) {
            try {
                treeToExport = rebuildTreeWithDeleted(previousRecord.bookmarkTree, record.bookmarkTree, changeMap);
                console.log('[showHistoryExportChangesModal] 已重建包含删除节点的树');
            } catch (error) {
                console.error('[showHistoryExportChangesModal] 重建树失败:', error);
                treeToExport = record.bookmarkTree;
            }
        }
    } else if (record.isFirstBackup) {
        // 第一次备份，所有书签都是新增
        const allNodes = flattenBookmarkTree(record.bookmarkTree);
        allNodes.forEach(item => {
            if (item.id) changeMap.set(item.id, { type: 'added' });
        });
    }

    console.log('[showHistoryExportChangesModal] 变化统计:', changeMap.size);

    // 保存当前导出数据（现在是 Map 格式）
    currentExportChangeData = changeMap;
    currentExportHistoryRecord = record;
    currentExportBookmarkTree = treeToExport;
    currentExportHistoryTreeContainer = useDomTreeContainer ? (treeContainer || document.querySelector('#modalBody .history-tree-container')) : null;

    // 显示模态框
    const modal = document.getElementById('exportChangesModal');
    if (modal) {
        modal.classList.add('show');
        // 重置为默认值
        const formatHtml = modal.querySelector('input[name="exportChangesFormat"][value="html"]');
        if (formatHtml) formatHtml.checked = true;

        // 使用当前备份历史的详略模式
        const modeValue = preferredMode || getRecordDetailMode(recordTime) || historyDetailMode || 'simple';
        const modeRadio = modal.querySelector(`input[name="exportChangesMode"][value="${modeValue}"]`);
        if (modeRadio) modeRadio.checked = true;

        const actionDownload = modal.querySelector('input[name="exportChangesAction"][value="download"]');
        if (actionDownload) actionDownload.checked = true;

        // 隐藏扩展层级
        const depthSection = document.getElementById('exportChangesDepthSection');
        if (depthSection) depthSection.style.display = 'none';

        // 隐藏详细模式说明
        const helpContent = document.getElementById('exportChangesDetailedHelpContent');
        if (helpContent) helpContent.style.display = 'none';

        // 隐藏标记说明
        const legendHelpContent = document.getElementById('exportChangesLegendHelpContent');
        if (legendHelpContent) legendHelpContent.style.display = 'none';
    }
}

// 初始化导出变化模态框
function initExportChangesModal() {
    const modal = document.getElementById('exportChangesModal');
    if (!modal) return;

    // 关闭按钮
    const closeBtn = document.getElementById('exportChangesModalClose');
    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            modal.classList.remove('show');
            // 清除历史导出数据
            currentExportHistoryRecord = null;
            currentExportBookmarkTree = null;
            currentExportHistoryTreeContainer = null;
        });
    }

    // 点击遮罩关闭
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.classList.remove('show');
            // 清除历史导出数据
            currentExportHistoryRecord = null;
            currentExportBookmarkTree = null;
            currentExportHistoryTreeContainer = null;
        }
    });

    // 模式切换 - 控制扩展层级显示
    const modeRadios = modal.querySelectorAll('input[name="exportChangesMode"]');
    const depthSection = document.getElementById('exportChangesDepthSection');
    modeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            if (depthSection) {
                // 新的详细模式（快照）不需要手动选择层级，完全依赖界面展开状态
                // 所以隐藏层级选择器
                depthSection.style.display = 'none';
            }
            // 切换模式时隐藏帮助内容
            const helpContent = document.getElementById('exportChangesDetailedHelpContent');
            if (helpContent) helpContent.style.display = 'none';
        });
    });

    // 绑定标记说明图标点击事件
    const legendHelpIcon = document.getElementById('exportChangesLegendHelp');
    if (legendHelpIcon) {
        legendHelpIcon.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const legendHelpContent = document.getElementById('exportChangesLegendHelpContent');
            if (legendHelpContent) {
                legendHelpContent.style.display = legendHelpContent.style.display === 'none' ? 'block' : 'none';
            }
        });
    }

    // 绑定帮助图标点击事件
    const helpIcon = document.getElementById('exportChangesDetailedHelp');
    if (helpIcon) {
        helpIcon.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            // 切换到详细模式
            const modeDetailed = document.querySelector('input[name="exportChangesMode"][value="detailed"]');
            if (modeDetailed) {
                modeDetailed.checked = true;
                // 注意：这里不手动触发 change 事件，或者是触发后我们要单独处理 toggle
                // 如果触发 change，上面的 listener 会隐藏 helpContent
                // 所以我们需要在触发 change 之后再显示 helpContent

                // 仅当 checked 状态改变时才触发 change (虽然 radio 点击总会触发)
                // 这里我们手动调用 logic 比较保险
                // modeDetailed.dispatchEvent(new Event('change'));

                // 为了兼容性，我们还是触发 change，然后专门显示 helpContent
                // 但是 change listener 会 sync setting，这里逻辑也简单:
                // 先 check，后 toggle
                if (depthSection) depthSection.style.display = 'none';
            }

            // 切换功能说明显示状态
            const helpContent = document.getElementById('exportChangesDetailedHelpContent');
            if (helpContent) {
                if (helpContent.style.display === 'none') {
                    const isZh = currentLang === 'zh_CN';
                    helpContent.innerHTML = isZh
                        ? '<strong>功能说明：</strong><br>即导出当前『详细视图』的“快照”（所见即所得）：<br>• 仅导出界面上<strong>已展开</strong>的文件夹内容。<br>• “数量/结构 变化”默认展开。'
                        : '<strong>Function Explanation:</strong><br>Exports a "snapshot" of the current "Detailed View" (WYSIWYG):<br>• Only content of <strong>expanded</strong> folders is exported.<br>• "Quantity/Structure Changes" is expanded by default.';
                    helpContent.style.display = 'block';
                } else {
                    helpContent.style.display = 'none';
                }
            }
        });
    }

    // 扩展层级滑块
    const depthSlider = document.getElementById('exportChangesDepth');
    const depthValue = document.getElementById('exportChangesDepthValue');
    if (depthSlider && depthValue) {
        depthSlider.addEventListener('input', () => {
            const val = parseInt(depthSlider.value);
            const isZh = currentLang === 'zh_CN';
            if (val === 0) {
                depthValue.textContent = isZh ? '仅同级' : 'Same level';
            } else {
                depthValue.textContent = isZh ? `${val} 层` : `${val} level${val > 1 ? 's' : ''}`;
            }
        });
    }

    // 开始导出按钮
    const exportBtn = document.getElementById('doExportChangesBtn');
    if (exportBtn) {
        exportBtn.addEventListener('click', () => {
            executeExportChanges();
        });
    }
}

// 执行导出
async function executeExportChanges() {
    const modal = document.getElementById('exportChangesModal');
    if (!modal || !currentExportChangeData) return;

    const format = modal.querySelector('input[name="exportChangesFormat"]:checked')?.value || 'html';
    const mode = modal.querySelector('input[name="exportChangesMode"]:checked')?.value || 'simple';
    const action = modal.querySelector('input[name="exportChangesAction"]:checked')?.value || 'download';
    const depth = parseInt(document.getElementById('exportChangesDepth')?.value || '1');
    const confirmBtn = document.getElementById('doExportChangesBtn');

    // 保存原始按钮状态
    const originalBtnHTML = confirmBtn.innerHTML;
    const isZh = currentLang === 'zh_CN';

    // 判断是否是备份历史导出
    const isHistoryExport = !!currentExportHistoryRecord;
    const useHistoryDomTree = isHistoryExport && !!currentExportHistoryTreeContainer;

    try {
        let content = '';
        let filename = '';
        const timestamp = formatTimeForFilename(); // 当前时间（导出时间）

        // 设置按钮加载状态
        confirmBtn.disabled = true;
        confirmBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${isZh ? '处理中...' : 'Processing...'}`;

        // 稍微延迟一下让UI更新，避免大计算量卡顿
        await new Promise(resolve => setTimeout(resolve, 50));

        if (format === 'html') {
            if (isHistoryExport) {
                // 备份历史导出 - 优先使用详情面板DOM（所见即所得）
                content = useHistoryDomTree
                    ? await generateHistoryChangesHTMLFromDOM(currentExportHistoryTreeContainer, mode)
                    : await generateHistoryChangesHTML(currentExportBookmarkTree, currentExportChangeData, mode);

                // Construct filename: Note_Hash_Mode_Time
                const record = currentExportHistoryRecord;
                const dateStr = formatTimeForFilename(record.time); // 备份时间（本地时间）
                const cleanNote = record.note ? record.note.replace(/[\\/:*?"<>|]/g, '_').replace(/\s+/g, '_') : '';
                const fingerprint = record.fingerprint ? `_${record.fingerprint.substring(0, 7)}` : '';
                const modeStr = mode === 'simple' ? (isZh ? '_简略' : '_Simple') : (isZh ? '_详细' : '_Detailed');
                const defaultPrefix = isZh ? '书签' : 'bookmark';

                const baseName = cleanNote
                    ? `${cleanNote}${fingerprint}${modeStr}_${dateStr}`
                    : `${defaultPrefix}${fingerprint}${modeStr}_${dateStr}`;

                filename = `${baseName}.html`;
            } else {
                // 当前变化导出 - 从 DOM 提取
                content = await generateChangesHTML(currentExportChangeData, mode, depth);
                const changesPrefix = isZh ? '书签变化' : 'bookmark-changes';
                filename = `${changesPrefix}-${timestamp}.html`;
            }
        } else {
            if (isHistoryExport) {
                // 备份历史导出 - 优先使用详情面板DOM（所见即所得）
                content = useHistoryDomTree
                    ? await generateHistoryChangesJSONFromDOM(currentExportHistoryTreeContainer, mode)
                    : await generateHistoryChangesJSON(currentExportBookmarkTree, currentExportChangeData, mode);

                // Construct filename: Note_Hash_Mode_Time
                const record = currentExportHistoryRecord;
                const dateStr = formatTimeForFilename(record.time); // 备份时间（本地时间）
                const cleanNote = record.note ? record.note.replace(/[\\/:*?"<>|]/g, '_').replace(/\s+/g, '_') : '';
                const fingerprint = record.fingerprint ? `_${record.fingerprint.substring(0, 7)}` : '';
                const modeStr = mode === 'simple' ? (isZh ? '_简略' : '_Simple') : (isZh ? '_详细' : '_Detailed');
                const defaultPrefix = isZh ? '书签' : 'bookmark';

                const baseName = cleanNote
                    ? `${cleanNote}${fingerprint}${modeStr}_${dateStr}`
                    : `${defaultPrefix}${fingerprint}${modeStr}_${dateStr}`;

                filename = `${baseName}.json`;
            } else {
                // 当前变化导出 - 从 DOM 提取
                content = await generateChangesJSON(currentExportChangeData, mode, depth);
                const changesPrefix = isZh ? '书签变化' : 'bookmark-changes';
                filename = `${changesPrefix}-${timestamp}.json`;
            }
            // 如果是 JSON 格式，content 是对象，需要 stringify
            if (typeof content === 'object') {
                content = JSON.stringify(content, null, 2);
            }
        }

        if (action === 'download') {
            // 同步导出到云端（云端1 WebDAV + 云端2 GitHub Repo）
            try {
                if (chrome && chrome.runtime && typeof chrome.runtime.sendMessage === 'function') {
                    const folderKey = isHistoryExport ? 'history' : 'current_changes';
                    const contentType = format === 'html' ? 'text/html;charset=utf-8' : 'application/json;charset=utf-8';
                    chrome.runtime.sendMessage({
                        action: 'exportFileToClouds',
                        folderKey,
                        lang: currentLang,
                        fileName: filename,
                        content,
                        contentType
                    }, (resp) => {
                        try {
                            if (!resp) return;
                            const isEnLang = currentLang !== 'zh_CN';

                            const webdavOk = resp.webdav && resp.webdav.success === true;
                            const githubRepoOk = resp.githubRepo && resp.githubRepo.success === true;
                            const webdavSkipped = resp.webdav && resp.webdav.skipped === true;
                            const githubRepoSkipped = resp.githubRepo && resp.githubRepo.skipped === true;

                            if (webdavOk && githubRepoOk) {
                                showToast(isEnLang ? 'Uploaded to Cloud 1 & Cloud 2' : '已上传到云端1&云端2');
                                return;
                            }
                            if (webdavOk) {
                                showToast(isEnLang ? 'Uploaded to Cloud 1 (WebDAV)' : '已上传到云端1(WebDAV)');
                                return;
                            }
                            if (githubRepoOk) {
                                showToast(isEnLang ? 'Uploaded to Cloud 2 (GitHub Repo)' : '已上传到云端2(GitHub仓库)');
                                return;
                            }

                            const attempted = !(webdavSkipped && githubRepoSkipped);
                            const errorMsg = resp.webdav?.error || resp.githubRepo?.error || resp.error || null;
                            if (attempted && errorMsg) {
                                showToast(isEnLang ? `Cloud upload failed: ${errorMsg}` : `云端上传失败：${errorMsg}`);
                            }
                        } catch (_) { }
                    });
                }
            } catch (_) { }

            // 下载文件 - 使用统一的导出文件夹结构
            const blob = new Blob([content], { type: format === 'html' ? 'text/html' : 'application/json' });
            const url = URL.createObjectURL(blob);

            // 根据导出类型选择不同的子文件夹（根据语言动态选择）
            const exportSubFolder = isHistoryExport ? getHistoryExportFolder() : getCurrentChangesExportFolder();
            const exportPath = `${getHistoryExportRootFolder()}/${exportSubFolder}`;

            // 尝试使用 chrome.downloads API 以支持子目录
            if (chrome && chrome.downloads && typeof chrome.downloads.download === 'function') {
                chrome.downloads.download({
                    url: url,
                    filename: `${exportPath}/${filename}`,
                    saveAs: false,
                    conflictAction: 'uniquify'
                }, (downloadId) => {
                    if (chrome.runtime.lastError) {
                        console.warn('chrome.downloads API failed, falling back to <a> tag:', chrome.runtime.lastError);
                        // 降级方案
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        a.click();
                    }
                    setTimeout(() => URL.revokeObjectURL(url), 10000);
                });
            } else {
                // 降级方案
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                setTimeout(() => URL.revokeObjectURL(url), 10000);
            }
        } else {
            // 复制到剪贴板
            await navigator.clipboard.writeText(content);
        }

        // 显示成功状态（绿色背景 + 绿色脉冲）
        confirmBtn.style.setProperty('background-color', 'var(--success)', 'important');
        confirmBtn.style.setProperty('color', 'white', 'important');
        confirmBtn.style.setProperty('border-color', 'var(--success)', 'important');
        confirmBtn.style.animation = 'pulse-green 1s';

        // 图标白色，并添加弹跳动画
        confirmBtn.innerHTML = `<i class="fas fa-check-circle" style="color: white; animation: bounce-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); font-size: 1.2em;"></i> ${isZh ? '成功' : 'Success'}`;

        // 1.5秒后关闭模态框并恢复按钮
        setTimeout(() => {
            modal.classList.remove('show');
            // 清除历史导出数据
            currentExportHistoryRecord = null;
            currentExportBookmarkTree = null;
            currentExportHistoryTreeContainer = null;
            // 恢复按钮状态
            setTimeout(() => {
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = originalBtnHTML;
                confirmBtn.style.backgroundColor = '';
                confirmBtn.style.color = '';
                confirmBtn.style.borderColor = '';
                confirmBtn.style.animation = ''; // 清除动画
            }, 300);
        }, 1200);

    } catch (error) {
        console.error('[导出变化] 失败:', error);

        // 显示错误状态
        confirmBtn.style.backgroundColor = 'var(--danger-color)';
        confirmBtn.style.color = 'white';
        confirmBtn.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${isZh ? '失败' : 'Failed'}`;

        alert(isZh ? `导出失败: ${error.message}` : `Export failed: ${error.message}`);

        // 恢复按钮状态
        setTimeout(() => {
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = originalBtnHTML;
            confirmBtn.style.backgroundColor = '';
            confirmBtn.style.color = '';
        }, 2000);
    }
}

function formatExportTimeText(date = new Date()) {
    try {
        if (typeof formatTime === 'function') {
            return formatTime(date);
        }
        return date.toLocaleString();
    } catch (e) {
        return new Date().toISOString();
    }
}

function getChangeCountsFromChangeData(changeData) {
    if (!changeData) return null;
    const diffMeta = changeData.diffMeta || {};
    const stats = changeData.stats || {};

    const bookmarkDiff = typeof diffMeta.bookmarkDiff === 'number' ? diffMeta.bookmarkDiff : 0;
    const folderDiff = typeof diffMeta.folderDiff === 'number' ? diffMeta.folderDiff : 0;

    const addedBookmarks = bookmarkDiff > 0 ? bookmarkDiff : 0;
    const deletedBookmarks = bookmarkDiff < 0 ? Math.abs(bookmarkDiff) : 0;
    const addedFolders = folderDiff > 0 ? folderDiff : 0;
    const deletedFolders = folderDiff < 0 ? Math.abs(folderDiff) : 0;

    const bookmarkMoved = typeof stats.bookmarkMoved === 'number' ? stats.bookmarkMoved : (stats.bookmarkMoved ? 1 : 0);
    const folderMoved = typeof stats.folderMoved === 'number' ? stats.folderMoved : (stats.folderMoved ? 1 : 0);
    const bookmarkModified = typeof stats.bookmarkModified === 'number' ? stats.bookmarkModified : (stats.bookmarkModified ? 1 : 0);
    const folderModified = typeof stats.folderModified === 'number' ? stats.folderModified : (stats.folderModified ? 1 : 0);

    const counts = {
        added: { bookmarks: addedBookmarks, folders: addedFolders },
        deleted: { bookmarks: deletedBookmarks, folders: deletedFolders },
        modified: { bookmarks: bookmarkModified, folders: folderModified },
        moved: { bookmarks: bookmarkMoved, folders: folderMoved }
    };

    if (addedBookmarks || addedFolders || deletedBookmarks || deletedFolders || bookmarkModified || folderModified || bookmarkMoved || folderMoved) {
        return counts;
    }
    return null;
}

function countChangeTypesFromDOM(treeContainer) {
    if (!treeContainer) {
        return {
            added: { bookmarks: 0, folders: 0 },
            deleted: { bookmarks: 0, folders: 0 },
            modified: { bookmarks: 0, folders: 0 },
            moved: { bookmarks: 0, folders: 0 }
        };
    }
    const treeRoot = treeContainer.querySelector('.bookmark-tree') || treeContainer;
    if (!treeRoot) {
        return {
            added: { bookmarks: 0, folders: 0 },
            deleted: { bookmarks: 0, folders: 0 },
            modified: { bookmarks: 0, folders: 0 },
            moved: { bookmarks: 0, folders: 0 }
        };
    }

    const counts = {
        added: { bookmarks: 0, folders: 0 },
        deleted: { bookmarks: 0, folders: 0 },
        modified: { bookmarks: 0, folders: 0 },
        moved: { bookmarks: 0, folders: 0 }
    };
    treeRoot.querySelectorAll('.tree-item').forEach(item => {
        const type = item.dataset.nodeType || (item.querySelector('.tree-bookmark-link') ? 'bookmark' : 'folder');
        const target = type === 'folder' ? 'folders' : 'bookmarks';
        if (item.classList.contains('tree-change-added')) counts.added[target] += 1;
        if (item.classList.contains('tree-change-deleted')) counts.deleted[target] += 1;
        if (item.classList.contains('tree-change-modified')) counts.modified[target] += 1;
        if (item.classList.contains('tree-change-moved')) counts.moved[target] += 1;
        if (item.classList.contains('tree-change-mixed')) {
            counts.modified[target] += 1;
            counts.moved[target] += 1;
        }
    });
    return counts;
}

function getHistoryChangeCounts(changeMap, bookmarkTree) {
    const counts = {
        added: { bookmarks: 0, folders: 0 },
        deleted: { bookmarks: 0, folders: 0 },
        modified: { bookmarks: 0, folders: 0 },
        moved: { bookmarks: 0, folders: 0 }
    };
    if (!changeMap) return counts;

    const nodeMap = new Map();
    function buildNodeMap(node) {
        if (!node) return;
        if (node.id) nodeMap.set(node.id, node);
        if (node.children) node.children.forEach(buildNodeMap);
    }
    const treeNodes = Array.isArray(bookmarkTree) ? bookmarkTree : [bookmarkTree];
    treeNodes.forEach(buildNodeMap);

    changeMap.forEach((change, id) => {
        if (!change || !change.type) return;
        const node = nodeMap.get(id);
        const isFolder = node && !node.url && node.children;
        const bucket = isFolder ? 'folders' : 'bookmarks';
        const types = change.type.split('+');
        if (types.includes('added')) counts.added[bucket] += 1;
        if (types.includes('deleted')) counts.deleted[bucket] += 1;
        if (types.includes('modified')) counts.modified[bucket] += 1;
        if (types.includes('moved')) counts.moved[bucket] += 1;
    });

    return counts;
}

function formatCountsLine(counts, isZh) {
    const labels = isZh
        ? { added: '新增', deleted: '删除', modified: '修改', moved: '移动', b: '书签', f: '文件夹' }
        : { added: 'Added', deleted: 'Deleted', modified: 'Modified', moved: 'Moved', b: 'BKM', f: 'FLD' };
    const formatPair = (pair) => {
        const parts = [];
        if (pair.bookmarks) parts.push(`${pair.bookmarks}${labels.b}`);
        if (pair.folders) parts.push(`${pair.folders}${labels.f}`);
        return parts.join(' ');
    };
    const parts = [];
    if (counts.added.bookmarks || counts.added.folders) parts.push(`${labels.added}:${formatPair(counts.added)}`);
    if (counts.deleted.bookmarks || counts.deleted.folders) parts.push(`${labels.deleted}:${formatPair(counts.deleted)}`);
    if (counts.modified.bookmarks || counts.modified.folders) parts.push(`${labels.modified}:${formatPair(counts.modified)}`);
    if (counts.moved.bookmarks || counts.moved.folders) parts.push(`${labels.moved}:${formatPair(counts.moved)}`);
    return parts.join('  ');
}

function hasAnyCounts(counts) {
    if (!counts) return false;
    return Object.values(counts).some(pair => (pair?.bookmarks || pair?.folders));
}

// 生成变化HTML
async function generateChangesHTML(changeData, mode, depth) {
    const isZh = currentLang === 'zh_CN';
    const now = new Date().toLocaleString();

    let html = '<!DOCTYPE NETSCAPE-Bookmark-file-1>\n';
    html += '<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">\n';
    html += `<TITLE>${isZh ? '书签变化' : 'Bookmark Changes'}</TITLE>\n`;
    html += `<H1>${isZh ? '书签变化' : 'Bookmark Changes'}</H1>\n`;
    html += '<DL><p>\n';

    // 添加图例说明（一行）
    const legendText = isZh
        ? '📋 前缀说明: [+]新增  [-]删除  [~]修改  [↔]移动'
        : '📋 Prefix legend: [+]Added  [-]Deleted  [~]Modified  [↔]Moved';
    html += `    <DT><H3>${legendText}</H3>\n`;
    const countsFromData = getChangeCountsFromChangeData(changeData);
    const countsFromDom = countChangeTypesFromDOM(document.getElementById('changesTreePreviewInline'));
    const counts = hasAnyCounts(countsFromData) ? countsFromData : countsFromDom;
    const exportTimeText = formatExportTimeText();
    html += `    <DL><p>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '操作统计' : 'Operation Counts'}: ${formatCountsLine(counts, isZh)}</A>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '导出时间' : 'Export Time'}: ${escapeHtml(exportTimeText)}</A>\n`;
    html += `    </DL><p>\n`;

    // 从 DOM 提取书签树
    const treeContainer = document.getElementById('changesTreePreviewInline');
    if (!treeContainer) {
        console.log('[generateChangesHTML] 未找到 changesTreePreviewInline');
        html += `    <DT><H3>${isZh ? '(无书签树数据)' : '(No bookmark tree data)'}</H3>\n`;
        html += '</DL><p>\n';
        return html;
    }

    const bookmarkTree = treeContainer.querySelector('.bookmark-tree');
    if (!bookmarkTree) {
        console.log('[generateChangesHTML] 未找到 .bookmark-tree');
        html += `    <DT><H3>${isZh ? '(无书签树数据)' : '(No bookmark tree data)'}</H3>\n`;
        html += '</DL><p>\n';
        return html;
    }

    console.log('[generateChangesHTML] 找到书签树, 开始提取变化');

    // 递归检查节点是否包含变化（自身或子节点）
    function hasChanges(treeNode) {
        const treeItem = treeNode.querySelector(':scope > .tree-item');
        if (!treeItem) return false;

        // 检查自身是否有变化
        if (treeItem.classList.contains('tree-change-added') ||
            treeItem.classList.contains('tree-change-deleted') ||
            treeItem.classList.contains('tree-change-modified') ||
            treeItem.classList.contains('tree-change-moved')) {
            return true;
        }

        // 检查子节点
        const childrenContainer = treeNode.querySelector(':scope > .tree-children');
        if (childrenContainer) {
            const childNodes = childrenContainer.querySelectorAll(':scope > .tree-node');
            for (const child of childNodes) {
                if (hasChanges(child)) return true;
            }
        }

        return false;
    }

    // 检查当前节点（treeItem）是否自身有变化标记
    function hasSelfChange(treeItem) {
        if (!treeItem) return false;
        return treeItem.classList.contains('tree-change-added') ||
            treeItem.classList.contains('tree-change-deleted') ||
            treeItem.classList.contains('tree-change-modified') ||
            treeItem.classList.contains('tree-change-moved');
    }

    // 递归生成 HTML
    // forceInclude: 如果为true，表示父级文件夹有变化标记，当前节点应该被强制导出
    function generateNodeHTML(nodeEl, indentLevel, forceInclude = false) {
        let result = '';
        const indent = '    '.repeat(indentLevel);

        const treeNodes = nodeEl.querySelectorAll(':scope > .tree-node');

        treeNodes.forEach(treeNode => {
            const treeItem = treeNode.querySelector(':scope > .tree-item');
            if (!treeItem) return;

            // 简略模式：只导出有变化的分支，或者被强制包含的节点
            // 详细模式（快照）：只要是可见的
            if (mode !== 'detailed' && !forceInclude && !hasChanges(treeNode)) return;

            // 从 data 属性获取标题和 URL（空标题用根目录表示）
            let title = treeItem.dataset.nodeTitle || treeItem.querySelector('.tree-label')?.textContent?.trim() || '';
            if (!title) title = currentLang === 'zh_CN' ? '根目录' : 'Root';
            const url = treeItem.dataset.nodeUrl || '';
            const nodeType = treeItem.dataset.nodeType;

            // 检查变化类型并添加前缀
            let prefix = '';
            if (treeItem.classList.contains('tree-change-added')) {
                prefix = '[+] ';
            } else if (treeItem.classList.contains('tree-change-deleted')) {
                prefix = '[-] ';
            } else if (treeItem.classList.contains('tree-change-modified')) {
                prefix = '[~] ';
            } else if (treeItem.classList.contains('tree-change-moved')) {
                prefix = '[↔] ';
            }

            const displayTitle = prefix + title;
            const isFolder = nodeType === 'folder' || !url;

            if (isFolder) {
                // 文件夹
                result += `${indent}<DT><H3>${escapeHtml(displayTitle)}</H3>\n`;
                result += `${indent}<DL><p>\n`;

                // 递归处理子节点
                const childrenContainer = treeNode.querySelector(':scope > .tree-children');
                if (childrenContainer) {
                    let shouldRecurse = false;
                    // 简略模式下，如果当前文件夹自身有变化标记，则强制包含所有子节点
                    const shouldForceIncludeChildren = mode !== 'detailed' && !forceInclude && hasSelfChange(treeItem);
                    const nextForceInclude = forceInclude || shouldForceIncludeChildren;

                    if (mode === 'detailed') {
                        // 详细模式：检查展开状态
                        if (childrenContainer.classList.contains('expanded')) {
                            shouldRecurse = true;
                        }
                    } else {
                        // 简略模式：如果有变化或者被强制包含，则递归
                        shouldRecurse = true;
                    }

                    if (shouldRecurse) {
                        result += generateNodeHTML(childrenContainer, indentLevel + 1, nextForceInclude);
                    }
                }

                result += `${indent}</DL><p>\n`;
            } else {
                // 书签
                result += `${indent}<DT><A HREF="${escapeHtml(url)}">${escapeHtml(displayTitle)}</A>\n`;
            }
        });

        return result;
    }

    // 生成书签树 HTML
    html += generateNodeHTML(bookmarkTree, 1);

    html += '</DL><p>\n';

    console.log('[generateChangesHTML] 生成的 HTML 长度:', html.length);

    return html;
}

// 生成变化JSON
async function generateChangesJSON(changeData, mode, depth) {
    const isZh = currentLang === 'zh_CN';
    const now = new Date().toISOString();

    // 从 DOM 提取书签树中的变化节点
    const treeContainer = document.getElementById('changesTreePreviewInline');
    const bookmarkTreeEl = treeContainer?.querySelector('.bookmark-tree');

    // 递归检查节点是否包含变化
    function hasChanges(treeNode) {
        const treeItem = treeNode.querySelector(':scope > .tree-item');
        if (!treeItem) return false;

        if (treeItem.classList.contains('tree-change-added') ||
            treeItem.classList.contains('tree-change-deleted') ||
            treeItem.classList.contains('tree-change-modified') ||
            treeItem.classList.contains('tree-change-moved')) {
            return true;
        }

        const childrenContainer = treeNode.querySelector(':scope > .tree-children');
        if (childrenContainer) {
            const childNodes = childrenContainer.querySelectorAll(':scope > .tree-node');
            for (const child of childNodes) {
                if (hasChanges(child)) return true;
            }
        }

        return false;
    }

    // 检查当前节点（treeItem）是否自身有变化标记
    function hasSelfChange(treeItem) {
        if (!treeItem) return false;
        return treeItem.classList.contains('tree-change-added') ||
            treeItem.classList.contains('tree-change-deleted') ||
            treeItem.classList.contains('tree-change-modified') ||
            treeItem.classList.contains('tree-change-moved');
    }

    // 递归提取树结构
    // forceInclude: 如果为true，表示父级文件夹有变化标记，当前节点应该被强制导出
    function extractTree(nodeEl, forceInclude = false) {
        const result = [];
        const treeNodes = nodeEl.querySelectorAll(':scope > .tree-node');

        treeNodes.forEach(treeNode => {
            const treeItem = treeNode.querySelector(':scope > .tree-item');
            if (!treeItem) return;

            // 简略模式：只导出有变化的分支，或者被强制包含的节点
            // 详细模式（快照）：只要是可见的
            if (mode !== 'detailed' && !forceInclude && !hasChanges(treeNode)) return;

            let title = treeItem.dataset.nodeTitle || treeItem.querySelector('.tree-label')?.textContent?.trim() || '';
            if (!title) title = currentLang === 'zh_CN' ? '根目录' : 'Root';
            const url = treeItem.dataset.nodeUrl || '';
            const nodeType = treeItem.dataset.nodeType;

            let changeType = null;
            if (treeItem.classList.contains('tree-change-added')) {
                changeType = 'added';
            } else if (treeItem.classList.contains('tree-change-deleted')) {
                changeType = 'deleted';
            } else if (treeItem.classList.contains('tree-change-modified')) {
                changeType = 'modified';
            } else if (treeItem.classList.contains('tree-change-moved')) {
                changeType = 'moved';
            }

            const isFolder = nodeType === 'folder' || !url;

            const item = {
                title: changeType ? `${getChangePrefix(changeType)} ${title}` : title,
                type: isFolder ? 'folder' : 'bookmark',
                ...(url ? { url } : {}),
                ...(changeType ? { changeType } : {})
            };

            if (isFolder) {
                const childrenContainer = treeNode.querySelector(':scope > .tree-children');
                if (childrenContainer) {
                    let shouldRecurse = false;
                    // 简略模式下，如果当前文件夹自身有变化标记，则强制包含所有子节点
                    const shouldForceIncludeChildren = mode !== 'detailed' && !forceInclude && hasSelfChange(treeItem);
                    const nextForceInclude = forceInclude || shouldForceIncludeChildren;

                    if (mode === 'detailed') {
                        // 详细模式：检查展开状态
                        if (childrenContainer.classList.contains('expanded')) {
                            shouldRecurse = true;
                        }
                    } else {
                        // 简略模式：如果有变化或者被强制包含，则递归
                        shouldRecurse = true;
                    }

                    if (shouldRecurse) {
                        item.children = extractTree(childrenContainer, nextForceInclude);
                    } else {
                        item.children = [];
                    }
                } else {
                    item.children = [];
                }
            }

            result.push(item);
        });

        return result;
    }

    const bookmarkTree = bookmarkTreeEl ? extractTree(bookmarkTreeEl) : [];
    const countsFromData = getChangeCountsFromChangeData(changeData);
    const countsFromDom = countChangeTypesFromDOM(document.getElementById('changesTreePreviewInline'));
    const counts = hasAnyCounts(countsFromData) ? countsFromData : countsFromDom;
    const exportTimeText = formatExportTimeText();
    const legendFolder = {
        title: isZh
            ? '📋 前缀说明: [+]新增  [-]删除  [~]修改  [↔]移动'
            : '📋 Prefix legend: [+]Added  [-]Deleted  [~]Modified  [↔]Moved',
        children: [
            {
                title: `${isZh ? '操作统计' : 'Operation Counts'}: ${formatCountsLine(counts, isZh)}`,
                url: 'about:blank'
            },
            {
                title: `${isZh ? '导出时间' : 'Export Time'}: ${exportTimeText}`,
                url: 'about:blank'
            }
        ]
    };

    // 构建兼容 Chrome bookmarks API 格式的输出
    // Chrome API 格式: {id, title, children: [...]}
    const result = {
        // 标准字段
        title: isZh ? '书签变化导出' : 'Bookmark Changes Export',
        children: [legendFolder, ...bookmarkTree],
        // 元信息（下划线前缀表示非标准扩展字段）
        _exportInfo: {
            exportDate: now,
            exportMode: mode,
            source: 'bookmark-backup-changes',
            legend: {
                '[+]': isZh ? '新增' : 'Added',
                '[-]': isZh ? '删除' : 'Deleted',
                '[~]': isZh ? '修改' : 'Modified',
                '[↔]': isZh ? '移动' : 'Moved'
            }
        }
    };

    return JSON.stringify(result, null, 2);
}

// 生成备份历史的变化HTML（从详情面板DOM提取，所见即所得）
async function generateHistoryChangesHTMLFromDOM(treeContainer, mode) {
    const isZh = currentLang === 'zh_CN';

    let html = '<!DOCTYPE NETSCAPE-Bookmark-file-1>\n';
    html += '<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">\n';
    html += `<TITLE>${isZh ? '书签变化' : 'Bookmark Changes'}</TITLE>\n`;
    html += `<H1>${isZh ? '书签变化' : 'Bookmark Changes'}</H1>\n`;
    html += '<DL><p>\n';

    const legendText = isZh
        ? '📋 前缀说明: [+]新增  [-]删除  [~]修改  [↔]移动'
        : '📋 Prefix legend: [+]Added  [-]Deleted  [~]Modified  [↔]Moved';
    html += `    <DT><H3>${legendText}</H3>\n`;
    const counts = getHistoryChangeCounts(currentExportChangeData, currentExportBookmarkTree);
    const exportTimeText = formatExportTimeText();
    const backupTimeText = currentExportHistoryRecord?.time
        ? (typeof formatTime === 'function' ? formatTime(new Date(currentExportHistoryRecord.time)) : new Date(currentExportHistoryRecord.time).toLocaleString())
        : '';
    const noteText = currentExportHistoryRecord?.note ? currentExportHistoryRecord.note : (isZh ? '（无备注）' : '(No note)');
    html += `    <DL><p>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '操作统计' : 'Operation Counts'}: ${formatCountsLine(counts, isZh)}</A>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '导出时间' : 'Export Time'}: ${escapeHtml(exportTimeText)}</A>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '备份时间' : 'Backup Time'}: ${escapeHtml(backupTimeText)}</A>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '备注' : 'Note'}: ${escapeHtml(noteText)}</A>\n`;
    html += `    </DL><p>\n`;

    const bookmarkTree = treeContainer?.classList?.contains('bookmark-tree')
        ? treeContainer
        : treeContainer?.querySelector?.('.bookmark-tree');

    if (!bookmarkTree) {
        html += `    <DT><H3>${isZh ? '(无书签树数据)' : '(No bookmark tree data)'}</H3>\n`;
        html += '</DL><p>\n';
        return html;
    }

    function hasChanges(treeNode) {
        const treeItem = treeNode.querySelector(':scope > .tree-item');
        if (!treeItem) return false;

        if (treeItem.classList.contains('tree-change-added') ||
            treeItem.classList.contains('tree-change-deleted') ||
            treeItem.classList.contains('tree-change-modified') ||
            treeItem.classList.contains('tree-change-moved') ||
            treeItem.classList.contains('tree-change-mixed')) {
            return true;
        }

        const childrenContainer = treeNode.querySelector(':scope > .tree-children');
        if (childrenContainer) {
            const childNodes = childrenContainer.querySelectorAll(':scope > .tree-node');
            for (const child of childNodes) {
                if (hasChanges(child)) return true;
            }
        }

        return false;
    }

    function getChangePrefixFromItem(treeItem) {
        if (treeItem.classList.contains('tree-change-added')) return '[+] ';
        if (treeItem.classList.contains('tree-change-deleted')) return '[-] ';
        if (treeItem.classList.contains('tree-change-mixed')) return '[~↔] ';
        if (treeItem.classList.contains('tree-change-modified')) return '[~] ';
        if (treeItem.classList.contains('tree-change-moved')) return '[↔] ';
        return '';
    }

    // 检查当前节点（treeItem）是否自身有变化标记
    function hasSelfChange(treeItem) {
        if (!treeItem) return false;
        return treeItem.classList.contains('tree-change-added') ||
            treeItem.classList.contains('tree-change-deleted') ||
            treeItem.classList.contains('tree-change-modified') ||
            treeItem.classList.contains('tree-change-moved') ||
            treeItem.classList.contains('tree-change-mixed');
    }

    // forceInclude: 如果为true，表示父级文件夹有变化标记，当前节点应该被强制导出
    function generateNodeHTML(nodeEl, indentLevel, forceInclude = false) {
        let result = '';
        const indent = '    '.repeat(indentLevel);
        const treeNodes = nodeEl.querySelectorAll(':scope > .tree-node');

        treeNodes.forEach(treeNode => {
            const treeItem = treeNode.querySelector(':scope > .tree-item');
            if (!treeItem) return;

            // 简略模式：只导出有变化的分支，或者被强制包含的节点
            if (mode !== 'detailed' && !forceInclude && !hasChanges(treeNode)) return;

            const link = treeItem.querySelector('a.tree-bookmark-link') || treeItem.querySelector('a');
            const url = link ? link.getAttribute('href') : '';
            let title = treeItem.dataset.nodeTitle || treeItem.querySelector('.tree-label')?.textContent?.trim() || '';
            if (!title && link) title = link.textContent.trim();
            if (!title) title = isZh ? '根目录' : 'Root';

            const nodeType = treeItem.dataset.nodeType;
            const isFolder = nodeType === 'folder' || !url;
            const displayTitle = getChangePrefixFromItem(treeItem) + title;

            if (isFolder) {
                result += `${indent}<DT><H3>${escapeHtml(displayTitle)}</H3>\n`;
                result += `${indent}<DL><p>\n`;

                const childrenContainer = treeNode.querySelector(':scope > .tree-children');
                if (childrenContainer) {
                    let shouldRecurse = false;
                    // 简略模式下，如果当前文件夹自身有变化标记，则强制包含所有子节点
                    const shouldForceIncludeChildren = mode !== 'detailed' && !forceInclude && hasSelfChange(treeItem);
                    const nextForceInclude = forceInclude || shouldForceIncludeChildren;

                    if (mode === 'detailed') {
                        shouldRecurse = childrenContainer.classList.contains('expanded');
                    } else {
                        shouldRecurse = true;
                    }

                    if (shouldRecurse) {
                        result += generateNodeHTML(childrenContainer, indentLevel + 1, nextForceInclude);
                    }
                }

                result += `${indent}</DL><p>\n`;
            } else {
                result += `${indent}<DT><A HREF="${escapeHtml(url)}">${escapeHtml(displayTitle)}</A>\n`;
            }
        });

        return result;
    }

    html += generateNodeHTML(bookmarkTree, 1);
    html += '</DL><p>\n';

    return html;
}

// 生成备份历史的变化JSON（从详情面板DOM提取，所见即所得）
async function generateHistoryChangesJSONFromDOM(treeContainer, mode) {
    const isZh = currentLang === 'zh_CN';
    const now = new Date().toISOString();

    const bookmarkTree = treeContainer?.classList?.contains('bookmark-tree')
        ? treeContainer
        : treeContainer?.querySelector?.('.bookmark-tree');

    if (!bookmarkTree) {
        return {
            title: isZh ? '书签变化导出' : 'Bookmark Changes Export',
            children: [],
            _exportInfo: {
                exportDate: now,
                exportMode: mode,
                source: 'bookmark-backup-history',
                error: isZh ? '无书签树数据' : 'No bookmark tree data'
            }
        };
    }

    function hasChanges(treeNode) {
        const treeItem = treeNode.querySelector(':scope > .tree-item');
        if (!treeItem) return false;

        if (treeItem.classList.contains('tree-change-added') ||
            treeItem.classList.contains('tree-change-deleted') ||
            treeItem.classList.contains('tree-change-modified') ||
            treeItem.classList.contains('tree-change-moved') ||
            treeItem.classList.contains('tree-change-mixed')) {
            return true;
        }

        const childrenContainer = treeNode.querySelector(':scope > .tree-children');
        if (childrenContainer) {
            const childNodes = childrenContainer.querySelectorAll(':scope > .tree-node');
            for (const child of childNodes) {
                if (hasChanges(child)) return true;
            }
        }

        return false;
    }

    function getChangeTypeFromItem(treeItem) {
        if (treeItem.classList.contains('tree-change-added')) return 'added';
        if (treeItem.classList.contains('tree-change-deleted')) return 'deleted';
        if (treeItem.classList.contains('tree-change-mixed')) return 'modified+moved';
        if (treeItem.classList.contains('tree-change-modified')) return 'modified';
        if (treeItem.classList.contains('tree-change-moved')) return 'moved';
        return null;
    }

    // 检查当前节点（treeItem）是否自身有变化标记
    function hasSelfChange(treeItem) {
        if (!treeItem) return false;
        return treeItem.classList.contains('tree-change-added') ||
            treeItem.classList.contains('tree-change-deleted') ||
            treeItem.classList.contains('tree-change-modified') ||
            treeItem.classList.contains('tree-change-moved') ||
            treeItem.classList.contains('tree-change-mixed');
    }

    // forceInclude: 如果为true，表示父级文件夹有变化标记，当前节点应该被强制导出
    function extractTree(nodeEl, forceInclude = false) {
        const result = [];
        const treeNodes = nodeEl.querySelectorAll(':scope > .tree-node');

        treeNodes.forEach(treeNode => {
            const treeItem = treeNode.querySelector(':scope > .tree-item');
            if (!treeItem) return;

            // 简略模式：只导出有变化的分支，或者被强制包含的节点
            if (mode !== 'detailed' && !forceInclude && !hasChanges(treeNode)) return;

            const link = treeItem.querySelector('a.tree-bookmark-link') || treeItem.querySelector('a');
            const url = link ? link.getAttribute('href') : '';
            let title = treeItem.dataset.nodeTitle || treeItem.querySelector('.tree-label')?.textContent?.trim() || '';
            if (!title && link) title = link.textContent.trim();
            if (!title) title = isZh ? '根目录' : 'Root';

            const nodeType = treeItem.dataset.nodeType;
            const isFolder = nodeType === 'folder' || !url;
            const changeType = getChangeTypeFromItem(treeItem);

            const item = {
                title: changeType ? `${getChangePrefix(changeType)} ${title}` : title,
                type: isFolder ? 'folder' : 'bookmark',
                ...(url ? { url } : {}),
                ...(changeType ? { changeType } : {})
            };

            if (isFolder) {
                const childrenContainer = treeNode.querySelector(':scope > .tree-children');
                if (childrenContainer) {
                    let shouldRecurse = false;
                    // 简略模式下，如果当前文件夹自身有变化标记，则强制包含所有子节点
                    const shouldForceIncludeChildren = mode !== 'detailed' && !forceInclude && hasSelfChange(treeItem);
                    const nextForceInclude = forceInclude || shouldForceIncludeChildren;

                    if (mode === 'detailed') {
                        shouldRecurse = childrenContainer.classList.contains('expanded');
                    } else {
                        shouldRecurse = true;
                    }

                    item.children = shouldRecurse ? extractTree(childrenContainer, nextForceInclude) : [];
                }
            }

            result.push(item);
        });

        return result;
    }

    const counts = getHistoryChangeCounts(currentExportChangeData, currentExportBookmarkTree);
    const exportTimeText = formatExportTimeText();
    const backupTimeText = currentExportHistoryRecord?.time
        ? (typeof formatTime === 'function' ? formatTime(new Date(currentExportHistoryRecord.time)) : new Date(currentExportHistoryRecord.time).toLocaleString())
        : '';
    const noteText = currentExportHistoryRecord?.note ? currentExportHistoryRecord.note : (isZh ? '（无备注）' : '(No note)');
    const legendFolder = {
        title: isZh
            ? '📋 前缀说明: [+]新增  [-]删除  [~]修改  [↔]移动'
            : '📋 Prefix legend: [+]Added  [-]Deleted  [~]Modified  [↔]Moved',
        children: [
            {
                title: `${isZh ? '操作统计' : 'Operation Counts'}: ${formatCountsLine(counts, isZh)}`,
                url: 'about:blank'
            },
            {
                title: `${isZh ? '导出时间' : 'Export Time'}: ${exportTimeText}`,
                url: 'about:blank'
            },
            {
                title: `${isZh ? '备份时间' : 'Backup Time'}: ${backupTimeText}`,
                url: 'about:blank'
            },
            {
                title: `${isZh ? '备注' : 'Note'}: ${noteText}`,
                url: 'about:blank'
            }
        ]
    };

    return {
        title: isZh ? '书签变化导出' : 'Bookmark Changes Export',
        children: [legendFolder, ...extractTree(bookmarkTree)],
        _exportInfo: {
            exportDate: now,
            exportMode: mode,
            source: 'bookmark-backup-history',
            legend: {
                '[+]': isZh ? '新增' : 'Added',
                '[-]': isZh ? '删除' : 'Deleted',
                '[~]': isZh ? '修改' : 'Modified',
                '[↔]': isZh ? '移动' : 'Moved',
                '[~↔]': isZh ? '修改+移动' : 'Modified+Moved'
            }
        }
    };
}

// 生成备份历史的变化HTML（从书签树直接生成，不依赖DOM）
// changeMap: Map<id, {type: 'added'|'deleted'|'modified'|'moved'|'modified+moved', moved?: {...}}>
async function generateHistoryChangesHTML(bookmarkTree, changeMap, mode, expandedIds = null) {
    const isZh = currentLang === 'zh_CN';
    const now = new Date().toLocaleString();

    // 在详细模式下，如果提供了 expandedIds，则只展开这些节点（WYSIWYG）
    const useWysiwygExpansion = mode === 'detailed' && expandedIds && expandedIds.size > 0;

    let html = '<!DOCTYPE NETSCAPE-Bookmark-file-1>\n';
    html += '<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">\n';
    html += `<TITLE>${isZh ? '书签变化' : 'Bookmark Changes'}</TITLE>\n`;
    html += `<H1>${isZh ? '书签变化' : 'Bookmark Changes'}</H1>\n`;
    html += '<DL><p>\n';

    // 添加图例说明（一行）
    const legendText = isZh
        ? '📋 前缀说明: [+]新增  [-]删除  [~]修改  [↔]移动'
        : '📋 Prefix legend: [+]Added  [-]Deleted  [~]Modified  [↔]Moved';
    html += `    <DT><H3>${legendText}</H3>\n`;
    const counts = getHistoryChangeCounts(changeMap, bookmarkTree);
    const exportTimeText = formatExportTimeText();
    const backupTimeText = currentExportHistoryRecord?.time
        ? (typeof formatTime === 'function' ? formatTime(new Date(currentExportHistoryRecord.time)) : new Date(currentExportHistoryRecord.time).toLocaleString())
        : '';
    const noteText = currentExportHistoryRecord?.note ? currentExportHistoryRecord.note : (isZh ? '（无备注）' : '(No note)');
    html += `    <DL><p>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '操作统计' : 'Operation Counts'}: ${formatCountsLine(counts, isZh)}</A>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '导出时间' : 'Export Time'}: ${escapeHtml(exportTimeText)}</A>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '备份时间' : 'Backup Time'}: ${escapeHtml(backupTimeText)}</A>\n`;
    html += `        <DT><A HREF="about:blank">${isZh ? '备注' : 'Note'}: ${escapeHtml(noteText)}</A>\n`;
    html += `    </DL><p>\n`;

    if (!bookmarkTree) {
        html += `    <DT><H3>${isZh ? '(无书签树数据)' : '(No bookmark tree data)'}</H3>\n`;
        html += '</DL><p>\n';
        return html;
    }

    // 检查某个节点或其子节点是否有变化
    function hasChangesRecursive(node) {
        if (!node) return false;
        if (changeMap.has(node.id)) return true;
        if (node.children) {
            return node.children.some(child => hasChangesRecursive(child));
        }
        return false;
    }

    // 递归生成 HTML
    // 详细模式：显示所有节点，但只展开有变化的路径（与"当前变化"一致）
    // 简略模式：只导出有变化的分支
    function generateNodeHTML(node, indentLevel) {
        if (!node) return '';

        // 检查该节点或其子节点是否有变化
        const nodeHasChanges = hasChangesRecursive(node);

        // 简略模式：只导出有变化的分支
        if (mode !== 'detailed' && !nodeHasChanges) return '';

        let result = '';
        const indent = '    '.repeat(indentLevel);

        const title = node.title || (isZh ? '(无标题)' : '(Untitled)');
        const url = node.url || '';
        const isFolder = !url && node.children;

        // 检查变化类型并添加前缀（支持组合类型如 'modified+moved'）
        let prefix = '';
        const change = changeMap.get(node.id);
        if (change) {
            const types = change.type ? change.type.split('+') : [];
            if (types.includes('added')) {
                prefix = '[+] ';
            } else if (types.includes('deleted')) {
                prefix = '[-] ';
            } else if (types.includes('modified') && types.includes('moved')) {
                prefix = '[~↔] ';
            } else if (types.includes('modified')) {
                prefix = '[~] ';
            } else if (types.includes('moved')) {
                prefix = '[↔] ';
            }
        }

        const displayTitle = prefix + escapeHtml(title);

        if (isFolder) {
            // 文件夹
            result += `${indent}<DT><H3>${displayTitle}</H3>\n`;
            result += `${indent}<DL><p>\n`;

            // 递归处理子节点
            // 详细模式：只有该节点路径有变化时才展开（递归子节点）
            // 简略模式：只要有变化就递归
            if (node.children && node.children.length > 0) {
                let shouldRecurse = false;

                if (mode === 'detailed') {
                    // 详细模式
                    if (useWysiwygExpansion) {
                        // WYSIWYG: 只展开用户手动展开过的节点
                        shouldRecurse = expandedIds.has(String(node.id));
                    } else {
                        // 默认行为：只有有变化的路径才展开
                        shouldRecurse = nodeHasChanges;
                    }
                } else {
                    // 简略模式：一定有变化才能到这里，所以递归
                    shouldRecurse = true;
                }

                if (shouldRecurse) {
                    node.children.forEach(child => {
                        result += generateNodeHTML(child, indentLevel + 1);
                    });
                }
            }

            result += `${indent}</DL><p>\n`;
        } else if (url) {
            // 书签
            result += `${indent}<DT><A HREF="${escapeHtml(url)}">${displayTitle}</A>\n`;
        }

        return result;
    }

    // 生成书签树 HTML
    const nodes = Array.isArray(bookmarkTree) ? bookmarkTree : [bookmarkTree];
    nodes.forEach(node => {
        if (node.children) {
            node.children.forEach(child => {
                html += generateNodeHTML(child, 1);
            });
        }
    });

    html += '</DL><p>\n';

    console.log('[generateHistoryChangesHTML] 生成的 HTML 长度:', html.length);

    return html;
}

// 生成备份历史的变化JSON（从书签树直接生成，不依赖DOM）
// changeMap: Map<id, {type: 'added'|'deleted'|'modified'|'moved'|'modified+moved', moved?: {...}}>
async function generateHistoryChangesJSON(bookmarkTree, changeMap, mode, expandedIds = null) {
    const isZh = currentLang === 'zh_CN';
    const now = new Date().toISOString();

    // 在详细模式下，如果提供了 expandedIds，则只展开这些节点（WYSIWYG）
    const useWysiwygExpansion = mode === 'detailed' && expandedIds && expandedIds.size > 0;

    if (!bookmarkTree) {
        return {
            title: isZh ? '书签变化导出' : 'Bookmark Changes Export',
            children: [],
            _exportInfo: {
                exportDate: now,
                exportMode: mode,
                source: 'bookmark-backup-history',
                error: isZh ? '无书签树数据' : 'No bookmark tree data'
            }
        };
    }

    // 检查某个节点或其子节点是否有变化
    function hasChangesRecursive(node) {
        if (!node) return false;
        if (changeMap.has(node.id)) return true;
        if (node.children) {
            return node.children.some(child => hasChangesRecursive(child));
        }
        return false;
    }

    // 递归提取树结构
    // 详细模式：显示所有节点，但只展开有变化的路径（与"当前变化"一致）
    // 简略模式：只导出有变化的分支
    function extractTree(node) {
        if (!node) return null;

        // 检查该节点或其子节点是否有变化
        const nodeHasChanges = hasChangesRecursive(node);

        // 简略模式：只导出有变化的分支
        if (mode !== 'detailed' && !nodeHasChanges) return null;

        const title = node.title || (isZh ? '(无标题)' : '(Untitled)');
        const url = node.url || '';
        const isFolder = !url && node.children;

        // 检查变化类型（支持组合类型如 'modified+moved'）
        const change = changeMap.get(node.id);
        let prefix = '';
        let changeType = null;
        if (change) {
            changeType = change.type;
            const types = change.type ? change.type.split('+') : [];
            if (types.includes('added')) {
                prefix = '[+] ';
            } else if (types.includes('deleted')) {
                prefix = '[-] ';
            } else if (types.includes('modified') && types.includes('moved')) {
                prefix = '[~↔] ';
            } else if (types.includes('modified')) {
                prefix = '[~] ';
            } else if (types.includes('moved')) {
                prefix = '[↔] ';
            }
        }

        const item = {
            title: prefix + title,
            type: isFolder ? 'folder' : 'bookmark',
            ...(url ? { url } : {}),
            ...(changeType ? { changeType } : {})
        };

        if (isFolder && node.children) {
            // 详细模式：只有有变化的路径才展开（递归子节点）
            // 简略模式：一定有变化才能到这里，所以递归
            let shouldRecurse = false;

            if (mode === 'detailed') {
                // 详细模式
                if (useWysiwygExpansion) {
                    // WYSIWYG: 只展开用户手动展开过的节点
                    shouldRecurse = expandedIds.has(String(node.id));
                } else {
                    // 默认行为：只有有变化的路径才展开
                    shouldRecurse = nodeHasChanges;
                }
            } else {
                // 简略模式：一定有变化才能到这里，所以递归
                shouldRecurse = true;
            }

            if (shouldRecurse) {
                item.children = node.children
                    .map(child => extractTree(child))
                    .filter(child => child !== null);
            } else {
                item.children = [];
            }
        }

        return item;
    }

    // 提取书签树
    const nodes = Array.isArray(bookmarkTree) ? bookmarkTree : [bookmarkTree];
    const children = [];
    nodes.forEach(node => {
        if (node.children) {
            node.children.forEach(child => {
                const extracted = extractTree(child);
                if (extracted) {
                    children.push(extracted);
                }
            });
        }
    });

    // 构建兼容 Chrome bookmarks API 格式的输出
    const counts = getHistoryChangeCounts(changeMap, bookmarkTree);
    const exportTimeText = formatExportTimeText();
    const backupTimeText = currentExportHistoryRecord?.time
        ? (typeof formatTime === 'function' ? formatTime(new Date(currentExportHistoryRecord.time)) : new Date(currentExportHistoryRecord.time).toLocaleString())
        : '';
    const noteText = currentExportHistoryRecord?.note ? currentExportHistoryRecord.note : (isZh ? '（无备注）' : '(No note)');
    const legendFolder = {
        title: isZh
            ? '📋 前缀说明: [+]新增  [-]删除  [~]修改  [↔]移动'
            : '📋 Prefix legend: [+]Added  [-]Deleted  [~]Modified  [↔]Moved',
        children: [
            {
                title: `${isZh ? '操作统计' : 'Operation Counts'}: ${formatCountsLine(counts, isZh)}`,
                url: 'about:blank'
            },
            {
                title: `${isZh ? '导出时间' : 'Export Time'}: ${exportTimeText}`,
                url: 'about:blank'
            },
            {
                title: `${isZh ? '备份时间' : 'Backup Time'}: ${backupTimeText}`,
                url: 'about:blank'
            },
            {
                title: `${isZh ? '备注' : 'Note'}: ${noteText}`,
                url: 'about:blank'
            }
        ]
    };

    const result = {
        title: isZh ? '书签变化导出' : 'Bookmark Changes Export',
        children: [legendFolder, ...children],
        _exportInfo: {
            exportDate: now,
            exportMode: mode,
            source: 'bookmark-backup-history',
            legend: {
                '[+]': isZh ? '新增' : 'Added',
                '[-]': isZh ? '删除' : 'Deleted',
                '[~]': isZh ? '修改' : 'Modified',
                '[↔]': isZh ? '移动' : 'Moved',
                '[~↔]': isZh ? '修改+移动' : 'Modified+Moved'
            }
        }
    };

    return result;
}

// 收集要导出的变化项
function collectChangesForExport(changeData, mode, depth) {
    let changes = [];

    console.log('[导出变化] changeData:', changeData);
    console.log('[导出变化] mode:', mode, 'depth:', depth);

    if (!changeData) {
        console.warn('[导出变化] changeData 为空');
        return changes;
    }

    // 添加基本变化
    if (changeData.added && Array.isArray(changeData.added)) {
        console.log('[导出变化] added 数量:', changeData.added.length);
        for (const item of changeData.added) {
            changes.push({ ...item, changeType: 'added' });
        }
    }
    if (changeData.deleted && Array.isArray(changeData.deleted)) {
        console.log('[导出变化] deleted 数量:', changeData.deleted.length);
        for (const item of changeData.deleted) {
            changes.push({ ...item, changeType: 'deleted' });
        }
    }
    if (changeData.modified && Array.isArray(changeData.modified)) {
        console.log('[导出变化] modified 数量:', changeData.modified.length);
        for (const item of changeData.modified) {
            changes.push({ ...item, changeType: 'modified' });
        }
    }
    if (changeData.moved && Array.isArray(changeData.moved)) {
        console.log('[导出变化] moved 数量:', changeData.moved.length);
        for (const item of changeData.moved) {
            changes.push({ ...item, changeType: 'moved' });
        }
    }

    // 如果变化数组为空，尝试从 DOM 提取变化
    if (changes.length === 0) {
        console.log('[导出变化] 变化数组为空，尝试从 DOM 提取');
        changes = collectChangesFromDOM();
    }

    console.log('[导出变化] 收集到的变化总数:', changes.length);
    if (changes.length > 0) {
        console.log('[导出变化] 第一个变化项示例:', changes[0]);
    }

    // 如果是详细模式，扩展上下文
    if (mode === 'detailed' && depth > 0) {
        // TODO: 实现上下文扩展逻辑
        // 这里需要获取变化项的父级和同级书签
        // 暂时只返回变化项本身
        console.log('[导出变化] 详细模式，扩展层级:', depth);
    }

    return changes;
}

// 从 DOM 中提取完整的书签树数据（简略模式）
function collectChangesFromDOM() {
    const treeContainer = document.getElementById('changesTreePreviewInline');

    if (!treeContainer) {
        console.warn('[导出变化] 未找到书签树容器');
        return [];
    }

    // 递归提取书签树
    function extractTreeNode(nodeEl, depth = 0) {
        const result = [];

        // 找到当前节点下的所有直接 tree-node
        const treeNodes = nodeEl.querySelectorAll(':scope > .tree-node');

        treeNodes.forEach(treeNode => {
            const treeItem = treeNode.querySelector(':scope > .tree-item');
            if (!treeItem) return;

            // 获取标题
            const labelEl = treeItem.querySelector('.tree-label');
            const linkEl = treeItem.querySelector('a.tree-label');

            const title = labelEl?.textContent?.trim() || linkEl?.textContent?.trim() || 'Untitled';
            const url = linkEl?.href || '';

            // 检查变化类型
            let changeType = null;
            if (treeItem.classList.contains('tree-change-added')) {
                changeType = 'added';
            } else if (treeItem.classList.contains('tree-change-deleted')) {
                changeType = 'deleted';
            } else if (treeItem.classList.contains('tree-change-modified')) {
                changeType = 'modified';
            } else if (treeItem.classList.contains('tree-change-moved')) {
                changeType = 'moved';
            }

            const isFolder = !url;

            const item = {
                title,
                url,
                changeType,
                isFolder,
                depth,
                children: []
            };

            // 如果是文件夹，递归获取子项
            if (isFolder) {
                const childrenContainer = treeNode.querySelector(':scope > .tree-children');
                if (childrenContainer) {
                    item.children = extractTreeNode(childrenContainer, depth + 1);
                }
            }

            result.push(item);
        });

        return result;
    }

    // 从根节点开始提取
    const rootChildren = treeContainer.querySelector('.tree-children');
    if (!rootChildren) {
        // 尝试直接从容器开始
        const directNodes = treeContainer.querySelectorAll('.tree-node');
        if (directNodes.length === 0) {
            console.warn('[导出变化] 书签树为空');
            return [];
        }
    }

    const tree = extractTreeNode(treeContainer, 0);
    console.log('[导出变化] 从 DOM 提取的书签树:', tree);

    // 展平树结构为变化列表（保留路径信息）
    const flatChanges = [];

    function flattenTree(nodes, path = '') {
        for (const node of nodes) {
            const currentPath = path ? `${path}/${node.title}` : node.title;

            // 添加到结果
            flatChanges.push({
                title: node.title,
                url: node.url,
                changeType: node.changeType,
                path: path,
                isFolder: node.isFolder,
                depth: node.depth
            });

            // 递归子节点
            if (node.children && node.children.length > 0) {
                flattenTree(node.children, node.isFolder ? currentPath : path);
            }
        }
    }

    flattenTree(tree);
    console.log('[导出变化] 展平后的变化列表:', flatChanges.length, '项');

    return flatChanges;
}

// 获取变化类型前缀
function getChangePrefix(changeType) {
    switch (changeType) {
        case 'added': return '[+]';
        case 'deleted': return '[-]';
        case 'modified': return '[~]';
        case 'moved': return '[↔]';
        case 'modified+moved': return '[~↔]';
        default: return '';
    }
}

// HTML转义
function escapeHtml(str) {
    if (!str) return '';
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

// =============================================================================
// 全局导出功能 (Global Export)
// =============================================================================

// =============================================================================
// 全局导出功能 (Global Export)
// =============================================================================

function initGlobalExport() {
    const btn = document.getElementById('globalExportBtn');
    if (btn) {
        btn.addEventListener('click', showGlobalExportModal);
    }

    const closeBtn = document.getElementById('globalExportModalClose');
    if (closeBtn) {
        closeBtn.addEventListener('click', closeGlobalExportModal);
    }

    const cancelBtn = document.getElementById('globalExportCancelBtn');
    if (cancelBtn) {
        cancelBtn.addEventListener('click', closeGlobalExportModal);
    }

    const confirmBtn = document.getElementById('globalExportConfirmBtn');
    if (confirmBtn) {
        confirmBtn.addEventListener('click', startGlobalExport);
    }

    // 全选交互
    const selectAllCbox = document.getElementById('globalExportSelectAll');
    if (selectAllCbox) {
        selectAllCbox.addEventListener('change', (e) => {
            const checked = e.target.checked;
            // 更新所有记录的选中状态（跨页）
            Object.keys(globalExportSelectedState).forEach(key => {
                globalExportSelectedState[key] = checked;
            });
            // 更新当前页的 UI
            document.querySelectorAll('.global-export-row-checkbox').forEach(cb => cb.checked = checked);
            updateGlobalExportStatus();
            syncGlobalExportRangeUiAfterListSelectionChange();
        });
    }

    initGlobalExportRangeUI();

    // 导出格式：三选一（HTML / JSON / Markdown）
    const formatHtmlCbox = document.getElementById('globalExportFormatHtml');
    const formatJsonCbox = document.getElementById('globalExportFormatJson');
    const formatMdCbox = document.getElementById('globalExportFormatMd');

    const packMergeRadio = document.getElementById('globalExportPackMerge');
    const packZipRadio = document.getElementById('globalExportPackZip');

    const formatCboxes = [formatHtmlCbox, formatJsonCbox, formatMdCbox].filter(Boolean);

    const applyPackRulesForMd = (isMdSelected) => {
        if (!packMergeRadio || !packZipRadio) return;

        if (isMdSelected) {
            // MD 强制“合并”，并禁用 Zip
            packMergeRadio.checked = true;
            packZipRadio.disabled = true;
            if (packZipRadio.parentElement) packZipRadio.parentElement.style.opacity = '0.5';
        } else {
            // 非 MD 恢复 Zip 可用
            packZipRadio.disabled = false;
            if (packZipRadio.parentElement) packZipRadio.parentElement.style.opacity = '1';
        }
    };

    const enforceSingleFormat = (activeCbox) => {
        formatCboxes.forEach((cbox) => {
            if (cbox !== activeCbox) cbox.checked = false;
        });
        applyPackRulesForMd(Boolean(formatMdCbox?.checked));
    };

    formatCboxes.forEach((cbox) => {
        cbox.addEventListener('change', (e) => {
            const target = e.target;
            if (target.checked) {
                enforceSingleFormat(target);
                return;
            }

            // 不允许全部取消：如果用户把最后一个也取消，则自动恢复勾选
            const anyChecked = formatCboxes.some(cb => cb.checked);
            if (!anyChecked) {
                target.checked = true;
            }
            applyPackRulesForMd(Boolean(formatMdCbox?.checked));
        });
    });

    // 初始化一次（防止默认勾选/历史状态导致 pack 状态不一致）
    applyPackRulesForMd(Boolean(formatMdCbox?.checked));

    // 导出卡片点击交互 (让整个卡片可点击)
    document.querySelectorAll('.export-option-card').forEach(card => {
        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox) {
            // 初始化状态
            if (checkbox.checked) card.classList.add('selected');

            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });
        }
    });

    const modal = document.getElementById('globalExportModal');
    if (modal) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeGlobalExportModal();
        });
    }
}

function closeGlobalExportModal() {
    document.getElementById('globalExportModal').classList.remove('show');
}

function updateGlobalExportStatus() {
    const selectedCount = Object.values(globalExportSelectedState).filter(v => v === true).length;
    const total = Object.keys(globalExportSelectedState).length;
    const statusEl = document.getElementById('globalExportStatus');

    if (statusEl) {
        statusEl.textContent = `${currentLang === 'zh_CN' ? '已选' : 'Selected'} ${selectedCount} / ${total}`;
    }

    const confirmBtn = document.getElementById('globalExportConfirmBtn');
    if (confirmBtn) {
        confirmBtn.disabled = selectedCount === 0;
        confirmBtn.style.opacity = selectedCount === 0 ? '0.5' : '1';
    }

    // 联动全选按钮状态
    updateSelectAllCheckboxState();
}

// 全局导出分页状态
let globalExportCurrentPage = 1;
const GLOBAL_EXPORT_PAGE_SIZE = 10;
let globalExportSelectedState = {}; // 保存每条记录的选中状态

let globalExportSeqNumberByTime = new Map(); // time(string) -> seqNumber(number)

let globalExportRangeBoundsCache = { min: 1, max: 1 };
let globalExportRangeApplyingSelection = false;
let globalExportActiveRangeThumb = 'max'; // 'min' | 'max'
let globalExportRangeRafPending = false;

function initGlobalExportRangeUI() {
    const toggleBtn = document.getElementById('globalExportRangeToggleBtn');
    const panel = document.getElementById('globalExportRangePanel');
    const enabledCbox = document.getElementById('globalExportRangeEnabled');
    const minSlider = document.getElementById('globalExportRangeMin');
    const maxSlider = document.getElementById('globalExportRangeMax');

    if (!toggleBtn || !panel || !enabledCbox || !minSlider || !maxSlider) return;

    if (!toggleBtn.hasAttribute('data-listener-attached')) {
        toggleBtn.addEventListener('click', () => {
            const isExpanded = panel.style.display !== 'none';
            setGlobalExportRangePanelExpanded(!isExpanded);
        });
        toggleBtn.setAttribute('data-listener-attached', 'true');
    }

    if (!enabledCbox.hasAttribute('data-listener-attached')) {
        enabledCbox.addEventListener('change', () => {
            const enabled = Boolean(enabledCbox.checked);
            setGlobalExportRangeEnabled(enabled);
            updateGlobalExportRangeHighlight();
            updateGlobalExportRangePreviewText();
            if (enabled) {
                applyGlobalExportSelectionByCurrentThumbRange();
            }
        });
        enabledCbox.setAttribute('data-listener-attached', 'true');
    }

    const handleMinInput = () => {
        updateGlobalExportRangeHighlight();
        updateGlobalExportRangePreviewText();
        if (isGlobalExportRangePanelExpanded()) {
            globalExportCurrentPage = 1;
            renderGlobalExportPage();
        }
        if (enabledCbox.checked) {
            applyGlobalExportSelectionByCurrentThumbRange();
        }
    };

    const handleMaxInput = () => {
        updateGlobalExportRangeHighlight();
        updateGlobalExportRangePreviewText();
        if (isGlobalExportRangePanelExpanded()) {
            globalExportCurrentPage = 1;
            renderGlobalExportPage();
        }
        if (enabledCbox.checked) {
            applyGlobalExportSelectionByCurrentThumbRange();
        }
    };

    if (!minSlider.hasAttribute('data-listener-attached')) {
        minSlider.addEventListener('input', handleMinInput);
        minSlider.addEventListener('pointerdown', () => {
            minSlider.style.zIndex = '5';
            maxSlider.style.zIndex = '4';
            globalExportActiveRangeThumb = 'min';
        });
        minSlider.setAttribute('data-listener-attached', 'true');
    }
    if (!maxSlider.hasAttribute('data-listener-attached')) {
        maxSlider.addEventListener('input', handleMaxInput);
        maxSlider.addEventListener('pointerdown', () => {
            maxSlider.style.zIndex = '5';
            minSlider.style.zIndex = '4';
            globalExportActiveRangeThumb = 'max';
        });
        maxSlider.setAttribute('data-listener-attached', 'true');
    }

    setGlobalExportRangePanelExpanded(false);
    setGlobalExportRangeEnabled(false);
    updateGlobalExportRangePreviewText();
}

function scheduleGlobalExportRangeUiUpdate() {
    if (globalExportRangeRafPending) return;
    globalExportRangeRafPending = true;
    requestAnimationFrame(() => {
        globalExportRangeRafPending = false;
        updateGlobalExportRangeHighlight();
        updateGlobalExportRangePreviewText();
    });
}

function isGlobalExportRangePanelExpanded() {
    const panel = document.getElementById('globalExportRangePanel');
    if (!panel) return false;
    return panel.style.display !== 'none';
}

function setGlobalExportRangePanelExpanded(expanded) {
    const panel = document.getElementById('globalExportRangePanel');
    const toggleBtn = document.getElementById('globalExportRangeToggleBtn');
    if (!panel || !toggleBtn) return;

    const wasExpanded = panel.style.display !== 'none';
    panel.style.display = expanded ? 'block' : 'none';
    const icon = toggleBtn.querySelector('i');
    if (icon) {
        icon.classList.toggle('fa-chevron-down', !expanded);
        icon.classList.toggle('fa-chevron-up', expanded);
    }

    // 收起时回到“原来的”模式：关闭范围勾选联动（但不改当前勾选状态）
    if (!expanded) {
        const enabledCbox = document.getElementById('globalExportRangeEnabled');
        if (enabledCbox && enabledCbox.checked) {
            enabledCbox.checked = false;
            setGlobalExportRangeEnabled(false);
            updateGlobalExportRangePreviewText();
        }
    }

    // 展开/收起会影响“下方列表显示什么”
    if (wasExpanded !== expanded) {
        globalExportCurrentPage = 1;
        try {
            renderGlobalExportPage();
        } catch (e) {
            // ignore if called before table exists
        }
    }
}

function setGlobalExportRangeEnabled(enabled) {
    // 注意：滑块在“视觉模式/勾选模式”都应保持可操作、视觉不变暗；
    // 这里的“启用”仅表示是否将范围应用到列表勾选
}

function getGlobalExportSeqRangeBounds() {
    if (!syncHistory || syncHistory.length === 0) return { min: 1, max: 1 };

    let min = Infinity;
    let max = -Infinity;
    for (let i = 0; i < syncHistory.length; i++) {
        const record = syncHistory[i];
        const seqNumber = record.seqNumber || (i + 1);
        if (seqNumber < min) min = seqNumber;
        if (seqNumber > max) max = seqNumber;
    }
    if (!Number.isFinite(min) || !Number.isFinite(max)) return { min: 1, max: 1 };
    return { min, max };
}

function updateGlobalExportRangeHighlight() {
    const highlight = document.getElementById('globalExportRangeHighlight');
    const minSlider = document.getElementById('globalExportRangeMin');
    const maxSlider = document.getElementById('globalExportRangeMax');
    if (!highlight || !minSlider || !maxSlider) return;

    const min = parseInt(minSlider.min, 10);
    const max = parseInt(minSlider.max, 10);
    const range = Math.max(1, max - min);

    const a = parseInt(minSlider.value, 10);
    const b = parseInt(maxSlider.value, 10);
    const low = Math.min(a, b);
    const high = Math.max(a, b);

    const leftPercent = ((low - min) / range) * 100;
    const widthPercent = ((high - low) / range) * 100;

    highlight.style.left = `${leftPercent}%`;
    highlight.style.width = `${widthPercent}%`;

    updateGlobalExportRangeBubbles();
}

function updateGlobalExportRangeBubbles() {
    const minSlider = document.getElementById('globalExportRangeMin');
    const maxSlider = document.getElementById('globalExportRangeMax');
    const minBubble = document.getElementById('globalExportRangeMinBubble');
    const maxBubble = document.getElementById('globalExportRangeMaxBubble');
    const container = document.getElementById('globalExportRangeContainer');
    const track = container ? container.querySelector('.range-slider-track') : null;
    const leftLabel = document.getElementById('globalExportRangeLeftLabel');
    const rightLabel = document.getElementById('globalExportRangeRightLabel');
    if (!minSlider || !maxSlider || !minBubble || !maxBubble || !container || !track) return;

    const min = parseInt(minSlider.min, 10);
    const max = parseInt(minSlider.max, 10);
    const range = Math.max(1, max - min);

    const minVal = parseInt(minSlider.value, 10);
    const maxVal = parseInt(maxSlider.value, 10);

    // Inputs are flipped (scaleX(-1)), so visual position is mirrored.
    const minPercent = ((minVal - min) / range) * 100;
    const maxPercent = ((maxVal - min) / range) * 100;

    // Use container pixels instead of getBoundingClientRect() to avoid occasional
    // jitter when the table below rerenders and layout shifts during dragging.
    const insetPx = 10; // keep in sync with #globalExportRangeContainer track/input inset
    const thumbSizePx = 20; // keep in sync with .range-slider-input thumb size
    const thumbHalfPx = thumbSizePx / 2;

    const trackWidthPx = Math.max(1, container.clientWidth - insetPx * 2);
    const effectiveWidthPx = Math.max(0, trackWidthPx - thumbSizePx);

    const minX = insetPx + thumbHalfPx + (1 - (minPercent / 100)) * effectiveWidthPx;
    const maxX = insetPx + thumbHalfPx + (1 - (maxPercent / 100)) * effectiveWidthPx;

    minBubble.style.left = `${minX}px`;
    maxBubble.style.left = `${maxX}px`;
    minBubble.textContent = String(minVal);
    maxBubble.textContent = String(maxVal);

    // If two thumbs overlap, don't draw both numbers on top of each other.
    const overlapThresholdPx = 14;
    const overlap = Math.abs(minX - maxX) <= overlapThresholdPx;
    if (overlap) {
        if (globalExportActiveRangeThumb === 'min') {
            minBubble.style.opacity = '1';
            minBubble.style.zIndex = '7';
            maxBubble.style.opacity = '0';
            maxBubble.style.zIndex = '6';
        } else {
            maxBubble.style.opacity = '1';
            maxBubble.style.zIndex = '7';
            minBubble.style.opacity = '0';
            minBubble.style.zIndex = '6';
        }
    } else {
        minBubble.style.opacity = '1';
        maxBubble.style.opacity = '1';
        minBubble.style.zIndex = '6';
        maxBubble.style.zIndex = '6';
    }

    // When a thumb reaches the end, let it cover the end label (avoid visual clutter).
    // If either thumb is close to an edge, hide that edge label.
    const edgeThresholdPx = thumbHalfPx + 2;
    const leftEdgeX = insetPx;
    const rightEdgeX = insetPx + trackWidthPx;
    const nearLeftEdge = Math.min(Math.abs(minX - leftEdgeX), Math.abs(maxX - leftEdgeX)) <= edgeThresholdPx;
    const nearRightEdge = Math.min(Math.abs(minX - rightEdgeX), Math.abs(maxX - rightEdgeX)) <= edgeThresholdPx;

    if (leftLabel) leftLabel.style.opacity = nearLeftEdge ? '0' : '1';
    if (rightLabel) rightLabel.style.opacity = nearRightEdge ? '0' : '1';
}

function updateGlobalExportRangePreviewText() {
    const previewEl = document.getElementById('globalExportRangePreviewText');
    const enabledCbox = document.getElementById('globalExportRangeEnabled');
    const minSlider = document.getElementById('globalExportRangeMin');
    const maxSlider = document.getElementById('globalExportRangeMax');
    if (!previewEl || !enabledCbox || !minSlider || !maxSlider) return;

    const a = parseInt(minSlider.value, 10);
    const b = parseInt(maxSlider.value, 10);
    const low = Math.min(a, b);
    const high = Math.max(a, b);
    const seqRangeStr = low === high ? String(low) : `${low}-${high}`;
    const countInRange = countGlobalExportRecordsInSeqRange(low, high);

    updateGlobalExportRangeBubbles();

    if (!enabledCbox.checked) {
        // 视觉查看模式：仅影响下方列表显示范围，不改勾选
        previewEl.textContent = currentLang === 'en'
            ? `Showing No. ${seqRangeStr} (${countInRange})`
            : `显示：序号 ${seqRangeStr}（${countInRange} 条）`;
        return;
    }

    // 勾选模式：影响下方列表显示，并把范围应用到勾选
    previewEl.textContent = currentLang === 'en'
        ? `Selecting No. ${seqRangeStr} (${countInRange})`
        : `勾选：序号 ${seqRangeStr}（${countInRange} 条）`;
}

function countGlobalExportRecordsInSeqRange(minSeq, maxSeq) {
    if (!syncHistory || syncHistory.length === 0) return 0;
    let count = 0;
    for (let i = 0; i < syncHistory.length; i++) {
        const record = syncHistory[i];
        const seqNumber = globalExportSeqNumberByTime.get(String(record.time)) || record.seqNumber || (i + 1);
        if (seqNumber >= minSeq && seqNumber <= maxSeq) count++;
    }
    return count;
}

function applyGlobalExportSelectionByCurrentThumbRange() {
    const minSlider = document.getElementById('globalExportRangeMin');
    const maxSlider = document.getElementById('globalExportRangeMax');
    if (!minSlider || !maxSlider) return;

    const a = parseInt(minSlider.value, 10);
    const b = parseInt(maxSlider.value, 10);
    const low = Math.min(a, b);
    const high = Math.max(a, b);

    applyGlobalExportSelectionBySeqRange(low, high);
}

function applyGlobalExportSelectionBySeqRange(minSeq, maxSeq) {
    if (!syncHistory || syncHistory.length === 0) return;

    globalExportRangeApplyingSelection = true;
    for (let i = 0; i < syncHistory.length; i++) {
        const record = syncHistory[i];
        const seqNumber = globalExportSeqNumberByTime.get(String(record.time)) || record.seqNumber || (i + 1);
        globalExportSelectedState[record.time] = (seqNumber >= minSeq && seqNumber <= maxSeq);
    }

    document.querySelectorAll('.global-export-row-checkbox').forEach(cb => {
        const time = cb.dataset.time;
        cb.checked = globalExportSelectedState[time] === true;
    });

    updateGlobalExportStatus();
    updateGlobalExportRangeHighlight();
    updateGlobalExportRangePreviewText();
    globalExportRangeApplyingSelection = false;
}

function setupGlobalExportRangeUiForOpen({ source = 'global', minSeq = null, maxSeq = null, autoEnable = false, autoExpand = false } = {}) {
    const enabledCbox = document.getElementById('globalExportRangeEnabled');
    const minSlider = document.getElementById('globalExportRangeMin');
    const maxSlider = document.getElementById('globalExportRangeMax');
    const leftLabel = document.getElementById('globalExportRangeLeftLabel');
    const rightLabel = document.getElementById('globalExportRangeRightLabel');

    if (!enabledCbox || !minSlider || !maxSlider) return;

    globalExportRangeBoundsCache = getGlobalExportSeqRangeBounds();
    const bounds = globalExportRangeBoundsCache;

    minSlider.min = String(bounds.min);
    minSlider.max = String(bounds.max);
    maxSlider.min = String(bounds.min);
    maxSlider.max = String(bounds.max);

    const nextMinSeq = minSeq == null ? bounds.min : minSeq;
    const nextMaxSeq = maxSeq == null ? bounds.max : maxSeq;

    minSlider.value = String(nextMinSeq);
    maxSlider.value = String(nextMaxSeq);

    if (leftLabel) leftLabel.textContent = String(bounds.max);
    if (rightLabel) rightLabel.textContent = String(bounds.min);

    setGlobalExportRangePanelExpanded(Boolean(autoExpand));
    enabledCbox.checked = Boolean(autoEnable);
    setGlobalExportRangeEnabled(Boolean(autoEnable));

    updateGlobalExportRangeHighlight();
    updateGlobalExportRangePreviewText();
    updateGlobalExportRangeBubbles();

    if (source === 'delete' && autoEnable) {
        applyGlobalExportSelectionBySeqRange(parseInt(minSlider.value, 10), parseInt(maxSlider.value, 10));
    }
}

function syncGlobalExportRangeUiAfterListSelectionChange() {
    const enabledCbox = document.getElementById('globalExportRangeEnabled');
    if (!enabledCbox || !enabledCbox.checked) return;
    if (globalExportRangeApplyingSelection) return;

    // 如果用户手动改了列表勾选，则退出“范围应用”模式，避免滑块显示与实际勾选不一致
    enabledCbox.checked = false;
    setGlobalExportRangeEnabled(false);
    updateGlobalExportRangePreviewText();
}

function showGlobalExportModal() {
    const modal = document.getElementById('globalExportModal');
    const tbody = document.getElementById('globalExportTableBody');

    if (!modal || !tbody) return;

    // 重置分页状态
    globalExportCurrentPage = 1;
    globalExportSelectedState = {};

    if (!syncHistory || syncHistory.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="padding: 30px; text-align: center; color: var(--text-tertiary);">暂无备份记录</td></tr>';
        document.getElementById('globalExportPagination').style.display = 'none';
        modal.classList.add('show');
        return;
    }

    // 初始化所有记录为选中状态
    syncHistory.forEach(record => {
        globalExportSelectedState[record.time] = true;
    });

    // 建立序号映射（与删除弹窗口径一致：syncHistory 顺序的 index+1；newer 具有更大序号）
    globalExportSeqNumberByTime = new Map();
    syncHistory.forEach((record, index) => {
        const seqNumber = record.seqNumber || (index + 1);
        globalExportSeqNumberByTime.set(String(record.time), seqNumber);
    });

    // 渲染当前页
    renderGlobalExportPage();

    // 绑定分页按钮事件
    const prevBtn = document.getElementById('globalExportPrevPage');
    const nextBtn = document.getElementById('globalExportNextPage');
    const pageInput = document.getElementById('globalExportPageInput');

    // 移除旧事件（防止重复绑定）
    prevBtn.replaceWith(prevBtn.cloneNode(true));
    nextBtn.replaceWith(nextBtn.cloneNode(true));
    pageInput.replaceWith(pageInput.cloneNode(true));

    document.getElementById('globalExportPrevPage').addEventListener('click', () => {
        if (globalExportCurrentPage > 1) {
            globalExportCurrentPage--;
            renderGlobalExportPage();
        }
    });

    document.getElementById('globalExportNextPage').addEventListener('click', () => {
        const totalPages = Math.ceil(syncHistory.length / GLOBAL_EXPORT_PAGE_SIZE);
        if (globalExportCurrentPage < totalPages) {
            globalExportCurrentPage++;
            renderGlobalExportPage();
        }
    });

    // 页码输入框跳转
    const newPageInput = document.getElementById('globalExportPageInput');
    newPageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const totalPages = Math.ceil(syncHistory.length / GLOBAL_EXPORT_PAGE_SIZE);
            let targetPage = parseInt(newPageInput.value, 10);
            if (isNaN(targetPage) || targetPage < 1) targetPage = 1;
            if (targetPage > totalPages) targetPage = totalPages;
            globalExportCurrentPage = targetPage;
            renderGlobalExportPage();
        }
    });
    newPageInput.addEventListener('blur', () => {
        const totalPages = Math.ceil(syncHistory.length / GLOBAL_EXPORT_PAGE_SIZE);
        let targetPage = parseInt(newPageInput.value, 10);
        if (isNaN(targetPage) || targetPage < 1) targetPage = 1;
        if (targetPage > totalPages) targetPage = totalPages;
        if (targetPage !== globalExportCurrentPage) {
            globalExportCurrentPage = targetPage;
            renderGlobalExportPage();
        } else {
            // 只更新输入框显示（防止显示非法值）
            newPageInput.value = globalExportCurrentPage;
        }
    });

    setupGlobalExportRangeUiForOpen({ source: 'global', autoEnable: false, autoExpand: false });
    updateGlobalExportStatus();
    modal.classList.add('show');
}

function renderGlobalExportPage() {
    const tbody = document.getElementById('globalExportTableBody');
    const pagination = document.getElementById('globalExportPagination');
    const prevBtn = document.getElementById('globalExportPrevPage');
    const nextBtn = document.getElementById('globalExportNextPage');
    const pageInput = document.getElementById('globalExportPageInput');
    const totalPagesEl = document.getElementById('globalExportTotalPages');

    if (!tbody) return;

    tbody.innerHTML = '';

    const reversedHistory = [...syncHistory].reverse();
    let visibleHistory = reversedHistory;

    // 视觉查看模式：如果范围面板展开，则下方列表只显示该范围内的记录
    if (isGlobalExportRangePanelExpanded()) {
        const minSlider = document.getElementById('globalExportRangeMin');
        const maxSlider = document.getElementById('globalExportRangeMax');
        if (minSlider && maxSlider) {
            const a = parseInt(minSlider.value, 10);
            const b = parseInt(maxSlider.value, 10);
            const minSeq = Math.min(a, b);
            const maxSeq = Math.max(a, b);
            visibleHistory = reversedHistory.filter((record) => {
                const seqNumber = globalExportSeqNumberByTime.get(String(record.time));
                if (!Number.isFinite(seqNumber)) return true;
                return seqNumber >= minSeq && seqNumber <= maxSeq;
            });
        }
    }

    if (visibleHistory.length === 0) {
        const colspan = 6;
        tbody.innerHTML = `<tr><td colspan="${colspan}" style="padding: 20px; text-align: center; color: var(--text-tertiary);">${currentLang === 'zh_CN' ? '该范围内暂无记录' : 'No records in this range'}</td></tr>`;
        if (pagination) pagination.style.display = 'none';
        return;
    }

    const totalPages = Math.ceil(visibleHistory.length / GLOBAL_EXPORT_PAGE_SIZE);
    const startIndex = (globalExportCurrentPage - 1) * GLOBAL_EXPORT_PAGE_SIZE;
    const endIndex = Math.min(startIndex + GLOBAL_EXPORT_PAGE_SIZE, visibleHistory.length);
    const pageRecords = visibleHistory.slice(startIndex, endIndex);

    // 显示/隐藏分页控件
    if (totalPages <= 1) {
        pagination.style.display = 'none';
    } else {
        pagination.style.display = 'flex';
        pageInput.value = globalExportCurrentPage;
        pageInput.max = totalPages;
        totalPagesEl.textContent = totalPages;
        prevBtn.disabled = globalExportCurrentPage <= 1;
        nextBtn.disabled = globalExportCurrentPage >= totalPages;
    }

    pageRecords.forEach((record, idx) => {
        const tr = document.createElement('tr');

        const timeStr = formatTime(record.time);
        const note = record.note || '';
        const noteDisplay = note ? escapeHtml(note) : `<span style="color:var(--text-tertiary); font-style: italic;">${currentLang === 'zh_CN' ? '无备注' : 'No Note'}</span>`;
        const fingerprint = record.fingerprint || '-';
        const seqNumber = globalExportSeqNumberByTime.get(String(record.time)) || record.seqNumber || '';

        const savedMode = getRecordDetailMode(record.time);
        const defaultMode = historyDetailMode || 'simple';
        const mode = savedMode || defaultMode;

        const isChecked = globalExportSelectedState[record.time] !== false;

        tr.innerHTML = `
            <td style="text-align: center;">
                <input type="checkbox" class="global-export-row-checkbox" data-time="${record.time}" ${isChecked ? 'checked' : ''}>
            </td>
            <td style="text-align: center; font-family: monospace; color: var(--text-secondary);">${seqNumber}</td>
            <td>
                <div style="max-width: 90px; overflow: hidden; text-overflow: ellipsis; white-space: normal; line-height: 1.4;">${noteDisplay}</div>
            </td>
            <td style="font-family: monospace; color: var(--text-secondary);">${fingerprint}</td>
            <td>
            <div class="global-export-toggle-group" data-time="${record.time}">
                <button class="global-export-toggle-btn ${mode === 'simple' ? 'active' : ''}" data-value="simple">${currentLang === 'zh_CN' ? '简略' : 'Simple'}</button>
                <button class="global-export-toggle-btn ${mode === 'detailed' ? 'active' : ''}" data-value="detailed">${currentLang === 'zh_CN' ? '详细' : 'Detailed'}</button>
            </div>
            </td>
            <td>
                <div style="font-weight: 500; white-space: nowrap;">${timeStr}</div>
            </td>
        `;

        // 添加行点击交互：点击行任意位置（除了按钮和复选框）触发选中
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', (e) => {
            // 如果点击的是按钮或复选框本身，则忽略
            if (e.target.closest('.global-export-toggle-btn') || e.target.closest('.global-export-row-checkbox')) return;

            // 切换选中状态
            const checkbox = tr.querySelector('.global-export-row-checkbox');
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                // 手动触发 change 事件或者直接更新状态
                // 这里我们直接更新状态并由 change 事件回调处理（如果触发的话），或者直接复制 change 逻辑
                // 为了简单，我们直接更新状态
                globalExportSelectedState[record.time] = checkbox.checked;
                updateGlobalExportStatus();
                syncGlobalExportRangeUiAfterListSelectionChange();
            }
        });

        tbody.appendChild(tr);
    });

    // 绑定行复选框事件
    tbody.querySelectorAll('.global-export-row-checkbox').forEach(cb => {
        cb.addEventListener('change', (e) => {
            const time = e.target.dataset.time;
            globalExportSelectedState[time] = e.target.checked;
            updateGlobalExportStatus();
            syncGlobalExportRangeUiAfterListSelectionChange();
        });
    });

    // 绑定视图模式切换事件
    tbody.querySelectorAll('.global-export-toggle-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const button = e.currentTarget;
            if (button.classList.contains('active')) return;

            const container = button.closest('.global-export-toggle-group');
            const time = container.dataset.time;
            const newMode = button.dataset.value;

            // 更新UI
            container.querySelectorAll('.global-export-toggle-btn').forEach(b => b.classList.remove('active'));
            button.classList.add('active');

            // 更新数据
            setRecordDetailMode(time, newMode);
        });
    });

    // 更新全选框状态
    updateSelectAllCheckboxState();

    // After rerendering the table, layout may shift slightly; keep bubbles stable.
    if (isGlobalExportRangePanelExpanded()) {
        scheduleGlobalExportRangeUiUpdate();
    }
}

function updateSelectAllCheckboxState() {
    const selectAllCheckbox = document.getElementById('globalExportSelectAll');
    if (!selectAllCheckbox) return;

    const allSelected = Object.values(globalExportSelectedState).every(v => v === true);
    const noneSelected = Object.values(globalExportSelectedState).every(v => v === false);

    selectAllCheckbox.checked = allSelected;
    selectAllCheckbox.indeterminate = !allSelected && !noneSelected;
}

async function startGlobalExport() {
    // 从 globalExportSelectedState 获取选中的记录
    const selectedTimes = Object.entries(globalExportSelectedState)
        .filter(([_, selected]) => selected)
        .map(([time, _]) => time);

    if (selectedTimes.length === 0) return;

    // 导出顺序：倒序（新的在前）
    const selectedTimesSorted = selectedTimes
        .slice()
        .sort((a, b) => Number(b) - Number(a));

    const seqMap = buildSequenceMapFromHistory(syncHistory);
    const selectedSeqNumbers = selectedTimes
        .map(t => seqMap.get(String(t)))
        .filter(n => Number.isFinite(n) && n > 0)
        .sort((a, b) => a - b);
    const rangeText = formatSelectedSequenceRanges(selectedSeqNumbers, currentLang);
    const selectionLabel = (() => {
        if (currentLang === 'zh_CN') {
            return rangeText
                ? `【序号${rangeText}-共${selectedTimes.length}个】`
                : `【共${selectedTimes.length}个】`;
        }
        return rangeText
            ? `[No${rangeText}-${selectedTimes.length}items]`
            : `[${selectedTimes.length}items]`;
    })();
    const selectionPrefix = sanitizeFilenameSegment(selectionLabel);
    const seqWidth = String(Math.max(syncHistory?.length || 1, 1)).length;

    const confirmBtn = document.getElementById('globalExportConfirmBtn');
    const originalText = confirmBtn.innerHTML;
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${currentLang === 'zh_CN' ? '正在处理...' : 'Processing...'}`;

    try {
        const formatHtml = document.getElementById('globalExportFormatHtml').checked;
        const formatJson = document.getElementById('globalExportFormatJson').checked;
        const formatMd = document.getElementById('globalExportFormatMd') ? document.getElementById('globalExportFormatMd').checked : false;

        const packMode = document.querySelector('input[name="globalExportPackMode"]:checked')?.value || 'zip';

        if (!formatHtml && !formatJson && !formatMd) {
            showToast(currentLang === 'zh_CN' ? '没有选择导出格式' : 'No export format selected');
            return;
        }

        let processedCount = 0;
        const totalCount = selectedTimesSorted.length;

        // ---------------------------------------------------------------------
        // 模式 A: ZIP 归档 (每个备份独立文件夹)
        // ---------------------------------------------------------------------
        if (packMode === 'zip') {
            const files = [];
            const timestamp = formatTimeForFilename(); // 导出时间（本地时间）
            const zipPrefix = currentLang === 'zh_CN' ? '全局备份归档' : 'Global_Backup_Archive';
            const zipRootFolder = selectionPrefix ? `${selectionPrefix}_${zipPrefix}_${timestamp}` : `${zipPrefix}_${timestamp}`;
            for (const recordTime of selectedTimesSorted) {
                // 更新进度
                processedCount++;
                confirmBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${currentLang === 'zh_CN' ? '正在处理' : 'Processing'} (${processedCount}/${totalCount})`;
                // 让UI有时间渲染
                await new Promise(r => requestAnimationFrame(r));

                const record = syncHistory.find(r => String(r.time) === String(recordTime));
                if (!record) continue;

                // 获取保存的视图模式
                const savedMode = getRecordDetailMode(record.time);
                const defaultMode = historyDetailMode || 'simple';
                const mode = savedMode || defaultMode;

                const dateStr = formatTimeForFilename(record.time); // 备份时间（本地时间）
                // Sanitize note for filename use
                const cleanNote = record.note ? record.note.replace(/[\\/:*?"<>|]/g, '_').replace(/\s+/g, '_') : '';
                const fingerprint = record.fingerprint ? `_${record.fingerprint.substring(0, 7)}` : '';
                const modeStr = mode === 'simple' ? (currentLang === 'zh_CN' ? '_简略' : '_Simple') : (currentLang === 'zh_CN' ? '_详细' : '_Detailed');
                const defaultPrefix = currentLang === 'zh_CN' ? '书签' : 'bookmark';

                const baseName = cleanNote
                    ? `${cleanNote}${fingerprint}${modeStr}_${dateStr}`
                    : `${defaultPrefix}${fingerprint}${modeStr}_${dateStr}`;

                const seqNumber = seqMap.get(String(record.time));
                const seqStr = Number.isFinite(seqNumber) ? String(seqNumber).padStart(seqWidth, '0') : '00';
                const fileBasePath = `${zipRootFolder}/${seqStr}_${baseName}`;

                if (formatHtml) {
                    try {
                        const htmlContent = await generateExportHtmlContentForGlobal(record, mode);
                        files.push({
                            name: `${fileBasePath}.html`,
                            data: new TextEncoder().encode(htmlContent)
                        });
                    } catch (err) {
                        console.error('HTML Gen Error', err);
                    }
                }

                if (formatJson) {
                    try {
                        const jsonContentObj = await generateExportJsonContentForGlobal(record, mode);
                        files.push({
                            name: `${fileBasePath}.json`,
                            data: new TextEncoder().encode(JSON.stringify(jsonContentObj, null, 2))
                        });
                    } catch (err) {
                        console.error('JSON Gen Error', err);
                    }
                }

                // ZIP mode does not explicitly support MD as per requirements (MD enforces Merge), 
                // but if we wanted to support it, we'd add it here.
            }

            if (files.length === 0) {
                // 如果只选了MD但强行进了Zip模式（不应该发生），则报错
                throw new Error('No files generated (MD format requires Merge mode)');
            }

            // 确保 ZIP 内的文件名排序为倒序（大的在前）
            files.sort((a, b) => String(b.name).localeCompare(String(a.name)));

            const zipBlob = __zipStore(files);
            const zipUrl = URL.createObjectURL(zipBlob);
            const zipName = selectionPrefix
                ? `${selectionPrefix}_${zipPrefix}_${timestamp}.zip`
                : `${zipPrefix}_${timestamp}.zip`;

            downloadBlob(zipUrl, zipName);
        }
        // ---------------------------------------------------------------------
        // 模式 B: 单一文件合并 (Merged Single File)
        // ---------------------------------------------------------------------
        else if (packMode === 'merge') {
            const mergedRoot = {
                title: currentLang === 'zh_CN' ? '全局备份合并历史' : 'Global Merged Backup History',
                children: []
            };

            const mergedItems = [];
            for (const recordTime of selectedTimesSorted) {
                processedCount++;
                confirmBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${currentLang === 'zh_CN' ? '正在合并' : 'Merging'} (${processedCount}/${totalCount})`;
                await new Promise(r => requestAnimationFrame(r));

                const record = syncHistory.find(r => String(r.time) === String(recordTime));
                if (!record) continue;

                // 获取保存的视图模式
                const savedMode = getRecordDetailMode(record.time);
                const defaultMode = historyDetailMode || 'simple';
                const mode = savedMode || defaultMode;

                // 1. 获取该记录的处理后树（带 [+] [-] 前缀）
                const processedTree = await getProcessedTreeForRecord(record, mode);

                // 2. 创建容器文件夹
                const timeStr = formatTime(record.time);
                // 改为 Note + Hash + Mode + Time 格式
                const fingerprint = record.fingerprint ? ` [${record.fingerprint.substring(0, 7)}]` : '';
                const titlePrefix = record.note ? record.note : (currentLang === 'zh_CN' ? '备份' : 'Backup');
                const modeLabel = mode === 'simple' ? (currentLang === 'zh_CN' ? '简略' : 'Simple') : (currentLang === 'zh_CN' ? '详细' : 'Detailed');

                const seqNumber = seqMap.get(String(record.time));
                const seqStr = Number.isFinite(seqNumber) ? String(seqNumber).padStart(seqWidth, '0') : '00';
                const containerTitle = `${seqStr} ${titlePrefix}${fingerprint} (${modeLabel}) (${timeStr})`;
                const containerFolder = {
                    title: containerTitle,
                    children: processedTree.children || [] // processedTree 本身是 root，我们取其 children
                };

                mergedItems.push({ seq: Number.isFinite(seqNumber) ? seqNumber : -1, folder: containerFolder });
            }

            // 3. 添加到合并根（倒序：大的在前）
            mergedItems
                .sort((a, b) => b.seq - a.seq)
                .forEach(item => mergedRoot.children.push(item.folder));

            // 4. 生成合并后的文件
            if (formatHtml) {
                const htmlContent = generateBookmarkExportHTMLFromTree(mergedRoot);
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const timestamp = formatTimeForFilename();
                const mergedPrefix = currentLang === 'zh_CN' ? '全局合并历史' : 'Global_Merged_History';
                const namePrefix = selectionPrefix ? `${selectionPrefix}_${mergedPrefix}` : mergedPrefix;
                downloadBlob(url, `${namePrefix}_${timestamp}.html`);
            }

            if (formatJson) {
                const jsonContent = JSON.stringify(mergedRoot, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const timestamp = formatTimeForFilename();
                const mergedPrefix = currentLang === 'zh_CN' ? '全局合并历史' : 'Global_Merged_History';
                const namePrefix = selectionPrefix ? `${selectionPrefix}_${mergedPrefix}` : mergedPrefix;
                downloadBlob(url, `${namePrefix}_${timestamp}.json`);
            }

            if (formatMd) {
                // 使用 generateHistorySummaryMD 生成摘要表格 (替代原来的内容导出)
                // 注意：这里我们只生成一个包含所有选定记录摘要的文件
                // 我们不需要遍历记录来生成内容，而是直接传入 selectedTimes（需确保 generateHistorySummaryMD 接受此参数）

                const mdContent = await generateHistorySummaryMD(selectedTimesSorted);
                const blob = new Blob([mdContent], { type: 'text/markdown;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const timestamp = formatTimeForFilename();
                const prefix = currentLang === 'zh_CN' ? '书签备份历史记录' : 'Bookmark_Backup_History';
                const namePrefix = selectionPrefix ? `${selectionPrefix}_${prefix}` : prefix;
                downloadBlob(url, `${namePrefix}_${timestamp}.md`);
            }
        }

        closeGlobalExportModal();
        showToast(currentLang === 'zh_CN' ? '全局导出成功' : 'Global export successful');

    } catch (e) {
        console.error('Global Export Failed', e);
        showToast(currentLang === 'zh_CN' ? '导出失败' : 'Export failed');
    } finally {
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = originalText;
    }
}

function downloadBlob(url, filename) {
    // 同步导出到云端（云端1 WebDAV + 云端2 GitHub Repo）
    try {
        if (chrome && chrome.runtime && typeof chrome.runtime.sendMessage === 'function') {
            const lower = String(filename || '').toLowerCase();
            const ext = lower.includes('.') ? lower.slice(lower.lastIndexOf('.')) : '';
            const contentTypeMap = {
                '.html': 'text/html;charset=utf-8',
                '.json': 'application/json;charset=utf-8',
                '.md': 'text/markdown;charset=utf-8',
                '.txt': 'text/plain;charset=utf-8',
                '.zip': 'application/zip'
            };
            const contentType = contentTypeMap[ext] || 'application/octet-stream';
            const isText = ext === '.html' || ext === '.json' || ext === '.md' || ext === '.txt';

            (async () => {
                try {
                    const res = await fetch(url);
                    if (!res.ok) return;

                    if (isText) {
                        const text = await res.text();
                        chrome.runtime.sendMessage({
                            action: 'exportFileToClouds',
                            folderKey: 'history',
                            lang: currentLang,
                            fileName: filename,
                            content: text,
                            contentType
                        }, () => { });
                        return;
                    }

                    const buf = await res.arrayBuffer();
                    // Chrome sendMessage 不支持直接传递 ArrayBuffer，需转换为 Base64
                    const bytes = new Uint8Array(buf);
                    const chunkSize = 0x2000;
                    let binary = '';
                    for (let i = 0; i < bytes.length; i += chunkSize) {
                        const chunk = bytes.subarray(i, i + chunkSize);
                        binary += String.fromCharCode(...chunk);
                    }
                    const base64 = btoa(binary);
                    chrome.runtime.sendMessage({
                        action: 'exportFileToClouds',
                        folderKey: 'history',
                        lang: currentLang,
                        fileName: filename,
                        contentBase64Binary: base64,
                        contentType
                    }, () => { });
                } catch (_) { }
            })();
        }
    } catch (_) { }

    // 使用统一的导出文件夹结构（根据语言动态选择）
    const exportPath = `${getHistoryExportRootFolder()}/${getHistoryExportFolder()}`;

    // 尝试使用 chrome.downloads API 以支持子目录
    if (chrome && chrome.downloads && typeof chrome.downloads.download === 'function') {
        chrome.downloads.download({
            url: url,
            filename: `${exportPath}/${filename}`,
            saveAs: false,
            conflictAction: 'uniquify'
        }, (downloadId) => {
            if (chrome.runtime.lastError) {
                console.warn('chrome.downloads API failed, falling back to <a> tag:', chrome.runtime.lastError);
                // 降级方案
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
            setTimeout(() => URL.revokeObjectURL(url), 10000);
        });
    } else {
        // 降级方案
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 10000);
    }
}

// 辅助：获取 JSON 内容对象（复用 generateHistoryChangesJSON 的逻辑但只返回对象）
async function generateExportJsonContentForGlobal(record, mode) {
    // 逻辑同 generateExportHtmlContentForGlobal，准备数据
    const { treeToExport, changeMap } = await prepareDataForExport(record);

    // 在详细模式下，尝试获取存储的展开状态（WYSIWYG）
    let expandedIds = null;
    if (mode === 'detailed' && hasRecordExpandedState(record.time)) {
        expandedIds = getRecordExpandedState(record.time);
    }

    return await generateHistoryChangesJSON(treeToExport, changeMap, mode, expandedIds);
}

// 辅助：准备导出数据 (Tree + ChangeMap)
async function prepareDataForExport(record) {
    let changeMap = new Map();
    const recordIndex = syncHistory.findIndex(r => r.time === record.time);
    let previousRecord = null;

    if (recordIndex > 0) {
        for (let i = recordIndex - 1; i >= 0; i--) {
            if (syncHistory[i].status === 'success' && (syncHistory[i].hasData || syncHistory[i].bookmarkTree)) {
                previousRecord = syncHistory[i];
                break;
            }
        }
    }

    // Lazy load current tree
    let treeToExport = record.bookmarkTree;
    if (!treeToExport && (record.hasData || record.status === 'success')) {
        treeToExport = await getBackupDataLazy(record.time);
    }

    // Lazy load previous tree
    let prevTree = null;
    if (previousRecord) {
        prevTree = previousRecord.bookmarkTree;
        if (!prevTree && (previousRecord.hasData || previousRecord.status === 'success')) {
            prevTree = await getBackupDataLazy(previousRecord.time);
        }
    }

    if (prevTree) {
        if (treeToExport) {
            changeMap = await detectTreeChangesFast(prevTree, treeToExport, {
                useGlobalExplicitMovedIds: false,
                explicitMovedIdSet: (record.bookmarkStats && Array.isArray(record.bookmarkStats.explicitMovedIds))
                    ? record.bookmarkStats.explicitMovedIds
                    : null
            });

            // 重建删除节点
            let hasDeleted = false;
            for (const [, change] of changeMap) {
                if (change.type && change.type.includes('deleted')) {
                    hasDeleted = true;
                    break;
                }
            }
            if (hasDeleted) {
                try {
                    treeToExport = rebuildTreeWithDeleted(prevTree, treeToExport, changeMap);
                } catch (error) {
                    // Fallback to pure current tree if rebuild fails
                    if (!record.bookmarkTree) {
                        // If we lazy loaded, we have it in treeToExport variable
                    } else {
                        treeToExport = record.bookmarkTree;
                    }
                }
            }
        }
    } else if (record.isFirstBackup && treeToExport) {
        const allNodes = flattenBookmarkTree(treeToExport);
        allNodes.forEach(item => {
            if (item.id) changeMap.set(item.id, { type: 'added' });
        });
    }

    return { treeToExport, changeMap };
}


// 重构：原有的 HTML 生成函数调用
async function generateExportHtmlContentForGlobal(record, mode) {
    const { treeToExport, changeMap } = await prepareDataForExport(record);

    // 在详细模式下，尝试获取存储的展开状态（WYSIWYG）
    let expandedIds = null;
    if (mode === 'detailed' && hasRecordExpandedState(record.time)) {
        expandedIds = getRecordExpandedState(record.time);
    }

    return await generateHistoryChangesHTML(treeToExport, changeMap, mode, expandedIds);
}

// 辅助：获取处理过的树（带前缀，已过滤）供合并使用
async function getProcessedTreeForRecord(record, mode) {
    const { treeToExport, changeMap } = await prepareDataForExport(record);

    // 在详细模式下，尝试获取存储的展开状态（WYSIWYG）
    let expandedIds = null;
    if (mode === 'detailed' && hasRecordExpandedState(record.time)) {
        expandedIds = getRecordExpandedState(record.time);
    }

    // 我们利用 generateHistoryChangesJSON 的 extractTree 逻辑来获取一个纯净的树对象
    // 但 generateHistoryChangesJSON 返回的是 { title:..., children:..., _exportInfo:... }
    // 我们只需要它的 children 部分，且它的 title 已经处理过前缀了。

    const jsonObj = await generateHistoryChangesJSON(treeToExport, changeMap, mode, expandedIds);

    // generateHistoryChangesJSON 返回结构：
    // { title: '...', children: [Legend, ...ActualTree], _exportInfo: ... }

    // 我们不需要 Legend 文件夹 (LegendFolder 是第一个 child)
    // 也不需要 _exportInfo
    // 我们只需要 ActualTree 部分

    const actualChildren = jsonObj.children ? jsonObj.children.filter(child => child.title && !child.title.startsWith('📋') && !child.title.startsWith('Log')) : [];

    // 过滤掉 Legend 之后就是我们的树了。
    // 但是 generateHistoryChangesJSON 里的 extractTree 会返回兼容 Chrome API 的结构 { title, url, children }
    // 这正是我们需要的结构，以便再次喂给 generateHistoryChangesHTML

    return {
        children: actualChildren
    };
}

// 辅助：生成 Markdown 内容 (Tree -> MD)
async function generateHistoryChangesMD(treeRoot, changeMap = new Map(), mode = 'simple') {
    let mdContent = '';

    // 递归函数生成 MD
    function traverse(node, depth) {
        // 跳过特定文件夹
        if (node.title && (node.title.startsWith('📋') || node.title.startsWith('Log'))) {
            return;
        }

        if (node.children) {
            // Folder
            if (depth === 0) {
                // Root level
                if (node.title) mdContent += `# ${node.title}\n\n`;
            } else if (depth === 1) {
                // Level 1: Backup Containers (in merged mode)
                if (node.title) mdContent += `## ${node.title}\n\n`;
            } else {
                // Sub-folders: Nested list item
                // Adjust indent: depth 2 -> 0 spaces (top level list under header)
                const indentLevel = Math.max(0, depth - 2);
                const indent = '  '.repeat(indentLevel);
                const title = node.title || 'Untitled Folder';
                mdContent += `${indent}- **${title}**\n`;
            }

            node.children.forEach(child => traverse(child, depth + 1));
        } else {
            // Bookmark
            const indentLevel = Math.max(0, depth - 2);
            const indent = '  '.repeat(indentLevel);

            // Standard: - [Title](URL)
            // Title check
            const title = node.title || node.url || 'Untitled';
            const url = node.url || '';

            // Escape brackets in title to avoid breaking MD links?
            // Simple replace [ ] with ( ) or just escape.
            const safeTitle = title.replace(/\[/g, '(').replace(/\]/g, ')');

            mdContent += `${indent}- [${safeTitle}](${url})\n`;
        }
    }

    traverse(treeRoot, 0);
    return mdContent;
}

// 辅助：生成 Markdown 摘要表格 (逻辑移植自 popup.js)
async function generateHistorySummaryMD(selectedTimes) {
    let mdContent = '';
    const lang = currentLang; // 获取当前语言
    const naText = lang === 'zh_CN' ? '无' : 'N/A';

    // 1. 获取选中的记录并按时间排序 (新的在前)
    // selectedTimes 是时间戳字符串数组，syncHistory 是记录数组
    const selectedRecords = syncHistory.filter(r => selectedTimes.includes(String(r.time)))
        .sort((a, b) => new Date(b.time) - new Date(a.time));
    const seqMap = buildSequenceMapFromHistory(syncHistory);

    // 2. 准备表头和文本
    const exportTitle = {
        'zh_CN': "# 书签备份历史记录",
        'en': "# Bookmark Backup History"
    };
    const exportNote = {
        'zh_CN': "注意：此文件包含了所选备份历史记录的摘要统计表格。",
        'en': "Note: This file contains a summary table of the selected backup history records."
    };
    const tableHeaders = {
        seq: { 'zh_CN': "序号", 'en': "No." },
        notes: { 'zh_CN': "备注", 'en': "Notes" },
        timestamp: { 'zh_CN': "时间戳", 'en': "Timestamp" },
        bookmarkChange: { 'zh_CN': "书签变化", 'en': "BKM Change" },
        folderChange: { 'zh_CN': "文件夹变化", 'en': "FLD Change" },
        movedCount: { 'zh_CN': "移动", 'en': "Moved" },
        modifiedCount: { 'zh_CN': "修改", 'en': "Modified" },
        location: { 'zh_CN': "位置", 'en': "Location" },
        backupMode: { 'zh_CN': "方式", 'en': "Mode" },
        status: { 'zh_CN': "状态/错误", 'en': "Status/Error" },
        hash: { 'zh_CN': "哈希值", 'en': "Hash" }
    };
    const locationValues = {
        upload: { 'zh_CN': "云端", 'en': "Cloud" }, // 兼容旧记录
        cloud: { 'zh_CN': "云端1, 云端2", 'en': "Cloud 1, Cloud 2" },
        webdav: { 'zh_CN': "云端1(WebDAV)", 'en': "Cloud 1 (WebDAV)" },
        github_repo: { 'zh_CN': "云端2(GitHub仓库)", 'en': "Cloud 2 (GitHub Repo)" },
        gist: { 'zh_CN': "云端2(GitHub仓库)", 'en': "Cloud 2 (GitHub Repo)" }, // legacy
        cloud_local: { 'zh_CN': "云端1, 云端2, 本地", 'en': "Cloud 1, Cloud 2, Local" },
        webdav_local: { 'zh_CN': "云端1(WebDAV), 本地", 'en': "Cloud 1 (WebDAV), Local" },
        github_repo_local: { 'zh_CN': "云端2(GitHub仓库), 本地", 'en': "Cloud 2 (GitHub Repo), Local" },
        gist_local: { 'zh_CN': "云端2(GitHub仓库), 本地", 'en': "Cloud 2 (GitHub Repo), Local" }, // legacy
        local: { 'zh_CN': "本地", 'en': "Local" },
        both: { 'zh_CN': "云端1(WebDAV), 本地", 'en': "Cloud 1 (WebDAV), Local" }, // 兼容旧记录
        none: { 'zh_CN': "无", 'en': "None" }
    };
    const statusValues = {
        success: { 'zh_CN': "成功", 'en': "Success" },
        error: { 'zh_CN': "错误", 'en': "Error" },
        locked: { 'zh_CN': "文件锁定", 'en': "File Locked" },
        noBackupNeeded: { 'zh_CN': "无需备份", 'en': "No backup needed" },
        checkCompleted: { 'zh_CN': "检查完成", 'en': "Check completed" }
    };
    const backupModeValues = {
        auto: { 'zh_CN': "自动", 'en': "Auto" },
        manual: { 'zh_CN': "手动", 'en': "Manual" },
        switch: { 'zh_CN': "切换", 'en': "Switch" },
        migration: { 'zh_CN': "迁移", 'en': "Migration" },
        check: { 'zh_CN': "检查", 'en': "Check" },
        unknown: { 'zh_CN': "未知", 'en': "Unknown" }
    };

    const formatTimeForExport = (date) => {
        return `${date.getFullYear()}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;
    };

    // Header section
    mdContent += exportTitle[lang] + "\n\n";
    mdContent += exportNote[lang] + "\n\n";

    // Table Headers
    mdContent += `| ${tableHeaders.seq[lang]} | ${tableHeaders.notes[lang]} | ${tableHeaders.timestamp[lang]} | ${tableHeaders.bookmarkChange[lang]} | ${tableHeaders.folderChange[lang]} | ${tableHeaders.movedCount[lang]} | ${tableHeaders.modifiedCount[lang]} | ${tableHeaders.location[lang]} | ${tableHeaders.backupMode[lang]} | ${tableHeaders.status[lang]} | ${tableHeaders.hash[lang]} |\n`;
    mdContent += "|---|---|---|---|---|---|---|---|---|---|---|\n";

    // 3. 遍历记录生成表格行
    let previousDateStr = null;

    selectedRecords.forEach(record => {
        const recordDate = new Date(record.time);
        const time = formatTimeForExport(recordDate);

        // 检查日期是否变化（年月日）
        const currentDateStr = `${recordDate.getFullYear()}-${recordDate.getMonth() + 1}-${recordDate.getDate()}`;

        // 如果日期变化，添加分界线
        if (previousDateStr && previousDateStr !== currentDateStr) {
            const formattedPreviousDate = lang === 'en' ?
                `${previousDateStr.split('-')[0]}-${previousDateStr.split('-')[1].padStart(2, '0')}-${previousDateStr.split('-')[2].padStart(2, '0')}` :
                `${previousDateStr.split('-')[0]}年${previousDateStr.split('-')[1]}月${previousDateStr.split('-')[2]}日`;

            // 添加简洁的分界线，并入表格中
            mdContent += `|  | **${formattedPreviousDate}** |  |  |  |  |  |  |  |  |  |\n`;
        }
        previousDateStr = currentDateStr;

        // 获取统计数据逻辑（与 popup.js / 主UI一致：显示 +x/-y 的绝对量；旧数据回退到 diff）
        const bookmarkAdded = typeof record.bookmarkStats?.bookmarkAdded === 'number' ? record.bookmarkStats.bookmarkAdded : 0;
        const bookmarkDeleted = typeof record.bookmarkStats?.bookmarkDeleted === 'number' ? record.bookmarkStats.bookmarkDeleted : 0;
        const folderAdded = typeof record.bookmarkStats?.folderAdded === 'number' ? record.bookmarkStats.folderAdded : 0;
        const folderDeleted = typeof record.bookmarkStats?.folderDeleted === 'number' ? record.bookmarkStats.folderDeleted : 0;

        // 格式化书签变化（+x/-y 或者 0）
        let bookmarkChangeText = '';
        if (bookmarkAdded > 0 && bookmarkDeleted > 0) {
            bookmarkChangeText = `+${bookmarkAdded}/-${bookmarkDeleted}`;
        } else if (bookmarkAdded > 0) {
            bookmarkChangeText = `+${bookmarkAdded}`;
        } else if (bookmarkDeleted > 0) {
            bookmarkChangeText = `-${bookmarkDeleted}`;
        } else {
            // 兼容旧数据：使用 bookmarkDiff
            const diff = record.bookmarkStats?.bookmarkDiff ?? 0;
            bookmarkChangeText = diff > 0 ? `+${diff}` : (diff < 0 ? `${diff}` : '0');
        }

        // 格式化文件夹变化（+x/-y 或者 0）
        let folderChangeText = '';
        if (folderAdded > 0 && folderDeleted > 0) {
            folderChangeText = `+${folderAdded}/-${folderDeleted}`;
        } else if (folderAdded > 0) {
            folderChangeText = `+${folderAdded}`;
        } else if (folderDeleted > 0) {
            folderChangeText = `-${folderDeleted}`;
        } else {
            // 兼容旧数据：使用 folderDiff
            const diff = record.bookmarkStats?.folderDiff ?? 0;
            folderChangeText = diff > 0 ? `+${diff}` : (diff < 0 ? `${diff}` : '0');
        }

        let movedTotal = 0;
        if (typeof record.bookmarkStats?.movedCount === 'number' && record.bookmarkStats.movedCount > 0) {
            movedTotal = record.bookmarkStats.movedCount;
        } else {
            const bookmarkMovedCount = typeof record.bookmarkStats?.bookmarkMoved === 'number'
                ? record.bookmarkStats.bookmarkMoved
                : (record.bookmarkStats?.bookmarkMoved ? 1 : 0);
            const folderMovedCount = typeof record.bookmarkStats?.folderMoved === 'number'
                ? record.bookmarkStats.folderMoved
                : (record.bookmarkStats?.folderMoved ? 1 : 0);
            movedTotal = bookmarkMovedCount + folderMovedCount;
        }
        const movedText = movedTotal > 0 ? String(movedTotal) : '-';

        let modifiedTotal = 0;
        if (typeof record.bookmarkStats?.modifiedCount === 'number' && record.bookmarkStats.modifiedCount > 0) {
            modifiedTotal = record.bookmarkStats.modifiedCount;
        } else {
            const bookmarkModifiedCount = typeof record.bookmarkStats?.bookmarkModified === 'number'
                ? record.bookmarkStats.bookmarkModified
                : (record.bookmarkStats?.bookmarkModified ? 1 : 0);
            const folderModifiedCount = typeof record.bookmarkStats?.folderModified === 'number'
                ? record.bookmarkStats.folderModified
                : (record.bookmarkStats?.folderModified ? 1 : 0);
            modifiedTotal = bookmarkModifiedCount + folderModifiedCount;
        }
        const modifiedText = modifiedTotal > 0 ? String(modifiedTotal) : '-';

        let locationText = naText;
        const recordDirection = (record.direction ?? 'none').toString();
        if (locationValues[recordDirection]) {
            locationText = locationValues[recordDirection][lang];
        } else if (recordDirection === 'download') {
            // 兼容旧记录
            locationText = locationValues.local[lang];
        } else if (recordDirection === 'none') {
            locationText = locationValues.none[lang];
        }

        const normalizeBackupModeKey = (recordType, direction) => {
            const raw = (recordType ?? '').toString().trim();
            const lowered = raw.toLowerCase();

            if (lowered === 'manual' || raw === '（手动）' || raw.includes('手动')) return 'manual';
            if (lowered === 'switch' || lowered === 'auto_switch' || raw === '（切换）' || raw.includes('切换')) return 'switch';
            if (lowered === 'migration' || raw === '（迁移）' || raw.includes('迁移')) return 'migration';
            if (lowered === 'check' || raw.includes('检查')) return 'check';
            // “direction === none” 基本是检查类记录
            if (direction === 'none') return 'check';
            if (lowered === 'auto' || raw === '（自动）' || raw.includes('自动') || !raw) return 'auto';
            return 'unknown';
        };
        const backupModeKey = normalizeBackupModeKey(record.type, record.direction);
        const backupModeText = (backupModeValues[backupModeKey] || backupModeValues.unknown)[lang];

        let statusText = naText;
        if (record.status === 'success') {
            if (record.direction === 'none') {
                statusText = statusValues.checkCompleted[lang] || statusValues.noBackupNeeded[lang];
            } else {
                statusText = statusValues.success[lang];
            }
        } else if (record.status === 'error') {
            statusText = record.errorMessage ? `${statusValues.error[lang]}: ${record.errorMessage}` : statusValues.error[lang];
        } else if (record.status === 'locked') {
            statusText = statusValues.locked[lang];
        }

        const fingerprint = record.fingerprint ? String(record.fingerprint) : '-';

        const safeNote = String(record.note || '').replace(/\|/g, '\\|');
        const safeStatusText = String(statusText || '').replace(/\|/g, '\\|');
        const safeFingerprint = String(fingerprint || '').replace(/\|/g, '\\|');

        const seqNumber = seqMap.get(String(record.time));
        const seqText = Number.isFinite(seqNumber) ? String(seqNumber) : '-';

        // 行数据
        mdContent += `| ${seqText} | ${safeNote} | ${time} | ${bookmarkChangeText} | ${folderChangeText} | ${movedText} | ${modifiedText} | ${locationText} | ${backupModeText} | ${safeStatusText} | ${safeFingerprint} |\n`;
    });

    // 最后添加日期分界线
    if (previousDateStr) {
        const formattedPreviousDate = lang === 'en' ?
            `${previousDateStr.split('-')[0]}-${previousDateStr.split('-')[1].padStart(2, '0')}-${previousDateStr.split('-')[2].padStart(2, '0')}` :
            `${previousDateStr.split('-')[0]}年${previousDateStr.split('-')[1]}月${previousDateStr.split('-')[2]}日`;
        mdContent += `|  | **${formattedPreviousDate}** |  |  |  |  |  |  |  |  |  |\n`;
    }

    return mdContent;
}
