# 书签画布双轨导出与沙箱导入系统实施计划书 (修订版 V2)

## 1. 项目目标 (Objective)
构建一套既能完美适配 Obsidian 第三方阅读，又能实现 100% 数据无损恢复的导出/导入系统。通过“双轨制”策略，解决“格式兼容”与“数据完整”之间的矛盾。

---

## 2. 导出系统 (Export System)

### 2.1 双轨模式选择 UI
在点击“导出”按钮时，增加一级弹窗，提供两种模式供用户选择：

*   **模式 A：Obsidian 兼容模式 (Obsidian Compatibility)**
    *   **定位**：笔记整理、分享、在 Obsidian 中查看。
    *   **特点**：以 Markdown 文件为核心，强调视觉还原。
    *   **风险提示**：“⚠️ **注意**：您可以在 Obsidian 中自由编辑 Markdown 笔记卡片。但请**避免通过编辑文本来修改书签树结构**（如移动书签层级），这可能导致导入时数据丢失。若需整理书签，建议在插件内操作。”
*   **模式 B：全量备份与 AI 数据模式 (Full Backup & AI Data)**
    *   **定位**：数据迁移、灾难恢复、存档、**AI 分析**。
    *   **特点**：以专用数据文件为核心，强调数据完整性与机器可读性。
    *   **提示**：“✅ **插件专用**：专为本插件的‘沙箱导入系统’设计，确保数据完整恢复。同时提供结构化 JSON 数据，**便于 AI 助手进行深度分析或数据处理（支持后续 AI 版本功能）**。”

### 2.2 文件结构策略
ZIP 包中将包含不同用途的文件：

1.  **视觉层 (`.md` / `.canvas`)**：
    *   所有模式下均生成。
    *   **Markdown 优化**：使用 HTML + Inline CSS 绘制书签树（连接线、对齐、长文本不换行、空文件夹标识），确保在 Obsidian 中视觉效果与插件一致。
2.  **补充层 (`bookmark-canvas.full.json`)**：
    *   用于存储 Markdown 无法记录的“样式数据”（颜色、滚动条位置、性能模式配置）。
    *   作为 Obsidian 模式的“补充补丁”。
3.  **核心数据层 (`bookmark-canvas.backup.json`)**：
    *   **仅在“模式 B”下生成。**
    *   **关键特性**：包含当前画布所有栏目的**完整数据对象树**（不仅仅是引用）。
        *   **永久栏目**：调用 Chrome API (`chrome.bookmarks.getTree`) 抓取当前时刻完整的书签树结构。
        *   **临时栏目**：递归序列化保存所有 Item 详情、说明文档。
        *   **连接线 & 节点**：完整的属性记录。

---

## 3. 导入系统 (Import System)

### 3.1 智能沙箱模式 (Sandboxed Import)
导入不再是简单的“覆盖”或“追加”，而是创建一个独立的“管理容器”。

*   **容器化 (Import Container)**：
    *   所有导入内容被一个**带有虚线边框和时间戳标签**的大型分组节点包裹。
    *   **空间删除 (Spatial Delete)**：容器本身提供“删除”按钮。点击时，执行碰撞检测——所有**仍位于框内**的元素会被一并删除；**移出框外**的元素则会被保留（即“择优录取”机制）。

### 3.2 冲突防御与数据清洗
*   **ID 重铸 (ID Remapping)**：
    *   导入时，强制为所有节点（栏目、卡片）和连接线生成全新的 UUID。
    *   确保多次导入同一个包也不会产生数据冲突，完美并存。
*   **永久栏目降级策略**：
    *   导入包中的“永久栏目”**不可**覆盖浏览器真实书签。
    *   它将自动转换为一个**“快照临时栏目”**（Snapshot Temp Section），颜色区分（如黄/绿），内容只读/可编辑，但与浏览器断开同步。

### 3.3 自动布局与交互
*   **寻找空地**：自动计算当前画布内容的最右侧边界，将新导入的容器放置在空白区域（避免重叠）。
*   **镜头跟随**：导入完成后，视图自动平滑飞行（Pan & Zoom）至新容器位置。
*   **滚动条恢复**：读取备份中的滚动位置数据，应用到新生成的 ID 上，确保用户看到的视图位置与导出时一致。

### 3.4 格式适配器 (Format Adapter)
导入系统必须具备“全能适配”能力，同时兼容以下两种输入：
1.  **ZIP 压缩包 (`.zip`)**：
    *   **处理逻辑**：自动解压 -> 递归深度搜索 `bookmark-canvas.backup.json` -> 若无则搜索 `bookmark-canvas.full.json`。
    *   **场景**：标准完整导出。
2.  **JSON 单文件 (`.json`)**：
    *   **处理逻辑**：直接读取并校验是否为合法的 Canvas State JSON。
    *   **场景**：用户提取的核心数据文件，或纯数据备份。

---

## 4. 关键规则细节 (Rules & Specifications)

### 4.1 视觉样式规则 (Markdown)
*   **树状连接线**：使用 HTML `div` border 和 `span` 实现垂直/水平连接线。
*   **长文本处理**：标题和 URL 强制单行显示 (`white-space: nowrap`)，超长自动省略 (`text-overflow: ellipsis`)，避免破坏布局。
*   **空状态**：空文件夹后自动追加 `(empty)` 灰色标识。

### 4.2 数据信任链
*   **优先级判断**：
    *   若发现 `bookmark-canvas.backup.json` -> **绝对信任该文件**（直接进入全量恢复流程，忽略 .md）。
    *   若仅有 `.md` 和 `.full.json` -> 尝试解析 `.md` 并用 `.full.json` 补充样式（降级体验）。

### 4.3 滚动位置
*   位置数据存储在 JSON 备份中。
*   导入时将位置写入 `localStorage`（映射到新 ID），实现“无副作用”的视图恢复。

---

## 5. 复杂性与风险控制 (Complexity & Risk Control)

### 5.1 数据结构适配 (Adapter Layer)
*   **挑战**：`chrome.bookmarks.getTree` 返回的数据结构（原生）与 Canvas 内部的 `TempSection` 数据结构（自定义）不一致。
*   **方案**：在导入逻辑中实现专用适配器 `__adaptChromeTreeToCanvasItems(chromeNodes)`，负责递归转换字段名（如 `children` -> `items`, `title` -> `name` 等）及补充缺失元数据。

### 5.2 资源持久化 (Asset Persistence)
*   **挑战**：Markdown 节点中的本地 Blob 图片在导出为 JSON/Text 时无法保存。
*   **方案**：
    *   目前阶段：在全量备份模式下，仅能保存文本和外部链接图片。
    *   用户提示：若 MD 节点包含本地粘贴的图片，导入后可能会显示 broken image。
    *   未来优化：考虑 Base64 嵌入（需评估 JSON 体积限制）。

### 5.3 文件搜索鲁棒性
*   **挑战**：用户可能解压后改变了文件夹层级，再打包。
*   **方案**：ZIP 读取器不应假定文件在根目录。应遍历 ZIP 中所有 Entry，以文件名后缀匹配目标文件。
