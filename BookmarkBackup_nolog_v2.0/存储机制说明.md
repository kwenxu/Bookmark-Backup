# 书签浏览记录数据存储说明

本文档记录最新实现的三套数据缓存机制，确保「书签添加记录」「点击记录」「点击排行」在首次加载后能够复用本地数据，并在有变动时做增量更新。

## 1. 书签添加记录（Additions）
- **缓存键：** `bb_cache_additions_v1`
- **存储位置：** 优先使用 `chrome.storage.local`，不可用时回落到 `localStorage`。
- **初次加载：**
  1. `ensureAdditionsCacheLoaded` 会尝试读取缓存并填充 `allBookmarks`，直接渲染列表。
  2. 若缓存不存在，调用 `chrome.bookmarks.getTree()` 全量拉取并写回缓存。
- **增量更新：**
  - 绑定书签 API 的 `onCreated/onRemoved/onChanged/onMoved` 事件，分别调用 `addBookmarkToAdditionsCache` 等函数在内存中更新对应记录，随后通过 `scheduleAdditionsCacheSave`（600ms 防抖）落盘。
  - 当前视图为 Additions 时，增量更新会自动触发 `renderAdditionsView()`。

## 2. 点击记录（日历视图）
- **缓存键：** `bb_cache_browsing_history_v1`
- **存储内容：** 以 `{ dateKey, records[] }` 的形式保存每一天的访问条目，记录中包含 `url/title/visitTime/visitCount/transition` 等字段，以及最近一次同步时间 `lastSyncTime`。
- **初次加载流程：**
  1. `restoreBrowsingHistoryCache` 尝试从缓存恢复 `bookmarksByDate`，并记录 `visitKeySet`（`url|visitTime`）用于去重。
  2. 如果缓存不存在，则执行 `loadBookmarkData({ incremental: false })`，即全量扫描浏览器历史。
- **增量加载：**
  - 页面启动后会立即触发 `loadBookmarkData({ incremental: true })`：
    - 以 `lastSyncTime - 60s` 作为 `startTime` 调用 `history.search`，避免错过临界点。
    - 仅新增未见过的访问记录（通过 `visitKeySet` 去重），并限制每个 URL 最多 400 条、仅保留近 365 天数据。
    - 每次同步后更新 `lastSyncTime`，保存缓存并触发自定义事件 `browsingHistoryCacheUpdated`。
- **缓存写入：** 任何全量或增量同步成功后都会调用 `saveBrowsingHistoryCache`。

## 3. 点击排行
- **依赖数据：** `ensureBrowsingClickRankingStats` 直接使用 `browsingHistoryCalendarInstance.bookmarksByDate`，不再单独读历史 API。
- **刷新策略：**
  - 监听 `browsingHistoryCacheUpdated` 事件，将内存中的 `browsingClickRankingStats` 置空，并重新加载当前激活的时间段（当天/当周/当月/当年）。
  - 用户选择的时间段保存在 `localStorage.browsingRankingActiveRange`，刷新后自动恢复。

## 4. 回退 / 无法持久化场景
- 若 `chrome.storage.local` 不可用，会自动回退到页面 `localStorage`，依旧具备相同的缓存与增量逻辑。
- 如果增量阶段报错，会退回到全量重建缓存，流程可自愈。

以上机制确保：
1. 页面刷新或重新打开时可以立即加载上一次的缓存数据，减少等待。
2. 后台增量同步完成后自动刷新 UI，同时把最新结果持久化，降低重复计算成本。
